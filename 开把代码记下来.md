

# 一、模拟

题目题解难度推荐指数[1. 两数之和](https://leetcode-cn.com/problems/two-sum/)[LeetCode 题解链接](https://leetcode-cn.com/problems/two-sum/solution/po-su-jie-fa-ha-xi-biao-jie-fa-by-ac_oie-yf7o/)简单✔🤩🤩🤩🤩🤩[2. 两数相加](https://leetcode-cn.com/problems/add-two-numbers/)[LeetCode 题解链接](https://leetcode-cn.com/problems/add-two-numbers/solution/po-su-jie-fa-shao-bing-ji-qiao-by-ac_oie-etln/)中等✔🤩🤩🤩🤩🤩[5. 最长回文子串](https://leetcode-cn.com/problems/longest-palindromic-substring/)[LeetCode 题解链接](https://leetcode-cn.com/problems/longest-palindromic-substring/solution/shua-chuan-lc-po-su-jie-fa-manacher-suan-i2px/)中等❗🤩🤩🤩🤩🤩[6. Z 字形变换](https://leetcode-cn.com/problems/zigzag-conversion/)[LeetCode 题解链接](https://leetcode-cn.com/problems/zigzag-conversion/solution/shua-chuan-lc-zhi-guan-gui-lu-jie-fa-shu-8226/)中等🤩🤩🤩[7. 整数反转](https://leetcode-cn.com/problems/reverse-integer/)[LeetCode 题解链接](https://leetcode-cn.com/problems/reverse-integer/solution/shua-chuan-lc-bu-wan-mei-jie-fa-wan-mei-919rd/)简单🤩🤩🤩[8. 字符串转换整数 (atoi)](https://leetcode-cn.com/problems/string-to-integer-atoi/)[LeetCode 题解链接](https://leetcode-cn.com/problems/string-to-integer-atoi/solution/shua-chuan-lc-jian-ji-jie-fa-by-ac_oier-69tp/)中等🤩🤩🤩[12. 整数转罗马数字](https://leetcode-cn.com/problems/integer-to-roman/)[LeetCode 题解链接](https://leetcode-cn.com/problems/integer-to-roman/solution/shua-chuan-lc-tan-xin-jie-fa-by-ac_oier-5kbw/)中等🤩🤩[13. 罗马数字转整数](https://leetcode-cn.com/problems/roman-to-integer/)[LeetCode 题解链接](https://leetcode-cn.com/problems/roman-to-integer/solution/shua-chuan-lc-ha-xi-biao-by-ac_oier-mooy/)简单🤩🤩[14. 最长公共前缀](https://leetcode-cn.com/problems/longest-common-prefix/)[LeetCode 题解链接](https://leetcode-cn.com/problems/longest-common-prefix/solution/shua-chuan-lc-die-dai-mo-ni-by-ac_oier-8t4q/)简单🤩🤩🤩🤩[31. 下一个排列](https://leetcode-cn.com/problems/next-permutation/)[LeetCode 题解链接](https://leetcode-cn.com/problems/next-permutation/solution/miao-dong-xi-lie-100-cong-xia-yi-ge-pai-gog8j/)中等🤩🤩🤩[38. 外观数列](https://leetcode-cn.com/problems/count-and-say/)[LeetCode 题解链接](https://leetcode-cn.com/problems/count-and-say/solution/shua-chuan-lc-100-mo-ni-ti-shi-yong-shao-w8jl/)简单🤩🤩[43. 字符串相乘](https://leetcode-cn.com/problems/multiply-strings/)[LeetCode 题解链接](https://leetcode-cn.com/problems/multiply-strings/solution/zhi-yao-ni-hui-shou-suan-cheng-fa-zhe-ti-ainl/)中等🤩🤩🤩🤩[58. 最后一个单词的长度](https://leetcode-cn.com/problems/length-of-last-word/)[LeetCode 题解链接](https://leetcode-cn.com/problems/length-of-last-word/solution/gong-shui-san-xie-jian-dan-zi-fu-chuan-m-tt6t/)中等🤩🤩🤩🤩[59. 螺旋矩阵 II](https://leetcode-cn.com/problems/spiral-matrix-ii/)[LeetCode 题解链接](https://leetcode-cn.com/problems/spiral-matrix-ii/solution/yi-ti-shuang-jie-xiang-jie-xing-zhuang-j-24x8/)中等🤩🤩🤩🤩[65. 有效数字](https://leetcode-cn.com/problems/valid-number/)[LeetCode 题解链接](https://leetcode-cn.com/problems/valid-number/solution/gong-shui-san-xie-zi-fu-chuan-mo-ni-by-a-7cgc/)困难🤩🤩🤩[66. 加一](https://leetcode-cn.com/problems/plus-one/)[LeetCode 题解链接](https://leetcode-cn.com/problems/plus-one/solution/gong-shui-san-xie-jian-dan-mo-ni-ti-by-a-5av1/)简单🤩🤩🤩🤩[68. 文本左右对齐](https://leetcode-cn.com/problems/text-justification/)[LeetCode 题解链接](https://leetcode-cn.com/problems/text-justification/solution/gong-shui-san-xie-zi-fu-chuan-mo-ni-by-a-s3v7/)困难🤩🤩🤩[73. 矩阵置零](https://leetcode-cn.com/problems/set-matrix-zeroes/)[LeetCode 题解链接](https://leetcode-cn.com/problems/set-matrix-zeroes/solution/xiang-jie-fen-san-bu-de-o1-kong-jian-jie-dbxd/)中等🤩🤩🤩🤩[165. 比较版本号](https://leetcode-cn.com/problems/compare-version-numbers/)[LeetCode 题解链接](https://leetcode-cn.com/problems/compare-version-numbers/solution/gong-shui-san-xie-jian-dan-zi-fu-chuan-m-xsod/)中等🤩🤩🤩🤩[166. 分数到小数](https://leetcode-cn.com/problems/fraction-to-recurring-decimal/)[LeetCode 题解链接](https://leetcode-cn.com/problems/fraction-to-recurring-decimal/solution/gong-shui-san-xie-mo-ni-shu-shi-ji-suan-kq8c4/)中等🤩🤩🤩🤩[168. Excel表列名称](https://leetcode-cn.com/problems/excel-sheet-column-title/)[LeetCode 题解链接](https://leetcode-cn.com/problems/excel-sheet-column-title/solution/gong-shui-san-xie-cong-1-kai-shi-de-26-j-g2ur/)简单🤩🤩🤩[171. Excel表列序号](https://leetcode-cn.com/problems/excel-sheet-column-number/)[LeetCode 题解链接](https://leetcode-cn.com/problems/excel-sheet-column-number/solution/gong-shui-san-xie-tong-yong-jin-zhi-zhua-y5fm/)简单🤩🤩🤩[190. 颠倒二进制位](https://leetcode-cn.com/problems/reverse-bits/)[LeetCode 题解链接](https://leetcode-cn.com/problems/reverse-bits/solution/yi-ti-san-jie-dui-cheng-wei-zhu-wei-fen-ub1hi/)简单🤩🤩🤩[233. 数字 1 的个数](https://leetcode-cn.com/problems/number-of-digit-one/)[LeetCode 题解链接](https://leetcode-cn.com/problems/number-of-digit-one/solution/gong-shui-san-xie-jiang-shu-wei-dp-wen-t-c9oi/)困难🤩🤩🤩🤩[237. 删除链表中的节点](https://leetcode-cn.com/problems/delete-node-in-a-linked-list/)[LeetCode 题解链接](https://leetcode-cn.com/problems/delete-node-in-a-linked-list/solution/gong-shui-san-xie-jian-dan-lian-biao-mo-rovcb/)简单🤩🤩🤩[260. 只出现一次的数字 III](https://leetcode-cn.com/problems/single-number-iii/)[LeetCode 题解链接](https://leetcode-cn.com/problems/single-number-iii/solution/gong-shui-san-xie-yi-ti-shuang-jie-ha-xi-zgi4/)中等🤩🤩🤩🤩[263. 丑数](https://leetcode-cn.com/problems/ugly-number/)[LeetCode 题解链接](https://leetcode-cn.com/problems/ugly-number/solution/gong-shui-san-xie-jian-dan-de-fen-qing-k-dlvg/)简单🤩🤩[268. 丢失的数字](https://leetcode-cn.com/problems/missing-number/)[LeetCode 题解链接](https://leetcode-cn.com/problems/missing-number/solution/gong-shui-san-xie-yi-ti-wu-jie-pai-xu-ji-te3s/)简单🤩🤩🤩🤩[273. 整数转换英文表示](https://leetcode-cn.com/problems/integer-to-english-words/)[LeetCode 题解链接](https://leetcode-cn.com/problems/integer-to-english-words/solution/gong-shui-san-xie-zi-fu-chuan-da-mo-ni-b-0my6/)困难🤩🤩🤩🤩[284. 顶端迭代器](https://leetcode-cn.com/problems/peeking-iterator/)[LeetCode 题解链接](https://leetcode-cn.com/problems/peeking-iterator/solution/gong-shui-san-xie-die-dai-qi-ji-ben-ren-b77lz/)中等🤩🤩🤩🤩[299. 猜数字游戏](https://leetcode-cn.com/problems/bulls-and-cows/)[LeetCode 题解链接](https://leetcode-cn.com/problems/bulls-and-cows/solution/gong-shui-san-xie-jian-dan-mo-ni-ti-by-a-tdhs/)中等🤩🤩🤩🤩[335. 路径交叉](https://leetcode-cn.com/problems/self-crossing/)[LeetCode 题解链接](https://leetcode-cn.com/problems/self-crossing/solution/gong-shui-san-xie-fen-qing-kuang-tao-lun-zdrb/)困难🤩🤩🤩🤩[345. 反转字符串中的元音字母](https://leetcode-cn.com/problems/reverse-vowels-of-a-string/)[LeetCode 题解链接](https://leetcode-cn.com/problems/reverse-vowels-of-a-string/solution/gong-shui-san-xie-note-bie-pian-shuang-z-c8ii/)简单🤩🤩🤩[405. 数字转换为十六进制数](https://leetcode-cn.com/problems/convert-a-number-to-hexadecimal/)[LeetCode 题解链接](https://leetcode-cn.com/problems/convert-a-number-to-hexadecimal/solution/gong-shui-san-xie-yi-ti-shuang-jie-jin-z-d93o/)简单🤩🤩🤩🤩[412. Fizz Buzz](https://leetcode-cn.com/problems/fizz-buzz/)[LeetCode 题解链接](https://leetcode-cn.com/problems/fizz-buzz/solution/gong-shui-san-xie-jian-dan-mo-ni-ti-by-a-jll0/)简单🤩🤩🤩🤩[413. 等差数列划分](https://leetcode-cn.com/problems/arithmetic-slices/)[LeetCode 题解链接](https://leetcode-cn.com/problems/arithmetic-slices/solution/gong-shui-san-xie-shuang-zhi-zhen-qiu-ji-ef1q/)中等🤩🤩🤩🤩[414. 第三大的数](https://leetcode-cn.com/problems/third-maximum-number/)[LeetCode 题解链接](https://leetcode-cn.com/problems/third-maximum-number/solution/gong-shui-san-xie-yi-ti-shuang-jie-pai-x-pmln/)中等🤩🤩🤩🤩[434. 字符串中的单词数](https://leetcode-cn.com/problems/number-of-segments-in-a-string/)[LeetCode 题解链接](https://leetcode-cn.com/problems/number-of-segments-in-a-string/solution/gong-shui-san-xie-jian-dan-zi-fu-mo-ni-t-0gx6/)简单🤩🤩🤩🤩[443. 压缩字符串](https://leetcode-cn.com/problems/string-compression/)[LeetCode 题解链接](https://leetcode-cn.com/problems/string-compression/solution/gong-shui-san-xie-shuang-zhi-zhen-yuan-d-bppu/)中等🤩🤩🤩🤩[451. 根据字符出现频率排序](https://leetcode-cn.com/problems/sort-characters-by-frequency/)[LeetCode 题解链接](https://leetcode-cn.com/problems/sort-characters-by-frequency/solution/gong-shui-san-xie-shu-ju-jie-gou-yun-yon-gst9/)中等🤩🤩🤩🤩[457. 环形数组是否存在循环](https://leetcode-cn.com/problems/circular-array-loop/)[LeetCode 题解链接](https://leetcode-cn.com/problems/circular-array-loop/solution/gong-shui-san-xie-yi-ti-shuang-jie-mo-ni-ag05/)中等🤩🤩🤩🤩[482. 密钥格式化](https://leetcode-cn.com/problems/license-key-formatting/)[LeetCode 题解链接](https://leetcode-cn.com/problems/license-key-formatting/solution/gong-shui-san-xie-jian-dan-zi-fu-chuan-m-piya/)简单🤩🤩🤩🤩[492. 构造矩形](https://leetcode-cn.com/problems/construct-the-rectangle/)[LeetCode 题解链接](https://leetcode-cn.com/problems/construct-the-rectangle/solution/gong-shui-san-xie-jian-dan-mo-ni-ti-by-a-7ser/)简单🤩🤩🤩🤩[495. 提莫攻击](https://leetcode-cn.com/problems/teemo-attacking/)[LeetCode 题解链接](https://leetcode-cn.com/problems/teemo-attacking/solution/gong-shui-san-xie-jian-dan-mo-ni-ti-by-a-gteh/)简单✔🤩🤩🤩🤩🤩[500. 键盘行](https://leetcode-cn.com/problems/keyboard-row/)[LeetCode 题解链接](https://leetcode-cn.com/problems/keyboard-row/solution/gong-shui-san-xie-jian-dan-zi-fu-chuan-m-zx6b/)简单🤩🤩🤩🤩[520. 检测大写字母](https://leetcode-cn.com/problems/detect-capital/)[LeetCode 题解链接](https://leetcode-cn.com/problems/detect-capital/solution/gong-shui-san-xie-jian-dan-zi-fu-chuan-m-rpor/)简单🤩🤩🤩🤩[528. 按权重随机选择](https://leetcode-cn.com/problems/random-pick-with-weight/)[LeetCode 题解链接](https://leetcode-cn.com/problems/random-pick-with-weight/solution/gong-shui-san-xie-yi-ti-shuang-jie-qian-8bx50/)中等🤩🤩🤩🤩[541. 反转字符串 II](https://leetcode-cn.com/problems/reverse-string-ii/)[LeetCode 题解链接](https://leetcode-cn.com/problems/reverse-string-ii/solution/gong-shui-san-xie-jian-dan-zi-fu-chuan-m-p88f/)简单✔❗🤩🤩🤩🤩🤩[551. 学生出勤记录 I](https://leetcode-cn.com/problems/student-attendance-record-i/)[LeetCode 题解链接](https://leetcode-cn.com/problems/student-attendance-record-i/solution/gong-shui-san-xie-jian-dan-mo-ni-ti-by-a-hui7/)简单🤩🤩🤩[566. 重塑矩阵](https://leetcode-cn.com/problems/reshape-the-matrix/)[LeetCode 题解链接](https://leetcode-cn.com/problems/reshape-the-matrix/solution/jian-dan-ti-zhong-quan-chu-ji-ke-yi-kan-79gv5/)简单🤩🤩🤩[598. 范围求和 II](https://leetcode-cn.com/problems/range-addition-ii/)[LeetCode 题解链接](https://leetcode-cn.com/problems/range-addition-ii/solution/gong-shui-san-xie-jian-dan-mo-ni-ti-by-a-006h/)简单🤩🤩🤩[645. 错误的集合](https://leetcode-cn.com/problems/set-mismatch/)[LeetCode 题解链接](https://leetcode-cn.com/problems/set-mismatch/solution/gong-shui-san-xie-yi-ti-san-jie-ji-shu-s-vnr9/)简单🤩🤩🤩[726. 原子的数量](https://leetcode-cn.com/problems/number-of-atoms/)[LeetCode 题解链接](https://leetcode-cn.com/problems/number-of-atoms/solution/gong-shui-san-xie-shi-yong-xiao-ji-qiao-l5ak4/)困难🤩🤩🤩🤩[766. 托普利茨矩阵](https://leetcode-cn.com/problems/toeplitz-matrix/)[LeetCode 题解链接](https://leetcode-cn.com/problems/toeplitz-matrix/solution/cong-ci-pan-du-qu-cheng-ben-fen-xi-liang-f20w/)简单🤩🤩🤩[867. 转置矩阵](https://leetcode-cn.com/problems/transpose-matrix/)[LeetCode 题解链接](https://leetcode-cn.com/problems/transpose-matrix/solution/yi-you-wei-jin-huo-xu-ni-neng-kan-kan-zh-m53m/)简单🤩🤩🤩🤩[896. 单调数列](https://leetcode-cn.com/problems/monotonic-array/)[LeetCode 题解链接](https://leetcode-cn.com/problems/monotonic-array/solution/wei-shi-yao-yi-ci-bian-li-yao-bi-liang-c-uglp/)简单🤩🤩🤩🤩[1047. 删除字符串中的所有相邻重复项](https://leetcode-cn.com/problems/remove-all-adjacent-duplicates-in-string/)[LeetCode 题解链接](https://leetcode-cn.com/problems/remove-all-adjacent-duplicates-in-string/solution/cong-30-dao-100wu-chong-shi-xian-jie-jue-vkah/)简单🤩🤩🤩🤩[1104. 二叉树寻路](https://leetcode-cn.com/problems/path-in-zigzag-labelled-binary-tree/)[LeetCode 题解链接](https://leetcode-cn.com/problems/path-in-zigzag-labelled-binary-tree/solution/gong-shui-san-xie-yi-ti-shuang-jie-mo-ni-rw2d/)中等🤩🤩🤩[1436. 旅行终点站](https://leetcode-cn.com/problems/destination-city/)[LeetCode 题解链接](https://leetcode-cn.com/problems/destination-city/solution/gong-shui-san-xie-jian-dan-fang-jia-mo-n-y47c/)简单✔❗🤩🤩🤩🤩🤩[1480. 一维数组的动态和](https://leetcode-cn.com/problems/running-sum-of-1d-array/)[LeetCode 题解链接](https://leetcode-cn.com/problems/running-sum-of-1d-array/solution/gong-shui-san-xie-yi-wei-qian-zhui-he-mo-g8hn/)简单✔🤩🤩🤩🤩🤩[1486. 数组异或操作](https://leetcode-cn.com/problems/xor-operation-in-an-array/)[LeetCode 题解链接](https://leetcode-cn.com/problems/xor-operation-in-an-array/solution/gong-shui-san-xie-yi-ti-shuang-jie-mo-ni-dggg/)简单🤩🤩🤩[1583. 统计不开心的朋友](https://leetcode-cn.com/problems/count-unhappy-friends/)[LeetCode 题解链接](https://leetcode-cn.com/problems/count-unhappy-friends/solution/gong-shui-san-xie-ha-xi-biao-mo-ni-ti-by-2qy0/)中等🤩🤩🤩🤩[1646. 获取生成数组中的最大值](https://leetcode-cn.com/problems/get-maximum-in-generated-array/)[LeetCode 题解链接](https://leetcode-cn.com/problems/get-maximum-in-generated-array/solution/gong-shui-san-xie-jian-dan-mo-ni-ti-by-a-sj53/)简单🤩🤩🤩🤩[1720. 解码异或后的数组](https://leetcode-cn.com/problems/decode-xored-array/)[LeetCode 题解链接](https://leetcode-cn.com/problems/decode-xored-array/solution/gong-shui-san-xie-li-yong-yi-huo-xing-zh-p1bi/)简单🤩🤩🤩[1736. 替换隐藏数字得到的最晚时间](https://leetcode-cn.com/problems/latest-time-by-replacing-hidden-digits/)[LeetCode 题解链接](https://leetcode-cn.com/problems/latest-time-by-replacing-hidden-digits/solution/gong-shui-san-xie-ti-huan-yin-cang-shu-z-2l1h/)简单🤩🤩🤩🤩[1743. 从相邻元素对还原数组](https://leetcode-cn.com/problems/restore-the-array-from-adjacent-pairs/)[LeetCode 题解链接](https://leetcode-cn.com/problems/restore-the-array-from-adjacent-pairs/solution/gong-shui-san-xie-yi-ti-shuang-jie-dan-x-elpx/)中等🤩🤩🤩🤩[1748. 唯一元素的和](https://leetcode-cn.com/problems/sum-of-unique-elements/)[LeetCode 题解链接](https://leetcode-cn.com/problems/sum-of-unique-elements/solution/mo-ni-ti-po-su-jie-fa-by-ac_oier-ff69/)简单🤩🤩[1763. 最长的美好子字符串](https://leetcode-cn.com/problems/longest-nice-substring/)[LeetCode 题解链接](https://leetcode-cn.com/problems/longest-nice-substring/solution/cong-shu-ju-fan-wei-xuan-ze-he-gua-suan-n3y2a/)简单🤩🤩🤩[1834. 单线程 CPU](https://leetcode-cn.com/problems/single-threaded-cpu/)[LeetCode 题解链接](https://leetcode-cn.com/problems/single-threaded-cpu/solution/gong-shui-san-xie-shu-ju-jie-gou-yun-yon-1qk0/)中等🤩🤩🤩🤩[1893. 检查是否区域内所有整数都被覆盖](https://leetcode-cn.com/problems/check-if-all-the-integers-in-a-range-are-covered/)[LeetCode 题解链接](https://leetcode-cn.com/problems/check-if-all-the-integers-in-a-range-are-covered/solution/gong-shui-san-xie-yi-ti-shuang-jie-mo-ni-j83x/)简单🤩🤩🤩🤩[1894. 找到需要补充粉笔的学生编号](https://leetcode-cn.com/problems/find-the-student-that-will-replace-the-chalk/)[LeetCode 题解链接](https://leetcode-cn.com/problems/find-the-student-that-will-replace-the-chalk/solution/gong-shui-san-xie-yi-ti-shuang-jie-qian-kpqsk/)中等🤩🤩🤩🤩[面试题 10.02. 变位词组](https://leetcode-cn.com/problems/group-anagrams-lcci/)[LeetCode 题解链接](https://leetcode-cn.com/problems/group-anagrams-lcci/solution/gong-shui-san-xie-tong-ji-bian-wei-ci-de-0iqe/)中等🤩🤩🤩🤩

#### 1.两数之和：i+j=target，哈希

> 遍历i，看所过之处，有没有互补的

```C%2B%2B
class Solution {
public:
    vector<int> twoSum(vector<int>& nums, int target) {
        unordered_map<int, int> heap;
        for (int i = 0; i < nums.size(); i ++ ) {
            int r = target - nums[i];
            if (heap.count(r)) return {heap[r], i};
            heap[nums[i]] = i;
        }

        return {};
    }
};
class Solution:
    def twoSum(self, nums: List[int], target: int) -> List[int]:
    
        # 解法一，常规双循环
        lenNums = len(nums)
        for i in range(lenNums):
            for j in range(i+1, lenNums):
                if nums[i] + nums[j] == target:
                    return i,j  # return [i,j] 这两个return效果是一样的?
        # 并不是，这里只是写了个函数，并不涉及输入输出之类

        # 解法二，用set类型
        setNums = set(nums)
        for i in range(len(nums)):
            if target - nums[i] in setNums:
                index = nums.index(target - nums[i])
                if index == i:
                    continue
                return i, index

        # 解法三，用hash表，但核心是不要预先构建hash表
        dicNums = {}
        for i in range(len(nums)):
            if nums[i] in dicNums:
                return dicNums[nums[i]], i
            dicNums[target - nums[i]] = i   # 核心是这句，一边查表，一边建表
```

#### 2.两数相加：基于链表 竖式相加

```C%2B%2B
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {
        ListNode* head = new ListNode(-1);
        ListNode* p = head;
        bool carry = false; //进位
        int sum = 0;
        while(l1 || l2){
            sum = 0; //⭐不要忘记写，每次sum要清空给下一次用
            if(l1){
                sum += l1->val;
                l1 = l1->next;
            }
            if(l2){
                sum += l2->val;
                l2 = l2->next;
            }
            if(carry)
                sum++;
            p->next = new ListNode(sum % 10);
            carry = sum >= 10 ? true : false; //⭐>=，不是大于
            p = p->next;
        }
        //当l1,l2都到最后为空，且有进位时
        if(carry)
            p->next = new ListNode(1); //p->next⭐
        
        return head->next;
    }
};
//不能用l1.next
//error: member reference type 'ListNode *' is a pointer; did you mean to use '->'?
//一个搞ACM的人写的代码，很干净简洁
    ListNode *addTwoNumbers(ListNode *l1, ListNode *l2) {
        ListNode* head = new ListNode();
        ListNode* currentPos = head;
        int v = 0;
        while(l1 || l2 || v) {
            int v1 = l1 ? l1->val : 0, v2 = l2 ? l2->val : 0; //不空为val，空位0
            int res = (v + v1 + v2) / 10;
            v = (v1 + v2 + v) % 10;
            currentPos->val = v;
            v = res;
            if (l1) l1 = l1->next;
            if (l2) l2 = l2->next;
            if (l1 || l2 || v) {
                currentPos->next = new ListNode();
                currentPos = currentPos->next;
            }
        }
        return head;
    }
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def addTwoNumbers(self, l1: ListNode, l2: ListNode) -> ListNode:
        result = ListNode(0)
        r=result
        carry=0
        while(l1 or l2):
            x= l1.val if l1 else 0
            y= l2.val if l2 else 0
            s = carry + x + y
            carry = s//10  # 返回商的整数部分
            r.next = ListNode( s % 10)
            r = r.next
            if(l1!=None):
                l1=l1.next
            if(l2!=None):
                l2=l2.next
        if(carry>0):
            r.next=ListNode(1)
        
        return result.next
```

#### 5.最长回文子串：中心扩展

官方题解：动态规划、中心扩展、manacher马拉车？

**中心扩展**

> 还是用中心扩展吧

```C%2B%2B
//自己的
class Solution {
public:
    string longestPalindrome(string s) {
        string ans = "";
        for (int i = 0; i < s.length(); i++) {
            // 先看回文串为奇数个时，左一个右一个
            int l = i - 1, r = i + 1;
            string sub = getString(s, l, r);
            if (sub.length() > ans.length()) ans = sub;
            // 再看回文串为偶数个时，右一个
            //i=0时直接看右边的
            l = i, r = i + 1;
            sub = getString(s, l, r);
            if (sub.length() > ans.length()) ans = sub;
        }
        return ans;
    }
    string getString(string s, int l, int r) {
        //计算以left和right为中心的回文串
        int left = l, right = r;
        while (left >= 0 && right < s.length() && s[left] == s[right]) {
            left--;
            right++;
        } 
        //向左右扩，return right-left-1
        //计算真实值要先把r和l恢复，(right-1)-(left+1)+1=r-l-1
        return s.substr(left + 1, right-left-1); //注意，这个子串的方法不同于Java！⭐
    }
};
//Java中：s.charAt(i) 指的是取字符串中下标i的
//C++中，求子串s.substr(a,b) 从a开始的b个
# 一个抄来的
class Solution:
    def longestPalindrome(self, s: str) -> str:
        maxl, max_len = 0, 0
        n = len(s)
        for i in range(2*n-1):
            l = i//2
            r = i//2 + i%2
            while l >= 0 and r < n and s[l] == s[r]:
                if r-l+1 > max_len: 
                    maxl = l
                    max_len = r-l+1
                l-=1
                r+=1
        return s[maxl : maxl+max_len]
# 终于，把自己的代码写出来了
class Solution:
    def longestPalindrome(self, s: str) -> str:
        ans=""
        for i in range(len(s)):
            l = i - 1
            r = i + 1
            sub = self.getString(s, l, r)
            if len(sub) > len(ans):
                ans = sub
            
            l = i
            r = i + 1
            sub = self.getString(s, l, r)
            if len(sub) > len(ans):
                ans = sub
        return ans


    def getString(self, s, l, r):
        left = l
        right = r
        while left >= 0 and right <len(s) and s[left] == s[right]:
            left-=1
            right+=1
        return s[left + 1:right]
# 对并另一个简洁好看的
   def longestPalindrome(self, s: str) -> str:
        res = ''
        for i in range(len(s)):
            s1 = self.find(s, i, i)       # 以当前字符为中心的最长回文子串，（奇数个）
            s2 = self.find(s, i, i+1)     # 以当前字符和下一字符为中心的最长回文子串
            #如果最大长度有变化则更新res
            if max(len(s1), len(s2)) > len(res):
                res = s2 if len(s1) < len(s2) else s1
        return res

    def find(self, s, left, right):
        #找到当前中心的最大长度子串
        while left >= 0 and right < len(s) and s[left] == s[right]:
            left -= 1
            right += 1
        return s[left+1:right]
```

**动态规划**

```C%2B%2B
//自己的一个版本，很尴尬，错了

//输入："cbbd"
//输出："c"
//预期结果："bb"
class Solution {
public:
    string longestPalindrome(string s){
        int n = s.size();
        int max = 1, begin = 0; //得在外面定义⭐
        if(n <= 2) return s;
        vector<vector<int>> dp(n,vector<int>(n));
        //根据边界条件，初始化！
        for(int i = 0; i < n; i++){
            dp[i][i] = true;
            if(s[i]==s[i+1] && i<n-1) dp[i][i+1] = true; 
        }

        for(int l = 3; l < n; l++){
            for(int i=0; i < n; i++){
                int j = l - i + 1;
                if(j >= n) break;
                if(s[i] != s[j]) dp[i][j] = false;
                //really??
                else{
                    dp[i][j] = true;
                    dp[i][j] = dp[i+1][j-1];
                }

                //output
                if(dp[i][j] && j-i+1 > max){
                    max = j-i+1;
                    begin = i;
                }
            }
        }
        return s.substr(begin, max);
    }
};
//官方题解
class Solution {
public:
    string longestPalindrome(string s) {
        int n = s.size();
        if (n < 2) {
            return s;
        }

        int maxLen = 1;
        int begin = 0;
        // dp[i][j] 表示 s[i..j] 是否是回文串
        vector<vector<int>> dp(n, vector<int>(n));
        // 初始化：所有长度为 1 的子串都是回文串
        for (int i = 0; i < n; i++) {
            dp[i][i] = true;
        }
        // 递推开始
        // 先枚举子串长度
        for (int L = 2; L <= n; L++) {
            // 枚举左边界，左边界的上限设置可以宽松一些
            for (int i = 0; i < n; i++) {
                // 由 L 和 i 可以确定右边界，即 j - i + 1 = L 得
                int j = L + i - 1;
                // 如果右边界越界，就可以退出当前循环
                if (j >= n) {
                    break;
                }

                if (s[i] != s[j]) {
                    dp[i][j] = false;
                } else {
                    if (j - i < 3) {
                        dp[i][j] = true;
                    } else {
                        dp[i][j] = dp[i + 1][j - 1];
                    }
                }

                // 只要 dp[i][L] == true 成立，就表示子串 s[i..L] 是回文，此时记录回文长度和起始位置
                if (dp[i][j] && j - i + 1 > maxLen) {
                    maxLen = j - i + 1;
                    begin = i;
                }
            }
        }
        return s.substr(begin, maxLen);
    }
};
```

**Manacher 算法**



#### [89. 格雷编码](https://leetcode-cn.com/problems/gray-code/)：对称生成的方法

![img](https://uestc.feishu.cn/space/api/box/stream/download/asynccode/?code=Y2QxOTc0OWJlMDJkZTZkOGJhY2Q3ZjNkZjg5Zjg2OTlfT0NUTVFlVzdFMW9xblkxckVLVmZxVlFJMWxybDVJOW5fVG9rZW46Ym94Y250cjZEeko5elg4cmc4TmRSendxem9jXzE2NTY0ODY2MTE6MTY1NjQ5MDIxMV9WNA)

**法1：对称生成？倒序拼接**

```C%2B%2B
class Solution {
public:
    vector<int> grayCode(int n) {
        vector<int> ans;  // n>=1
        ans.push_back(0);
        ans.push_back(1);
        int add = 2;
        for(int i = 2; i <= n; i++){
            for(int j = add - 1; j >= 0; --j)
                ans.push_back(ans[j] + add);  // 倒着增加如ans向量
            add *= 2;
        }
        return ans;
    }
};
```





**法2：直接利用定义构造格雷编码**









#### [112. 路径总和](https://leetcode-cn.com/problems/path-sum/)：直接递归 / DFS / BFS ⭐面试题

![img](https://uestc.feishu.cn/space/api/box/stream/download/asynccode/?code=YjdlOWZkMzQ1YjNkZDVmMGE1YjYxNmY1ZGE1ZmVkMTRfYWJrb0lBbEhRcTV2TXl2YjZsYTNYQ1V5Y05WSW9jM0dfVG9rZW46Ym94Y25CVU5sOW10YzhEZDZqMkJnVmZGMlVVXzE2NTY0ODY2MTE6MTY1NjQ5MDIxMV9WNA)

这道题面试的时候遇到了⭐

推荐题解：

- [C++DFS/BFS - 路径总和 - 力扣（LeetCode） (leetcode-cn.com)](https://leetcode-cn.com/problems/path-sum/solution/cdfsbfs-by-sscicada-vhh5/)
- [路径总和的四种解法：DFS、回溯、BFS、栈 - 路径总和 - 力扣（LeetCode） (leetcode-cn.com)](https://leetcode-cn.com/problems/path-sum/solution/lu-jing-zong-he-de-si-chong-jie-fa-dfs-hui-su-bfs-/)

**法1：递归（结合着DFS的思想）**

```Python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right

class Solution:
    def hasPathSum(self, root:TreeNode, sum: int) -> bool:
        if not root:
            return False
        if not root.left and not root.right:
            return sum == root.val
        return self.hasPathSum(root.left, sum-root.val) or self.hasPathSum(root.right, sum-root.val)
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */

class Solution {
public:
    bool hasPathSum(TreeNode* root, int sum) {
        if(root == nullptr) 
            return false;
        if(root->left == nullptr && root->right == nullptr)
            return sum == root->val;
        return hasPathSum(root->left, sum-root->val) || hasPathSum(root->right, sum-root->val);
    }
};
```

**法2：DFS用栈**

```Python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def hasPathSum(self, root: TreeNode, target: int) -> bool:
        if not root: 
            return False
        return self.dfs(root, target, [root.val])
    
    def dfs(self, root, target, path):
        if not root: 
            return False
        if sum(path) == target and not root.left and not root.right:
            return True
        lflag, rflag = False, False
        if root.left:
            lflag = self.dfs(root.left, target, path+[root.left.val])
        if root.right:
            rflag = self.dfs(root.right, target, path+[root.right.val])
        return lflag or rflag
```

其中，注意列表的拼接

![img](https://uestc.feishu.cn/space/api/box/stream/download/asynccode/?code=YTZlYWJkMzk1YTE1OGNmZjY2YTkwYzIzYmEyYjlmZjFfbUZJdWEwelc0dzk3TGhDclZBd0c3VDg3elBGMFVjR2JfVG9rZW46Ym94Y25tM3lmS3lVMjhUNldPUWR4c1FVbUszXzE2NTY0ODY2MTE6MTY1NjQ5MDIxMV9WNA)

如果使用C++，需要注意一个问题：

加上cur值后还需要减去它！！

以下的方法是有问题的

![img](https://uestc.feishu.cn/space/api/box/stream/download/asynccode/?code=Nzg5MTgxNTA1NGQ1OGMzMDNkMDIwMDg4NTAwMzQ0YmNfbm94WDlxTzV4djBDbHhxVlo0VVJRZWsyTEFHMmlJRGZfVG9rZW46Ym94Y25TREFPTVo4NXRvM3k2Sm9uYUoxUWRoXzE2NTY0ODY2MTE6MTY1NjQ5MDIxMV9WNA)

正解：

```C%2B%2B
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */

class Solution {
public:
    // vector<int> path;
    int cur = 0;
    bool hasPathSum(TreeNode* root, int sum) {
        if(root == nullptr) 
            return false;
        // path.push_back(root->val);
        return dfs(root, sum);
    }
    bool dfs(TreeNode* root, int sum){
        if(root == nullptr)
            return false;
        cur += root->val;
        if(cur == sum && root->left == nullptr && root->right == nullptr)
            return true;
        if(root->left){
            if(dfs(root->left, sum)) return true;
            cur -= root->left->val;
        }
        if(root->right){
            if(dfs(root->right, sum)) return true;
            cur -= root->right->val;
        }
        return false;
    }
};
```

![img](https://uestc.feishu.cn/space/api/box/stream/download/asynccode/?code=Y2E1ZGIxOGYwYjVlNmNiZGQyZGE1NGYwZTEwOGEyZTRfR3ZqZDdvczUwcHcxWWxzWlRiNGZGQ2ZaQ1dvZHJwaUFfVG9rZW46Ym94Y25aZzBZVTJYVXZZbEs1RnhKNzFmNHhoXzE2NTY0ODY2MTE6MTY1NjQ5MDIxMV9WNA)



**法3：BFS用队列**

```Python
class Solution:
    def hasPathSum(self, root: TreeNode, sum: int) -> bool:
        if not root:
            return False
        que = collections.deque()
        que.append((root, root.val))
        while que:
            node, cur = que.popleft()
            if not node.left and not node.right and cur == sum:
                return True
            if node.left:
                que.append((node.left, cur + node.left.val))
            if node.right:
                que.append((node.right, cur + node.right.val))
        return False
class Solution {
public:
// 维护两个队列，一个存放节点，一个存放根节点到该节点路径的和
// 一层一层遍历，遍历找到了没有左右孩子并且和等于 targetSum 的节点，就 return true
// 没有找到就 return false
    bool hasPathSum(TreeNode* root, int targetSum) {
        if (root == nullptr) return false;
        queue<TreeNode*> node_que;
        queue<int> cur;
        node_que.push(root);
        cur.push(root->val);
        while (!node_que.empty()) {
            int size = node_que.size();
            for (int i = 0; i < size; ++i) {
                TreeNode *t = node_que.front();
                node_que.pop();
                int temp = cur.front();
                cur.pop();
                if (!t->left && !t->right && temp == targetSum) {
                    return true;
                }
                if (t->left) {
                    node_que.push(t->left);
                    int m = temp + t->left->val;
                    cur.push(m);
                }
                if (t->right) {
                    node_que.push(t->right);
                    int m = temp + t->right->val;
                    cur.push(m);
                }
            }
        }
        return false;
    }
}; 
```

**法4：直接用栈**

![img](https://uestc.feishu.cn/space/api/box/stream/download/asynccode/?code=ZmU5YzJhM2Q4MzZhZWRmNTM3MGJlZTY2NjFmOGEyOTlfTENNeWV4bm9yeWZVU3ZRdmtjaEdONDlrTnFLSk1TQ2RfVG9rZW46Ym94Y243VUJzRnU4M1RpdWI2bXdwRWZoenNjXzE2NTY0ODY2MTE6MTY1NjQ5MDIxMV9WNA)



#### [324. 摆动排序 II](https://leetcode.cn/problems/wiggle-sort-ii/)：不能想得太简单

```C%2B%2B
这个就是想的太简单了：
    如果[1,5,1,1,6,4]，就会输出[1,1,1,5,4,6]，显然是错的
    void wiggleSort(vector<int>& nums) {
        int n = nums.size();
        if (n == 1) return;
        sort(nums.begin(), nums.end());
        for (int i = 1; i < n - 1; i += 2) {
            swap(nums[i], nums[i + 1]);
        }
```

可以看一下官方题解

```C%2B%2B
class Solution {
public:
    void wiggleSort(vector<int>& nums) {
        int n = nums.size();
        vector<int> tmp = nums;
        sort(tmp.begin(), tmp.end());
        int mid = (n + 1) / 2;
        for (int i = 0, j = mid - 1, k = n - 1; i < n; i += 2, j--, k--) {
            nums[i] = tmp[j];
            if (i + 1 < n) nums[i + 1] = tmp[k];
        }
    }
};
```



#### [383. 赎金信](https://leetcode-cn.com/problems/ransom-note/)：统计词频，counter()函数 相减

![img](https://uestc.feishu.cn/space/api/box/stream/download/asynccode/?code=ZTE1NzRkY2ZkODUzNmE3ZWRjY2E3ODFlM2E5YWUzMDdfekF5cHlXNlZxd2FIeGkxVFZWc3hjWlo4aFRaSFVCaWJfVG9rZW46Ym94Y25zc3dYdm1pd1lZclFWSXZyUWp1YWxnXzE2NTY0ODY2MTE6MTY1NjQ5MDIxMV9WNA)![img](https://uestc.feishu.cn/space/api/box/stream/download/asynccode/?code=ZmFmOGYzMTcxYWEzNWRlOTNkN2M3YmUyODQzZjRhYmVfTURWdVFMbjBDMFpKdWt6aEZGTk9hb0xqaEprVGtjYWZfVG9rZW46Ym94Y25vNnhtaDBLbzdWU1VYaDdzSFkzc01lXzE2NTY0ODY2MTE6MTY1NjQ5MDIxMV9WNA)

思路就是直接统计词频，

```C%2B%2B
class Solution {
public:
    // 统计词频
    bool canConstruct(string ransomNote, string magazine) {
        vector<int> cnt(26);
        for(char c: magazine) 
            cnt[c-'a']++;
        for(char c: ransomNote) 
            if(--cnt[c-'a'] < 0)
                return false;
        return true;
    }
};
```

python一行代码解决问题：

```Python
class Solution:
    def canConstruct(self, ransomNote: str, magazine: str) -> bool:
        return not collections.Counter(ransomNote)-collections.Counter(magazine)
```

![img](https://uestc.feishu.cn/space/api/box/stream/download/asynccode/?code=M2M5NjVmYzk2NTQ5OTgwY2JmMDQ2N2E1ZjExNmU3OWRfMjBTSUlhOUpTUFFyQmJhdG12VmZPVXdkdHMxcThiOU9fVG9rZW46Ym94Y242U0ZKanJmNnJpYU50aVlEQWd0WG9jXzE2NTY0ODY2MTE6MTY1NjQ5MDIxMV9WNA)



#### [468. 验证IP地址](https://leetcode.cn/problems/validate-ip-address/)：字符串模拟











#### 495.提莫攻击：简单的模拟

#### 506.相对名次：pair 哈希 python写法？

```C%2B%2B
// 易懂的版本
class Solution {
public:
    vector<string> findRelativeRanks(vector<int>& nums) {
        vector<int> org = nums;
        sort(nums.rbegin(), nums.rend());
        unordered_map<int, string> order;
        for (int i = 0; i < nums.size(); i++) {
            if (i >= 3) order[nums[i]] = to_string(i+1);
            if (i == 0) order[nums[i]] = "Gold Medal";
            if (i == 1) order[nums[i]] = "Silver Medal";
            if (i == 2) order[nums[i]] = "Bronze Medal";
        }

        vector<string> res(nums.size());
        for (int i = 0; i < res.size(); i++) {
            res[i] = order[org[i]];
        }

        return res;
    }
};
// 官方题解
class Solution {
public:
    vector<string> findRelativeRanks(vector<int>& score) {
        int n = score.size();
        string str_ans[3] = {"Gold Medal", "Silver Medal", "Bronze Medal"};
        vector<pair<int, int>> mypair;

        //存入哈希表(这里vector)
        for (int i = 0; i < n; ++i) {
            mypair.emplace_back(make_pair(-score[i], i));
            // emplace_back会在插入数据后直接构造数据。相比push,emplace底层实现更简洁，效率高，当然可以push_back()
        }
        sort(mypair.begin(), mypair.end());
        
        //输出结果
        vector<string> ans(n);
        for (int i = 0; i < n; ++i) {
            if (i >= 3) {
                ans[mypair[i].second] = to_string(i + 1);
            } else {
                ans[mypair[i].second] = str_ans[i];
            }
        }
        return ans;

    }
};
// 自己写的
class Solution {
public:
    vector<string> findRelativeRanks(vector<int>& score) {
        int n = score.size();
        string str_ans[3] = {"Gold Medal", "Silver Medal", "Bronze Medal"};
        unordered_map<int, int> mypair;  //sorted分数->排名
        vector<int> sorted = score;
        sort(sorted.begin(), sorted.end());
        //存入哈希表
        for (int i = n-1; i >= 0; --i) {
            mypair.insert(pair(sorted[i], n-1-i));
        }       
        //输出结果
        vector<string> ans(n);
        for (int i = 0; i < n; ++i) {
            int rank = mypair[score[i]];
            ans[i] = rank < 3 ? str_ans[rank] : to_string(rank + 1);
        }
        return ans;
    }
};
class Solution:
    desc = ("Gold Medal", "Silver Medal", "Bronze Medal")

    def findRelativeRanks(self, score: List[int]) -> List[str]:
        ans = [""] * len(score)   #不能写成[]*len()
        arr = sorted(enumerate(score), key=lambda x: -x[1])
        for i, (idx, _) in enumerate(arr):
            ans[idx] = self.desc[i] if i < 3 else str(i + 1)
        return ans
```



#### [532. 数组中的 k-diff 数对](https://leetcode.cn/problems/k-diff-pairs-in-an-array/)：哈希+set

思路比较好想到：

**法1：哈希表 or set**

> unordered_set会比set快上不少！

```C%2B%2B
class Solution {
public:
    int findPairs(vector<int>& nums, int k) {
        unordered_set<int> ans;  // 记录较小的
        unordered_set<int> isHave;
        for (int n : nums) {
            if (isHave.count(n + k)) ans.insert(n);
            if (isHave.count(n - k)) ans.insert(n - k);
            isHave.insert(n);
        }
        return ans.size();
    }
};
```

**法2：排序后二分**

```C%2B%2B
class Solution {
public:
    int findPairs(vector<int>& nums, int k) {
        sort(nums.begin(), nums.end());
        int n = nums.size(), ans = 0;
        for (int i = 0; i < n - 1; i++) {
            if (i > 0 && nums[i] == nums[i - 1]) continue;
            int l = i + 1, r = n - 1;
            while (l <= r) {
                int mid = l + (r - l) / 2;
                if (nums[mid] == nums[i] + k) {
                    ans++;
                    break;
                }
                else if (nums[mid] > nums[i] + k) r = mid - 1;
                else l = mid + 1;
            }
        }
        return ans;
    }
};
```

**法3：双指针**

```C%2B%2B
class Solution {
public:
    int findPairs(vector<int>& nums, int k) {
        sort(nums.begin(), nums.end());
        int n = nums.size(), ans = 0;
        for (int i = 0; i < n; i++) {
            if (i > 0 && nums[i] == nums[i - 1]) continue;
            for (int j = i + 1; j < n; j++) {
                if (nums[j] == nums[i] + k) {
                    ans++;
                    break;
                }
            }
        }
        return ans;
    }
};
    
    换一种写法
    int findPairs(vector<int>& nums, int k) {
        sort(nums.begin(), nums.end());
        int size = nums.size(), ret = 0;
        int last = 1e7 + 1; //保存上一个数对中的x
        vector<int>::iterator it;
        for (int i = 0; i < size; i++) {
            if (nums[i] == last) continue; //如果x相同的话就跳过
            it = lower_bound(nums.begin() + i + 1, nums.end(), k + nums[i]);
            if (it != nums.end() && *it == (k + nums[i])) {
                ret++;
                last = nums[i];
            }
        }
        return ret;
    }
```



#### [535. TinyURL 的加密与解密](https://leetcode.cn/problems/encode-and-decode-tinyurl/)：伪加解密

> 直接用哈希表来存url就行

```C%2B%2B
class Solution {
private:
    unordered_map<int, string> umap;
    int id = 0;
    string tiny = "http://tinyurl.com/";
public:
    // Encodes a URL to a shortened URL.
    string encode(string longUrl) {
        umap[++id] = longUrl;
        return tiny + to_string(id);
    }

    // Decodes a shortened URL to its original URL.
    string decode(string shortUrl) {
        int p = shortUrl.rfind('/') + 1;
        int key = stoi(shortUrl.substr(p, int(shortUrl.size()) - p));
        return umap[key];
    }
};
```





#### [537. 复数乘法](https://leetcode-cn.com/problems/complex-number-multiplication/)：

![img](https://uestc.feishu.cn/space/api/box/stream/download/asynccode/?code=NTQ4NDAwY2Y2MjJjYmMwYjJiZWRmYWU0OGNhYWVhYTlfU2xDY2JPdG12Tk9EankwNVQwek1SZXFnVGl6aTVNU2xfVG9rZW46Ym94Y25TUjhkUUdVZFdqblhsaVRVb0p0N2plXzE2NTY0ODY2MTE6MTY1NjQ5MDIxMV9WNA)

```C%2B%2B
class Solution {
public:
    string complexNumberMultiply(string num1, string num2) {
        // num1 = a1+b1*i
        // num2 = a2+b2*i
        int a1 = stoi(num1.substr(0, num1.find("+")));
        int b1 = stoi(num1.substr(num1.find("+") + 1, num1.size()-1));
        int a2 = stoi(num2.substr(0, num2.find("+")));
        int b2 = stoi(num2.substr(num2.find("+") + 1, num2.size()-1));
        int a = a1*a2 - b1*b2, b = a1*b2 + a2*b1;
        return to_string(a) + "+" + to_string(b) + "i";
    }
};
```

**注意：**

- stoi函数将字符串转换为整数
- to_string函数将整数转换为字符串





#### [541. 反转字符串 II](https://leetcode-cn.com/problems/reverse-string-ii/)：注意两种语言的reverse函数

![img](https://uestc.feishu.cn/space/api/box/stream/download/asynccode/?code=NGM5ZmE0YjM2NmRlZmVjM2Q0MDUzY2Y2M2E5ZjU2YTVfZG02SmJ0dkZmWWdGMncyUWxWc2Rid3lwOGtqU1RRN1VfVG9rZW46Ym94Y25tNnpXZlphVm9oZldkd3M2QlJCYXJlXzE2NTY0ODY2MTE6MTY1NjQ5MDIxMV9WNA)

```C%2B%2B
class Solution {
public:
    string reverseStr(string s, int k) {
        int n = s.length();
        for(int i = 0; i < n; i += 2*k){
            // reverse(s[i], s[i+k]);❌
            reverse(s.begin() + i, s.begin() + min(i + k, n)); //官方题解
        }
        return s;
    }
};

/*
c.begin() 返回一个迭代器，它指向容器c的第一个元素
c.end() 返回一个迭代器，它指向容器c的最后一个元素的下一个位置
c.rbegin() 返回一个逆序迭代器，它指向容器c的最后一个元素
c.rend() 返回一个逆序迭代器，它指向容器c的第一个元素前面的位置
*/
class Solution:
    def reverseStr(self, s: str, k: int) -> str:
        t = list(s) #按照列表来操作了
        for i in range(0, len(t), 2 * k):
            # t[i: i + k] = list(reversed(t[i: i + k])) # python的逆序⭐
            t[i: i + k] = reversed(t[i: i + k])
            # print(t[i:i+k])
        return "".join(t)

# return t
# 输出 ["b","a","c","d","f","e","g"]
# 预期结果 "bacdfeg"
# 要将列表转换为字符串！
```



#### [522. 最长特殊序列 II](https://leetcode.cn/problems/longest-uncommon-subsequence-ii/)：遍历字符串来比较

> `strs[i].size()`不能直接当作int来使用？

```C%2B%2B
class Solution {
public:
    bool isSubseq(string a, string b) {  // a是否是b的子序列
        int i = 0, j = 0;
        while (i < a.size() && j < b.size()) {
            if (a[i] == b[j]) i++;
            j++;
        }
        return i == a.size();
    }
    int findLUSlength(vector<string>& strs) {
        int n = strs.size();
        int ans = -1;
        for (int i = 0; i < n; i++) {
            bool check = true;
            for (int j = 0; j < n; j++) {
                if (i != j && isSubseq(strs[i], strs[j])) {
                    check = false;
                    break;
                }
            }
            if (check) {
                ans = max(ans, (int)strs[i].size());
            }
        }
        return ans;
    }
};
```



#### [591. 标签验证器](https://leetcode-cn.com/problems/tag-validator/)：字符串模拟+栈？

> 困难题：

自己写的：但是有点问题。。

```C%2B%2B
class Solution {
public:
    bool isValid(string code) {
        int n = code.size();
        stack<string> s;
        int i = 0;
        while (i < n) {
            if (code[i] == '<') {
                // if (i == n - 1) return false;
                if (code[i + 1] == '/') {
                    int j = code.find('>', i);
                    if (j == string::npos) return false;
                    string tagName = code.substr(i + 2, j - (i + 2));
                    if (s.empty() || s.top() != tagName) return false;
                    s.pop();
                    i = j + 1;
                    // if (s.empty() && i != n) return false;  // ⭐
                }
                else if (code.substr(i + 1, 8) == "![CDATA[") {
                    int j = code.find("]]>", i);    // 从i之后再找
                    if (j == string::npos) return false;
                    i = j + 3;
                }
                else {
                    int j = code.find('>', i);
                    if (j == string::npos) return false;
                    string tagName = code.substr(i + 2, j - (i + 2));
                    if (tagName.size() < 1 || tagName.size() > 9) return false;
                    for (auto s : tagName) {
                        if (!isupper(s)) return false;
                    }
                    s.push(tagName);
                    i = j + 1;
                }
            }
            else {
                if (s.empty()) return false;
                i++;
            }
        }
        return s.empty();
    }
};
```

评论里面抄来一个：

```C%2B%2B
bool isValid(string code)
{
    int idx = 0;
    stack<string> tagname;
    while (idx < code.size())
    {
        if (code[idx] == '<')
        {
            idx++;                //跳过<
            if (code[idx] == '/') //结束符
            {
                int start = ++idx; //跳过/
                while (idx < code.size() && code[idx] != '>')
                    idx++;
                if (tagname.empty() || idx == code.size() || code.substr(start, idx - start) != tagname.top()) //没有匹配的开始符或没有>返回false
                    return false;
                tagname.pop();
                idx++; //跳过>
            }
            else if (code[idx] != '!') //开始符
            {
                int start = idx;
                while (idx < code.size() && code[idx] != '>')
                {
                    if (!isupper(code[idx])) //不是大写返回false
                        return false;
                    idx++;
                }
                int len = idx - start;
                if ((start > 1 && tagname.empty()) || idx == code.size() || len > 9 || len == 0) //长度大于9或等于0或没有结束符或当前标签不是第一个且不在任何标签范围内返回false
                    return false;
                tagname.push(code.substr(start, len));
                idx++; //跳过>
            }
            else // cdata
            {
                idx++; //跳过！
                if (tagname.empty() || code.substr(idx, 7) != "[CDATA[")
                    return false;
                idx += 7; //位于[后面一个字符
                while (idx < code.size())
                {
                    if (code.substr(idx, 3) == "]]>")
                        break;
                    idx++;
                }
                if (idx == code.size())
                    return false;
                idx += 3; //跳]]>
            }
        }
        else
        {
            if (tagname.empty()) //当前文字不在标签范围内
                return false;
            idx++;
        }
    }
    return tagname.empty(); //有无未闭合标签
}
```



#### [699. 掉落的方块](https://leetcode.cn/problems/falling-squares/)：暴力求解俄罗斯方块

> 思路是怎么想到的？

> 一个格子落到其他格子上面以后，后来的格子就只能继续向上堆。所以我们可以把已经落稳了的格子，变成长方形，且把与其有交集格子中重叠的部分覆盖了：如图

> ![img](https://uestc.feishu.cn/space/api/box/stream/download/asynccode/?code=OTVlMDAzOWM1MGIzYjE1MGYyMTFjODI4OWJiODU4MGJfUnp5dkhJNk1DQWFTY01RWDN3MWRvZFB6SnBkM093QzJfVG9rZW46Ym94Y25hZ1lkUXFuc20zQjN6S21xd01wTHdnXzE2NTY0ODY2MTE6MTY1NjQ5MDIxMV9WNA)

```C%2B%2B
class Solution {
public:
    struct Margin {
        int left;
        int right;
        int height;
        Margin(int l, int r, int h): left(l), right(r), height(h) {}
    };
    vector<int> fallingSquares(vector<vector<int>>& pos) {
        int n = pos.size();
        int maxHeight = 0;
        vector<Margin> margs;
        vector<int> ans;

        for (int i = 0; i < n; i++) {  // 遍历每个正方形
            int l = pos[i][0], h = pos[i][1], r = l + h;
            int curMaxh = 0;
            for (Margin m : margs) {
                if (m.left >= r || m.right <= l) continue;  // 正好错开
                curMaxh = max(curMaxh, m.height);  // 需要垒，那就求出当前最高
            }
            int curHeight = curMaxh + h;
            margs.push_back(Margin(l, r, curHeight));  // 存的是矩形投影区域
            maxHeight = max(maxHeight, curHeight);
            ans.push_back(maxHeight);
        }
        return ans;
    }
};
```

**注意定义一个struct后怎么初始化之类的！！**



#### [748. 最短补全词](https://leetcode-cn.com/problems/shortest-completing-word/)：if not counter()相减

```C%2B%2B
class Solution {
public:
    // 官方题解
    string shortestCompletingWord(string licensePlate, vector<string> &words) {
        array<int, 26> cnt{};
        for (char ch : licensePlate) {
            if (isalpha(ch)) {
                ++cnt[tolower(ch) - 'a'];
            }
        }
        int idx = -1;
        for (int i = 0; i < words.size(); ++i) {
            array<int, 26> word_cnt{};
            for (char ch : words[i])
                ++word_cnt[ch - 'a'];

            bool isComplete = true;
            for (int j = 0; j < 26; ++j) {
                if (word_cnt[j] < cnt[j]) {
                    isComplete = false;
                    break;
                }
            }
            if (isComplete && (idx ==-1 || words[i].size() < words[idx].size()))
            // 注意这里idx的判断和size判断的顺序不能写反！！⭐
                idx = i;
        }
        return words[idx];
    }
};
class Solution:
    # python官方解答极度简洁
    def shortestCompletingWord(self, licensePlate: str, words: List[str]) -> str:
        cnt = Counter(ch.lower() for ch in licensePlate if ch.isalpha())
        return min((word for word in words if not cnt-Counter(word)),key=len)
```



#### [794. 有效的井字游戏](https://leetcode-cn.com/problems/valid-tic-tac-toe-state/)：井字模拟

```C%2B%2B
class Solution {
public:
    bool validTicTacToe(vector<string>& board) {
        int numX = 0, numO = 0;
        for(auto row : board){
            for(auto i : row){
                if(i == 'X') numX++;
                if(i == 'O') numO++;
            }
        }

        if(numX != numO && numX != numO + 1) return false;
        if(checkWin(board, 'X') && numX != numO + 1) return false;
        if(checkWin(board, 'O') && numX != numO) return false;
        else
            return true;
    }

    bool checkWin(vector<string>& board, char p) {
        for(int i = 0; i < 3; ++i){
            if(board[i][0] == p && board[i][1] == p && board[i][2] == p)
                return true;
            if(board[0][i] == p && board[1][i] == p && board[2][i] == p)
                return true;
        }
        if(board[0][0] == p && board[1][1] == p && board[2][2] == p)
            return true;
        if(board[0][2] == p && board[1][1] == p && board[2][0] == p)
            return true;
        else
            return false;
    }
};
```



#### [812. 最大三角形面积](https://leetcode.cn/problems/largest-triangle-area/)：用坐标求三角形面积

**法1：海伦公式**

![img](https://uestc.feishu.cn/space/api/box/stream/download/asynccode/?code=NzJiZTIwYTllMzZmYWU5MzM3Y2M2NThkZmEyYmQwYzBfZHZvSDZMVkZtcDRFSDBBdld2dkl0YmNqaDJyWHBBeGZfVG9rZW46Ym94Y25adktHd2lXUGM1SHFJaUdoN29PT2tmXzE2NTY0ODY2MTE6MTY1NjQ5MDIxMV9WNA)

```C%2B%2B
class Solution {
public:
    double getLen(vector<int>& a, vector<int>& b) {
        return sqrt(pow(a[0] - b[0], 2) + pow(a[1] - b[1], 2));
    }
    double getArea(double a, double b, double c) {
        double p = (a + b + c) / 2;
        return sqrt(p * (p - a) * (p - b) * (p - c));
    }
    double largestTriangleArea(vector<vector<int>>& points) {
        double ans = 0.0;
        for (auto &A : points) {
            for (auto &B : points) {
                for (auto &C : points) {
                    double a = getLen(B, C), b = getLen(A, C), c = getLen(A, B); 
                    ans = max(ans, getArea(a, b, c));
                }
            }
        }
        return ans;
    }
};
```

**法2：向量叉乘**

![img](https://uestc.feishu.cn/space/api/box/stream/download/asynccode/?code=OTViNTVjYTBiYTEyNTNjZTZlY2Y4ZmQ5ZTZjNzgxNjJfTkw0dmFLZWl2bVgyZkdaYno5Zmg1dkRUUmdCNGp4UE5fVG9rZW46Ym94Y25uQlM0ejNLYVhSNEZwOTJreWFBZU10XzE2NTY0ODY2MTE6MTY1NjQ5MDIxMV9WNA)

**法3：S=1/2 \* a \* b \* sinC**





#### [846. 一手顺子](https://leetcode-cn.com/problems/hand-of-straights/)：优先队列(堆)+哈希

注意取牌，检查能否组成顺子时的思路⭐

```C%2B%2B
class Solution {
public:
    bool isNStraightHand(vector<int>& hand, int groupSize) {
        unordered_map<int, int> cnt;  // 某数值和数量的对应关系
        priority_queue<int, vector<int>, greater<int>> q;  // 升序队列
        for (auto c: hand) {  // 存进去
            cnt[c]++;
            q.push(c);
        }

        while(!q.empty()) {
            int c = q.top();
            q.pop();
            // 牌已经被取出
            // 我们只需要每次从堆中取出一张牌
            // 检查相邻的groupsize张是否存在，如果存在就将对应该数值的计数器减1即可
            if (cnt[c] != 0) {
                for (int x = 0; x < groupSize; x++) {  // 检查能否顺子
                    if (cnt[c+x] == 0) return false;
                    cnt[c+x]--;  // 计数器减1，等价于取出牌
                }
            }
        }
        return true;
    }
};
```



#### [868. 二进制间距](https://leetcode-cn.com/problems/binary-gap/)：直接遍历，简单模拟

![img](https://uestc.feishu.cn/space/api/box/stream/download/asynccode/?code=NDY0MGVhZmIwNmU1MjQ3ZjhjMTEwYzBhNDZiMjczNmNfOUxRMkk1bjhGeHA3NEVXWVdIOUQzbTlqZUFnQU9yRGtfVG9rZW46Ym94Y25DVWl1S3ZuZmpaczZ1Yll2a09FVU9jXzE2NTY0ODY2MTE6MTY1NjQ5MDIxMV9WNA)

```C%2B%2B
class Solution {
public:
    // 直接遍历：遍历n的二进制中的每一位i，同时记录上一位1的位置j
    int binaryGap(int n) {
        int ans = 0;
        for (int i = 31, j = -1; i >= 0; i--) {
            if (((n >> i) & 1) == 1) {
                if (j != -1) ans = max(ans, j - i);
                j = i;
            }
        }
        return ans;
    }
};
#include <cmath>    // 如果加上一个没有太大必要的操作
int binaryGap(int n) {
    ...
    for (int i = (int)(log(n) / log(2)), j = -1; i >= 0; i--) {...}
}
```



#### [883. 三维形体投影面积](https://leetcode-cn.com/problems/projection-area-of-3d-shapes/)：投影

![img](https://uestc.feishu.cn/space/api/box/stream/download/asynccode/?code=MmFmZWQ0MDUwZjM1MmYyYzc4ZjYyOTA5NDBjODkyYTlfcmNYSklGOXdYN3Y4aWtRcWx1MnpuU0JmZklsYVpMSDZfVG9rZW46Ym94Y25YcnNyNDBCc3NDT1E1V3ZJdnh6Q0hnXzE2NTY0ODY2MTE6MTY1NjQ5MDIxMV9WNA)

> 输入的是某坐标的v值，直接遍历输入的列表即可；

> 侥幸地，因为行列数量一样可以这么操作。。。

使用三个变量分别统计三视图的阴影面积：

- ans1：统计俯视图的面积，共有n∗n 个位置需要被统计，当任意格子g[i][j]>0，面积+1；
- ans2：统计左视图的面积，共有n行需要被统计，每一行对 ans2 的贡献为该行的最大高度；
- ans3：统计主视图的面积，共有n列需要被统计，每一列对 ans3 的贡献为该列的最大高度。

```C%2B%2B
class Solution {
public:
    int projectionArea(vector<vector<int>>& grid) {
        int s1 = 0, s2 = 0, s3 = 0;
        int n = grid.size();
        for (int i = 0; i < n; ++i) {
            int a = 0, b = 0;
            for (int j = 0; j < n; ++j) {
                if (grid[i][j] > 0) s1++;
                a = max(a, grid[i][j]);
                b = max(b, grid[j][i]);
            }
            s2 += a;
            s3 += b;
        }
        return s1 + s2 + s3;
    }
};
```



#### [890. 查找和替换模式](https://leetcode.cn/problems/find-and-replace-pattern/)：映射

> 根据题意，我们需要构造从字母到字母的双射，

```C%2B%2B
class Solution {
public:
    bool isMatch(string word, string pattern) {
        unordered_map<int, int> map;
        int m = word.size();
        for (int i = 0; i < m; i++) {
            if (map.find(word[i] - 'a') == map.end()) {
                map[word[i] - 'a'] = pattern[i] - 'a';
            }
            else {
                if (map[word[i] - 'a'] != pattern[i] - 'a')
                    return false;
            }
        }
        return true;
    }
    vector<string> findAndReplacePattern(vector<string>& words, string pattern) {
        vector<string> res;
        for (auto word : words) {
            if (isMatch(word, pattern) && isMatch(pattern, word))
                res.push_back(word);
        }
        return res;
    }
};
```



#### [905. 按奇偶排序数组](https://leetcode-cn.com/problems/sort-array-by-parity/)：

```C%2B%2B
class Solution {
public:
    // 遍历一趟，双指针
    vector<int> sortArrayByParity(vector<int>& nums) {
        int n = nums.size();
        for (int i = 0, j = n - 1; i < j; ++i) {
            if (nums[i] % 2 == 1) {
                int t = nums[i];
                nums[i--] = nums[j];
                nums[j--] = t;
            }
        }
        return nums;
    }
};
```



#### [929. 独特的电子邮件地址](https://leetcode.cn/problems/unique-email-addresses/)：字符串模拟

```C%2B%2B
class Solution {
public:
    int numUniqueEmails(vector<string>& emails) {
        set<string> getMail;
        for (auto e : emails) {
            string mail;
            int n = e.size(), i = 0;
            bool flag = false;
            while (i < n) {
                if (e[i] == '@') break;  // @之后直接substr
                if (e[i] == '.' && ++i > 0) continue;
                if (e[i] == '+') flag = true;
                if (!flag) mail += e[i];
                i++;
            }
            // mail.append(e.substr(i));
            getMail.insert(mail + e.substr(i));
        }
        return getMail.size();
    }
};
```





#### [944. 删列造序](https://leetcode.cn/problems/delete-columns-to-make-sorted/)：直接按列遍历

```C%2B%2B
class Solution {
public:
    int minDeletionSize(vector<string>& strs) {
        int m = strs.size(), n = strs[0].size();  // m行n列
        int ans = 0;
        for (int j = 0; j < n; j++) {
            for (int i = 0; i < m - 1; i++) {
                if (strs[i][j] > strs[i + 1][j]) {
                    ans++;
                    break;
                }
            }
        }
        return ans;
    }
};
```



#### [953. 验证外星语词典](https://leetcode.cn/problems/verifying-an-alien-dictionary/)：

> 题意很是有问题！！不多纠结了

> 根据字典序，逐位进行比较？都不是：相当于查字典？

```C%2B%2B
class Solution {
public:
    bool isAlienSorted(vector<string>& words, string order) {
        unordered_map<char, int> mp;  // 直接上哈希表
        int n = words.size();
        for (int i = 0; i < 26; i++) {
            mp[order[i]] = i;
        }
        for (int i = 0; i < n - 1; i++) {
            string w0 = words[i], w1 = words[i + 1];
            int l0 = w0.size(), l1 = w1.size();
            bool flag = false;
            for (int j = 0; j < l0 && j < l1; j++) {
                if (mp[w0[j]] < mp[w1[j]]) {
                    flag = true;
                    break;
                }
                else if (mp[w0[j]] > mp[w1[j]])
                    return false;
            }
            if (flag == false && l0 > l1) return false;
        }
        return true;
    }
};
```

补充一种写法：自定义排序。。。

```C%2B%2B
class Solution {
public:
    unordered_map<char, int> ord;
    int check(string a, string b) {
        int m = a.size(), n = b.size();
        int i = 0, j = 0;
        while (i < m && j < n) {
            if (a[i] != b[j]) return ord[a[i]] - ord[b[j]];
            i++, j++;
        }
        if (i < m) return 1;
        if (j < n) return -1;
        return 0;
    }
    bool isAlienSorted(vector<string>& words, string order) {
        int n = words.size();
        for (int i = 0; i < 26; i++) {
            ord[order[i]] = i;
        }
        for (int i = 0; i < n - 1; i++) {
            if (check(words[i], words[i + 1]) > 0) return false;
        }
        return true;
    }
};
```



#### [961. 在长度 2N 的数组中找出重复 N 次的元素](https://leetcode.cn/problems/n-repeated-element-in-size-2n-array/)

> 似乎过分简单了：2n = (n + 1) + (n - 1)

- > 不重复的那个一定是只出现了一次！

```C%2B%2B
int repeatedNTimes(vector<int>& nums) {
    int cnt[10001] = {0};  //数据范围<=10^4
    for (int n : nums) {
        if (++cnt[n] > 1) return n;
    }
    return -1;
}
```



#### [997. 找到小镇的法官](https://leetcode-cn.com/problems/find-the-town-judge/)：入度出度

python的解法看起来更方便

```Python
class Solution:
    def findJudge(self, n: int, trust: List[List[int]]) -> int:
        inDg = Counter(y for _,y in trust)
        outDg = Counter(x for x,_ in trust)
        for i in range(1, n + 1):
            if inDg[i] == n - 1 and outDg[i] == 0:
                return i
        return -1
```



#### [1051. 高度检查器](https://leetcode.cn/problems/height-checker/)：简单排序模拟



#### [1078. Bigram 分词](https://leetcode-cn.com/problems/occurrences-after-bigram/)：自己写一个C++分词吧

如果用C++实现本题，问题在于如何将text分词成为一个动态数组words？

```C%2B%2B
class Solution {
public:
    // 可惜C++没有分割字符串的方法？
    vector<string> findOcurrences(string text, string first, string second) {
        vector<string> words;
        int start = 0;
        int len = text.size();
        for(int i = 0; i < len; ++i) {
            if(text[i] == ' ') {
                words.push_back(text.substr(start, i - start));
                start = i + 1;
            }
        }
        words.push_back(text.substr(start, len - start));

        vector<string> ans;
        int n = words.size();
        for (int i = 2; i < n; i++) {
            if (words[i - 2] == first && words[i - 1] == second)
                ans.push_back(words[i]);
        }
        return ans;
    }
};
```

python解法注意**enumerate**的用法

```Python
class Solution:
    def findOcurrences(self, text: str, first: str, second: str) -> List[str]:
        ans = []
        words = text.split(" ")
        for i,_ in enumerate(words):
            if i < len(words)-2 and words[i] == first and words[i+1] == second:
                ans.append(words[i+2])
        return ans

# class Solution:
#     def findOcurrences(self, text: str, first: str, second: str) -> List[str]:
#         words = text.split()
#         return [words[i] for i in range(2, len(words)) if words[i - 2] == first and words[i - 1] == second]
```

![img](https://uestc.feishu.cn/space/api/box/stream/download/asynccode/?code=YmQ0NGIwNWYxMGUxYmFlODI5YzU5OGEzMDFmZjNkNmFfdTRRbGJMVFpjdjY3MXBFdUJmY092T3A3dVg4UWhjY1dfVG9rZW46Ym94Y25aWmdncXpPNTRZTHhkbFQ2Z2tHa21jXzE2NTY0ODY2MTE6MTY1NjQ5MDIxMV9WNA)



#### [1154. 一年中的第几天](https://leetcode-cn.com/problems/day-of-the-year/)：4年一闰，百年不闰

```C%2B%2B
class Solution {
public:
    int dayOfYear(string date) {
        int days[12] = {31,28,31,30,31,30,31,31,30,31,30,31};       
        string yy = date.substr(0, 4);
        string mm = date.substr(5, 2);
        string dd = date.substr(8, 2);
        int y = stoi(yy), m = stoi(mm), d = stoi(dd);
        int ans = 0;
        if (((y%4==0)&&(y%100!=0))||(y%400==0)) days[1]++;
        for (int i = 0; i < m - 1; i++) ans += days[i];
        ans += d;
        return ans;
    }
};
class Solution:
    def dayOfYear(self, date: str) -> int:
        year, month, day = [int(_) for _ in date.split("-")]
        amount = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]
        if year % 400 == 0 or (year % 4 == 0 and year % 100 != 0):
            amount[1] += 1
        ans = sum(amount[:month - 1])
        return ans + day
```



#### [1108. IP 地址无效化](https://leetcode.cn/problems/defanging-an-ip-address/)：字符串模拟

> 字符串添加字符！

```C%2B%2B
class Solution {
public:
    string defangIPaddr(string address) {
        string ans;
        for (auto a : address) {
            if (a == '.') ans.append("[.]");
            else ans.push_back(a);
        }
        return ans;
    }
};
```



#### [1189. “气球” 的最大数量](https://leetcode-cn.com/problems/maximum-number-of-balloons/)：统计词频计数

![img](https://uestc.feishu.cn/space/api/box/stream/download/asynccode/?code=MmZlNzhmNzFmNDUzOGMyNTZlNzdlZDM0NDFhZTJiNGJfbWZxYU1pVTRKREZIdEp0ZHg2a2l0aVdJNGFxY3BOeGRfVG9rZW46Ym94Y256YXRrMEVnZ1pnb2ZlWVZ0bjEyVEJiXzE2NTY0ODY2MTE6MTY1NjQ5MDIxMV9WNA)

```C%2B%2B
class Solution {
public:
    // 就是统计词频，balloon: a:1, b:1, l:2, n:1, o:2
    int maxNumberOfBalloons(string text) {
        int cnt[5] = {0};
        for (auto c : text) {
            if (c == 'b') cnt[0]++;
            else if (c == 'a') cnt[1]++;
            else if (c == 'l') cnt[2]++;
            else if (c == 'o') cnt[3]++;
            else if (c == 'n') cnt[4]++;
        }
        cnt[2] /= 2, cnt[3] /= 2;
        int ans = cnt[0];
        for (int i = 0; i < 5; i++)
            ans = min(ans, cnt[i]);
        return ans;
    }
};
class Solution:
    def maxNumberOfBalloons(self, text: str) -> int:
        cnt = Counter(ch for ch in text if ch in "balon")
        cnt['l'] //= 2
        cnt['o'] //= 2
        return min(cnt.values()) if len(cnt) == 5 else 0
```





#### [1342. 将数字变成 0 的操作次数](https://leetcode-cn.com/problems/number-of-steps-to-reduce-a-number-to-zero/)：简单数学计算，是奇是偶

```Dart
class Solution {
public:
    int numberOfSteps(int num) {
        int ans = 0;
        while(num != 0) {
            num = num % 2 == 0 ? num / 2 : num - 1;
            ans++;
        }
        return ans;
    }
};
```



#### [1380. 矩阵中的幸运数](https://leetcode-cn.com/problems/lucky-numbers-in-a-matrix/)：联想到807.城市天际线

![img](https://uestc.feishu.cn/space/api/box/stream/download/asynccode/?code=NWQwMjZlNjY2ZTA2ZmE2ZTBjMzlkYWFmMWI4OGNiN2ZfUWdnM05CcUxjOVRqc1R3RjBxUnNXU1dVZ0lUdmtFQnBfVG9rZW46Ym94Y25yVEZUS3VIOFRJT3l1eGxXNVZCRFJnXzE2NTY0ODY2MTE6MTY1NjQ5MDIxMV9WNA)

**注意C++和Python中无穷大、无穷小的写法**

```C%2B%2B
class Solution {
public:
    vector<int> luckyNumbers (vector<vector<int>>& matrix) {
        int m = matrix.size(), n = matrix[0].size();  // m行n列
        vector<int> rowMin(m, INT_MAX);
        vector<int> colMax(n, INT_MIN);
        for (int i = 0; i < m; ++i) {
            for (int j = 0; j < n; ++j) {
                rowMin[i] = min(rowMin[i], matrix[i][j]);
                colMax[j] = max(colMax[j], matrix[i][j]);
            }
        }
        vector<int> ans;
        for (int i = 0; i < m; ++i) {
            for (int j = 0; j < n; ++j) {
                if (matrix[i][j] == rowMin[i] && matrix[i][j] == colMax[j])
                    ans.push_back(matrix[i][j]);
            }
        }
        return ans;
    }
};
class Solution:
    def luckyNumbers (self, matrix: List[List[int]]) -> List[int]:
        m, n = len(matrix), len(matrix[0])
        rowMin = [float('inf') for _ in range(m)]
        colMax = [float('-inf') for _ in range(n)]
        for i in range(m):
            for j in range(n):
                rowMin[i] = min(rowMin[i], matrix[i][j])
                colMax[j] = max(colMax[j], matrix[i][j])
        ans = []
        for i in range(m):
            for j in range(n):
                if matrix[i][j] == rowMin[i] and matrix[i][j] == colMax[j]:
                    ans.append(matrix[i][j])
        return ans
```





#### 1436.旅行终点站：哈希表，for(auto i : v)

```C%2B%2B
// 官方题解，建议看原题记录
class Solution {
public:
    string destCity(vector<vector<string>>& paths) {
        unordered_set<string> citiesA;
        for (auto &path : paths) { //for (auto path : paths)看起来也行
            citiesA.insert(path[0]);
        }
        for (auto &path : paths) {
            if (!citiesA.count(path[1])) {
                return path[1];
            }
        }
        return "";
    }
};
class Solution {
public:
    string destCity(vector<vector<string>>& paths) {
        unordered_map<string, int> out; //out 记录出度
        for (auto &p : paths) {
            out[p[0]]++; //out[p[1]]不变，见演草本的例子
        }
        // for (auto [a,b] : out) 这是错误的
        for (auto p : paths) {
            if (out[p[1]] == 0) {
                // return out[a];❌
                return p[1]; //注意，是把对应的城市名返回，类型string
            }
        }
        return "";
    }
};
```



#### 1480.一维数组的动态和：动规 普普通通

#### [1576. 替换所有的问号](https://leetcode-cn.com/problems/replace-all-s-to-avoid-consecutive-repeating-characters/)：字符的替换 简单题

![img](https://uestc.feishu.cn/space/api/box/stream/download/asynccode/?code=N2FlMGRlZDhjYzY2ZmE3MDg0ZGQ2MWEwOTM3YTczZWJfSE5ObzZ4b2JoOHhrcEtPejhwcFNnVjJCWFFVRGJFSWhfVG9rZW46Ym94Y25qTVZOQWJOWEZwVVFtWG5GRlhyNnZlXzE2NTY0ODY2MTE6MTY1NjQ5MDIxMV9WNA)

```Python
class Solution:
    def modifyString(self, s: str) -> str:
        ls = list(s)
        n = len(s)
        for i in range(n):
            if ls[i] == '?':
                for p in "abc":
                    if (i >= 1 and ls[i-1] == p) or (i < n-1 and ls[i+1] == p):
                        continue
                    ls[i] = p
                    break
        return "".join(ls)
```

#### [1614. 括号的最大嵌套深度](https://leetcode-cn.com/problems/maximum-nesting-depth-of-the-parentheses/)：简单地‘(’累加计数

```C%2B%2B
class Solution {
public:
    int maxDepth(string s) {
        int n = s.size();
        int ans = 0;
        for(int i = 0, cnt = 0; i < n; ++i){
            if(s[i] == '(') cnt++;
            else if(s[i] == ')') cnt--;
            ans = max(ans, cnt);
        }
    return ans;
    }
};
```



#### [1629. 按键持续时间最长的键](https://leetcode-cn.com/problems/slowest-key/)：一次遍历找最大

注意直接比较字节序

```C%2B%2B
class Solution {
public:
    // 只看每次的最长持续时间
    char slowestKey(vector<int>& releaseTimes, string keysPressed) {
        int n = releaseTimes.size();
        int p = 0, max = releaseTimes[0];
        for(int i = 1; i < n; i++){
            int cur = releaseTimes[i] - releaseTimes[i-1];
            if(cur > max){
                p = i;
                max = cur;
            }
            else if(cur == max && keysPressed[i] > keysPressed[p]){
                p = i;
            }
        }
        return keysPressed[p];
    }
};
```



#### [1706. 球会落何处](https://leetcode-cn.com/problems/where-will-the-ball-fall/)：

![img](https://uestc.feishu.cn/space/api/box/stream/download/asynccode/?code=ODJiYjQyMmZjNmQ0NjI2MDcyMzEwNzAxMWQyY2MzOWVfRGhrTFF5YnVOSW5lU2RGV3NkY2l0NVJDSU5jeTdpMmJfVG9rZW46Ym94Y25tUmUzWGpsMlhMNnVYMkxwbW5WTGloXzE2NTY0ODY2MTE6MTY1NjQ5MDIxMV9WNA)

**写法1：**进行一个动态规划

![img](https://uestc.feishu.cn/space/api/box/stream/download/asynccode/?code=YTc5MTVlZDU1MzgyNzFlY2Y1NTY3ZTE1ZjcxMTFiMDZfVmtaalc4OU1pRHJGUmVpSkpEcTNYSmVzRVcyNkJaWWJfVG9rZW46Ym94Y25RUVJIMjU2RHlxdXdvOURUa0JlM0VlXzE2NTY0ODY2MTE6MTY1NjQ5MDIxMV9WNA)

```Python
class Solution:
    def findBall(self, grid: List[List[int]]) -> List[int]:
        m, n = len(grid), len(grid[0])  # m行n列
        dp = {i : i for i in range(n)}
        for i in range(m):  # 遍历每一行
            for j in list(dp.keys()):  # 看每一列的值
                if grid[i][dp[j]] == 1:
                    if dp[j] == n-1 or grid[i][dp[j]+1] == -1: dp.pop(j)
                    else: dp[j] += 1
                elif grid[i][dp[j]] == -1:
                    if dp[j] == 0 or grid[i][dp[j]-1] == 1: dp.pop(j)
                    else: dp[j] -= 1
        return [dp[_] if _ in dp else -1 for _ in range(n)]
```

注意：这样写会越界！！

![img](https://uestc.feishu.cn/space/api/box/stream/download/asynccode/?code=MTAzZjA3ZjNlOGI2NjM5YjFkMTY2ZWJkMWRjYWM0ZGVfdHRENWZ6RHdFZ1BObGphd2gwUHcwaGh2NFVocjlaNlNfVG9rZW46Ym94Y25uUmpRVVFtRE1Kb1I5QWR6QmluTE5nXzE2NTY0ODY2MTE6MTY1NjQ5MDIxMV9WNA)

**写法2：**比上面哪个更容易看懂，像是人能写出来的东西

【三叶】の题解思路：

![img](https://uestc.feishu.cn/space/api/box/stream/download/asynccode/?code=MmEyYzcxMjE2N2NkMjU3Yzc3Zjc2NGExZjE0NzljZTdfQkU0QWthazVhdjAzSWFFS1Zzd28zcGEzdE5jVURNVVhfVG9rZW46Ym94Y253b3BRd2Jvb24xTW9hQTdNOHJGaExHXzE2NTY0ODY2MTE6MTY1NjQ5MDIxMV9WNA)

```C%2B%2B
class Solution {
public:
    int m, n;
    vector<vector<int>> g;
    vector<int> findBall(vector<vector<int>>& grid) {
        g = grid;
        m = g.size(), n = g[0].size();
        vector<int> ans(n);
        for (int i = 0; i < n; ++i) {
            ans[i] = getVal(i);
        }
        return ans;
    }
    int getVal(int x) {
        int r = 0, c = x;
        while (r < m) {
            int ne = c + g[r][c];
            if (ne < 0 || ne >= n) return -1;
            if (g[r][c] != g[r][ne]) return -1;
            r++;
            c = ne;
        }
        return c;
    }
};
```

最容易理解的一个写法：

```C%2B%2B
class Solution {
public:
    vector<int> findBall(vector<vector<int>>& grid) {
        int m = grid.size(), n = grid[0].size(); 
        vector<int> ans(n);  // 当前求在第几列（-1为卡住）
        for (int j = 0; j < n; j++) ans[j] = j; 

        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                if (ans[j] == -1) continue;
                int col = ans[j]; 
                if (grid[i][col] == 1)
                    ans[j] = (col + 1 >= n || grid[i][col+1] == -1) ? -1 : col + 1; 
                else if (grid[i][col] == -1)
                    ans[j] = (col - 1 < 0 || grid[i][col-1] == 1) ? -1 : col - 1; 
            }
        }

        return ans; 
    }
};
```



#### [1725. 可以形成最大正方形的矩形数目](https://leetcode-cn.com/problems/number-of-rectangles-that-can-form-the-largest-square/)：简单求最值

> 数组内求min，然后再求max

![img](https://uestc.feishu.cn/space/api/box/stream/download/asynccode/?code=OGRhZmJhOWZiMWJkOWM0MDUxMDAzZTY2YzFlMmE4YzBfSGF1c0FqclU0TVNwNE5yeUp2Q25EdWVXbm9LMVRXSDFfVG9rZW46Ym94Y253dXhzbjJoSFM2TDdsNHRmc0lCV1VlXzE2NTY0ODY2MTE6MTY1NjQ5MDIxMV9WNA)

**一种简单的写法：**

```C%2B%2B
class Solution {
public:
    int countGoodRectangles(vector<vector<int>>& rectangles) {
        int ans = 0, maxLen = 0;
        int n = rectangles.size();
        for(int i = 0; i < n; ++i){
            int cur = min(rectangles[i][0], rectangles[i][1]);
            if(cur == maxLen)
                ans++;
            else if(cur > maxLen){
                maxLen = cur;  // 找的是最大正方形
                ans = 1;
            }
        }
        return ans;
    }
};
```

**还有一种简便的C++写法：**

```C%2B%2B
class Solution {
public:
    int countGoodRectangles(vector<vector<int>>& rectangles) {
        int ans = 0, maxLen = 0;
        for(auto &rec : rectangles){
            int cur = min(rec[0], rec[1]);
            if(cur == maxLen)
                ans++;
            else if(cur > maxLen){
                maxLen = cur;  // 找的是最大正方形
                ans = 1;
            }
        }
        return ans;
    }
};
# python基础写法
class Solution:
    def countGoodRectangles(self, rectangles: List[List[int]]) -> int:
        ans, maxLen = 0, 0
        for a, b in rectangles:
            cur = min(a, b)
            if cur == maxLen:
                ans += 1
            elif cur > maxLen:
                maxLen = cur
                ans = 1
        return ans
        
# python的简练写法⭐
class Solution:
    def countGoodRectangles(self, rectangles: List[List[int]]) -> int:
        return cur.count(m) if (cur := [min(rec) for rec in rectangles]) and (m := max(cur)) else 0
```



#### [1763. 最长的美好子字符串](https://leetcode-cn.com/problems/longest-nice-substring/)：朴素地枚举

![img](https://uestc.feishu.cn/space/api/box/stream/download/asynccode/?code=MzllNjJiYjRlMThhMDY4N2M1NDU2ODE4NzRiZDU1YWJfODJkdW5xQnNKdTdIdzluQUlIVFpPMlFObUMzUW1IVzNfVG9rZW46Ym94Y25GMWtQeFBRblVJWGRsVmQxSTMzV3ZiXzE2NTY0ODY2MTE6MTY1NjQ5MDIxMV9WNA)

**法1：分治思想**

将原问题拆解成子问题：**如果某个字符，在当前字符串中没有它对应的大写或小写字符，它必不能构成答案中的一部分，答案只能在它左边或在它右边**。

我们返回该点左边或右边更长的答案即为答案。

如果不存在这样的字符，说明原字符串本身就是美好字符串

```Python
class Solution:
    # 分治思想⭐
    def longestNiceSubstring(self, s: str) -> str:
        if len(s) < 2:
            return ""
        for i, ch in enumerate(s):
            if ch.upper() not in s or ch.lower() not in s:
                return max(self.longestNiceSubstring(s[:i]), self.longestNiceSubstring(s[i+1:]), key = len)
        return s
```



**法2：枚举？**

![img](https://uestc.feishu.cn/space/api/box/stream/download/asynccode/?code=YjMyMGQ4Zjg5MjBkZWRmYTliNmY4ZmFlZWY4YWM2NjVfYjRaMlJvdmkyRTM1dmFzMXdmWDFLWERXZVk4RE9zTjdfVG9rZW46Ym94Y25PR2thdTN0SmJqRjRxenpHOEtTMk9kXzE2NTY0ODY2MTE6MTY1NjQ5MDIxMV9WNA)







#### [1816. 截断句子](https://leetcode-cn.com/problems/truncate-sentence/)：简单的切片 substr()



#### [1823. 找出游戏的获胜者](https://leetcode-cn.com/problems/find-the-winner-of-the-circular-game/)：约瑟夫环

**方法一：直接模拟**

- > 利用数据范围1 <= k <= n <= 500，我们可以直接根据规则进行模拟。

- > 创建一个标记数组 vis，若有 vis[idx] = true 则代表点编号为 idx 已被淘汰，每次我们都从当前位置 cur 开始，找到第 k 个尚未淘汰的点（vis[idx] = false），并将其进行标记（vis[idx] = true），共有 n - 1 个点需要被淘汰。

- > 一些细节，为了方便取模，我们调整点编号从 11 开始，在返回答案时再重新调整为从 11 开始。

```C%2B%2B
class Solution {
public:
    int findTheWinner(int n, int k) {
        vector<bool> vis(n, false);
        int cnt = 0, cur = 0;
        while (cnt < n - 1) {
            for (int i = 0; i < k - 1; ++i) {
                cur++;
                while (vis[cur % n]) cur++;
            }
            vis[cur % n] = true;
            cnt++;
            cur++;
            while (vis[cur % n]) cur++;
        }
        return (cur % n) + 1;
    }
};
```

**方法二：递归⭐**

![img](https://uestc.feishu.cn/space/api/box/stream/download/asynccode/?code=Y2ZhZmJlYmIxODNhZmRjOTcwYTBkNzc2YWY2NTY3NmZfUE40d1lmV21NMnpWZEJKM2t1SGtHaFNiNWZtRUdJSGRfVG9rZW46Ym94Y25RUU80Z3dzdUxEckc2clhHclJ1MjhkXzE2NTY0ODY2MTE6MTY1NjQ5MDIxMV9WNA)

```C%2B%2B
    int findTheWinner(int n, int k) {
        if (n <= 1)
            return n;
        int ans = (findTheWinner(n - 1, k) + k) % n;
        return ans == 0 ? n : ans;
    }
```

**方法三：约瑟夫环的数学推导**

[【负雪明烛】你能找到的最详细约瑟夫环数学推导！ - 找出游戏的获胜者 - 力扣（LeetCode） (leetcode-cn.com)](https://leetcode-cn.com/problems/find-the-winner-of-the-circular-game/solution/by-fuxuemingzhu-laof/)

```Java
    int findTheWinner(int n, int k) {
        int pos = 0;
        for (int i = 2; i < n + 1; ++i) {
            pos = (pos + k) % i;
        }
        return pos + 1;
```



#### [2000. 反转单词前缀](https://leetcode-cn.com/problems/reverse-prefix-of-word/)：find函数使用方法⭐+python简洁的反转方法

> 题意：指定字符寻找下标进行翻转

find函数找；reverse函数翻转？😅

```C%2B%2B
class Solution {
public:
    string reversePrefix(string word, char ch) {
        int idx = word.find(ch);
        if(idx != string::npos){
            reverse(word.begin(), word.begin() + idx + 1);
        }
        return word;
    }
};
class Solution:
    def reversePrefix(self, word: str, ch: str) -> str:
        idx = word.find(ch)
        return word if idx == -1 else word[:idx+1][::-1] + word[idx+1:]

# 解法2
class Solution:
    def reversePrefix(self, word: str, ch: str) -> str:
        return word if (idx:=word.find(ch)) == -1 else word[:idx+1][::-1] + word[idx+1:]
```



> **双指针进行翻转？：**先从前往后遍历，找到第一个ch的下标idx（初始值-1），然后对[0,idx] 应用**双指针**进行翻转（若没有ch字符，则idx = -1，则[0,idx] 为不合法区间，翻转过程被跳过）。

```C%2B%2B
class Solution {
public:
    string reversePrefix(string word, char ch) {
        int n = word.size(), idx = -1;
        for(int i = 0; i < n && idx == -1; ++i){
            if(word[i] == ch)
                idx = i;
        }
        // 用双指针进行翻转
        int l = 0, r = idx;
        while(l < r){
            char ch = word[l];
            word[l++] = word[r];
            word[r--] = ch;
        }
        return word;
    }
};
```



#### [2016. 增量元素之间的最大差值](https://leetcode-cn.com/problems/maximum-difference-between-increasing-elements/)

![img](https://uestc.feishu.cn/space/api/box/stream/download/asynccode/?code=OWI0Yjg5OTBmYzExMTE2YjQ4MDU3NmQzY2EzMWE0N2FfbXZ2Q0FIVmNqeW94THJsSG9QTEZ0ZEZXdzNab2RpM09fVG9rZW46Ym94Y252MXUySlFwbFBMejJxemM2a0NJM1JmXzE2NTY0ODY2MTE6MTY1NjQ5MDIxMV9WNA)

```C%2B%2B
class Solution {
public:
    int maximumDifference(vector<int>& nums) {
        int n = nums.size(), ans = -1;
        int premin = nums[0];  // nums前面的最小值
        for (int i = 0; i < n; ++i) {
            if (nums[i] > premin) ans = max(ans, nums[i] - premin);
            else premin = min(premin, nums[i]);
        }
        return ans;
    }
};
```





#### [面试题 01.05. 一次编辑](https://leetcode.cn/problems/one-away-lcci/)：双指针模拟，比较字符串

> 为了比较字符串，是否通过一次编辑就能实现

![img](https://uestc.feishu.cn/space/api/box/stream/download/asynccode/?code=ZTViY2QzODkxNTJkMzYwYzFjNTRlNDZiY2M1YjczODFfMXNDS2xsZzg2WnFvcDhSOHRCaFhuQ21EelU2UTEyUldfVG9rZW46Ym94Y24yc0E5bEZYSWVxZ2d1SHBVZHN6OGJkXzE2NTY0ODY2MTE6MTY1NjQ5MDIxMV9WNA)

**法1：一次性遍历，分类讨论**

```C%2B%2B
#include <cmath>
class Solution {
public:
    bool oneEditAway(string first, string second) {
        int m = first.size(), n = second.size();
        if (m < n) return oneEditAway(second, first);
        if (m == n) {  // 执行一次替换
            for (int i = 0, dif = 0; i < m; i++) {
                if (first[i] != second[i]) dif++;
                if (dif > 1) return false;
            }
            return true;
        }
        if (m - n == 1) {  // 执行一次删除
            for (int i = 0, dif = 0; i < m; i++) {
                if (first[i + dif] != second[i]) {  // dif相当于偏移量
                    dif++;
                    i--;  // 以second为基准，再比较一次第i位
                }
                if (dif > 1) return false;
            }
            return true;
        }
        return false;
    }
};
```

**法2：双指针**

```TypeScript
class Solution {
public:
    bool oneEditAway(string first, string second) {
        int m = first.size(), n = second.size();
        if (m < n) return oneEditAway(second, first);
        if (m - n > 1) return false;
        int i = 0, j = 0, dif = 0;
        while (i < m && j < n && dif <= 1) {
            if (first[i] == second[j]) {
                i++, j++;
            }
            else {
                if (m == n) {
                    i++, j++, dif++;  // 说明是一次替换
                }
                else {
                    i++, dif++;  // 说明是一次删除
                }
            }
        }
        return dif <= 1 ? true : false;
    }
};
```



#### [面试题 17.11. 单词距离](https://leetcode.cn/problems/find-closest-lcci/)

```C%2B%2B
class Solution {
public:
    int findClosest(vector<string>& words, string word1, string word2) {
        int n = words.size();
        int p1 = -1, p2 = -1, ans = n;
        for (int i = 0; i < n; i++) {
            if (words[i] == word1) p1 = i;
            if (words[i] == word2) p2 = i;
            if (p1 != -1 && p2 != -1) ans = min(ans, abs(p1 - p2));
        }
        return ans;
    }
};
```









# 数据结构

## (1)栈

无法复制加载中的内容

#### 20.有效括号：C++函数用法，python栈+哈希表

```C%2B%2B
class Solution {
public:
    bool isValid(string s) {
        int n = s.size();
        if (n % 2 == 1)
            return false;

        unordered_map<char, char> pairs = {
            {')', '('},
            {']', '['},
            {'}', '{'}
        };
        stack<char> stk;
        for (char ch: s) {
            if (pairs.count(ch)) { //下标为ch的地方有数据，这里是根据右括号查左？
                if (stk.empty() || stk.top() != pairs[ch])
                    return false;
                stk.pop();
            }
            else
                stk.push(ch);
        }
        return stk.empty();
    }
};
//想必：if (pairs.count(ch)) 是看当前ch是右括号不是？若是则进入if
//count(ch)是查找 key的存在
//pairs[ch]是 key->value查询
class Solution:
    def isValid(self, s: str) -> bool:
        # python用列表来实现栈就可以了！方便
        if len(s)%2 == 1:
            return False
        pairs = {
            ")": "(",
            "]": "[",
            "}": "{",
        } #字典：作为哈希表
        stack = list()
        for ch in s:
            if ch in pairs:
                if not stack or stack[-1]!=pairs[ch]: # stack[-1]倒序第1个，即栈顶
                    return False
                stack.pop()
            else:
                stack.append(ch)
        
        return not stack
```

#### [32. 最长有效括号](https://leetcode-cn.com/problems/longest-valid-parentheses/)：不要想简单了 思路 边界

![img](https://uestc.feishu.cn/space/api/box/stream/download/asynccode/?code=YmFmZmE1ZmU0ZDU1ZmE4NTRjMWQyMmRmMzA5ZDE3OGZfU3dJQXhHNjBnRkJ6WlBvY2RIc1J1REFBY29yR2FsdFFfVG9rZW46Ym94Y25KR1owdkszRTgzSmRzcDNOcmVaMWdnXzE2NTY0ODY2MTE6MTY1NjQ5MDIxMV9WNA)

用栈实现的思路是：

![img](https://uestc.feishu.cn/space/api/box/stream/download/asynccode/?code=NWJiNTdlNDhiMGI5NDg3ZDhlOTVkN2QxMjZkZDUyYjZfZWk0UEk1bnM5V2ZsclRvd1dlQ0ZIT1NYcXBtY0taV0xfVG9rZW46Ym94Y25kYk92RTRrZmw2QXJBdE1teXpFQ0VoXzE2NTY0ODY2MTE6MTY1NjQ5MDIxMV9WNA)

```C%2B%2B
class Solution {
public:
    int longestValidParentheses(string s) {
        int ans = 0;
        stack<int> stk;  // 栈中存放的是未匹配的括号的下标
        // 栈底元素为当前“最后一个没有被匹配的右括号的下标”
        stk.push(-1);
        for (int i = 0; i < s.length(); i++) {
            if (s[i] == '(') {
                stk.push(i);
            } else {  // 是')'则把左括号下标出栈
                stk.pop();
                // 这时，看栈中还有没有等待匹配的左括号
                if (stk.empty()) { // 如果没有左括号了，说明当前右括号是没有被匹配的
                    stk.push(i);  //把当前这个未匹配的右括号下标放入，作为新的起点！
                } else { //如果还有左括号等待匹配
                    ans = max(ans, i - stk.top());
                }
                // stk.pop();
            }
        }
        return ans;
    }
};
```

**需要记录：最近的最长括号开始位置！！**

![img](https://uestc.feishu.cn/space/api/box/stream/download/asynccode/?code=OGZhYWVkMzI0Y2NlYWQwY2QxNzk0ODc4ZDI1MTNhOGRfdFB5S3NBY3dHeFZvYWhKbnNydWtFdGhqZ2pkajByTDBfVG9rZW46Ym94Y25jQlRvWHVST1dOMmhycVVSekFYS1hiXzE2NTY0ODY2MTE6MTY1NjQ5MDIxMV9WNA)



#### 155.最小栈

```Python
class MinStack:

    def __init__(self):
        self.stack = []
        self.min_stack = [math.inf]

    def push(self, val: int) -> None:
        self.stack.append(val)
        # self.min_stack.append(min(val, min_stack[-1])) 有个错误！忘记写self了！！
        self.min_stack.append(min(val, self.min_stack[-1]))

    def pop(self) -> None:
        self.stack.pop()
        self.min_stack.pop()

    def top(self) -> int:
        return self.stack[-1]

    def getMin(self) -> int:
        return self.min_stack[-1]

# Your MinStack object will be instantiated and called as such:
# obj = MinStack()
# obj.push(val)
# obj.pop()
# param_3 = obj.top()
# param_4 = obj.getMin()
```

#### [232. 用栈实现队列](https://leetcode-cn.com/problems/implement-queue-using-stacks/)：双栈



#### [1047. 删除字符串中相邻重复项](https://leetcode-cn.com/problems/remove-all-adjacent-duplicates-in-string/)：string类似vector的用法 明明用栈就很好

![img](https://uestc.feishu.cn/space/api/box/stream/download/asynccode/?code=Mzk4OWQ5MmEwMjNiYTFhMTY2YTkxNzA0MTFhMTFkMWJfQXBiOTJ4UDVGOWRZcG00RmtsdUl6WGhod0FlNFo4N0RfVG9rZW46Ym94Y25QaHpRbTBJc3FtSmI3SkM1dFRJUGJkXzE2NTY0ODY2MTE6MTY1NjQ5MDIxMV9WNA)

官方直接使用字符串的操作：显然用栈比较好，这里**把string当栈用**

```C%2B%2B
class Solution {
public:
    string removeDuplicates(string s) {
        string stk;
        for (char ch : s) {
            if (!stk.empty() && stk.back() == ch) {
                stk.pop_back();
            } else {
                stk.push_back(ch);
            }
        }
        return stk;
    }
};
```

![img](https://uestc.feishu.cn/space/api/box/stream/download/asynccode/?code=OGFhYWExYWY5Y2IwODc2YTk3ZDg0MTZiMDYyNDFjZWNfamNtQ3lmSkU3b20yWUlhS2c2ekZGQW41cTZ1V1VOVk5fVG9rZW46Ym94Y25YOUJJWnkwZHJ5TFo2MnJsY29LSFBIXzE2NTY0ODY2MTE6MTY1NjQ5MDIxMV9WNA)







## (2)单调栈



## (3)队列

无法复制加载中的内容



#### [933. 最近的请求次数](https://leetcode-cn.com/problems/number-of-recent-calls/)：

> 关键在于看懂题意：每次t入队；取在队中的介于[t-3000, t]的元素个数

```C%2B%2B
class RecentCounter {
public:
    queue<int> q;

    RecentCounter() {}
    
    int ping(int t) {
        q.push(t);
        while (q.front() < t - 3000) q.pop();
        return q.size();
    }
};
```

无非就是练习了一下队列的使用



#### 





## (4)单调队列





## (5)二叉树

无法复制加载中的内容



#### [449. 序列化和反序列化二叉搜索树](https://leetcode.cn/problems/serialize-and-deserialize-bst/)：⭐

![img](https://uestc.feishu.cn/space/api/box/stream/download/asynccode/?code=OWQyZDk4MjU3ZjhkNWJhZDI3YzQ2OTM5ZTgxMzlhOTJfY1RrM0ljZHIzMzVCUGNzcmVkeWYwMkNlYWtJTk5wdzFfVG9rZW46Ym94Y25jcUNxWDgzcWhsWFRKNDJidjY3VVdiXzE2NTY0ODY2MTE6MTY1NjQ5MDIxMV9WNA)

- > 根--左--右

- > 转成字符转后，再转回来，**思考：两位数的情况，要特殊处理⭐**

```C%2B%2B
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Codec {
public:
    void seHandler(vector<int>& list, TreeNode* root) {
        if (root == NULL) return;
        list.push_back(root->val);
        seHandler(list, root->left);
        seHandler(list, root->right);
    }
    // Encodes a tree to a single string.
    string serialize(TreeNode* root) {
        vector<int> list;
        string se;
        seHandler(list, root);
        for (auto n : list) se += to_string(n) + ',';
        return se;
    }

    TreeNode* deHandler(vector<int>& list, int lb, int rb) {
        if (lb > rb) return NULL;
        TreeNode* root = new TreeNode(list[lb]);  //先是根
        int border = rb + 1;
        for (int i = lb + 1; i <= rb; i++) {
            if (list[i] < list[lb]) {
                continue;  // 比根小，是左子树
            }
            else {
                border = i;
                break;
            }
        }
        root->left = deHandler(list, lb + 1, border - 1);
        root->right = deHandler(list, border, rb);

        return root;
    }
    // Decodes your encoded data to tree.
    TreeNode* deserialize(string data) {
        if (data == "") return NULL;
        vector<int> list;
        string curNum = "";
        for (auto s : data) {
            if (s == ',') {
                list.push_back(stoi(curNum));
                curNum = "";
            }
            else curNum += s;
        }
        return deHandler(list, 0, list.size() - 1);  // 要规定好list的左右边界
    }
};

// Your Codec object will be instantiated and called as such:
// Codec* ser = new Codec();
// Codec* deser = new Codec();
// string tree = ser->serialize(root);
// TreeNode* ans = deser->deserialize(tree);
// return ans;
```

升级写法：

```C%2B%2B
class Codec {
public:
    int idx = 0;
    int n;
    // Encodes a tree to a single string.
    string serialize(TreeNode* root) {
        if(root == NULL) return "";
        string ans = "";
        ans += to_string(root->val) + ",";
        ans += serialize(root->left) + ",";
        ans += serialize(root->right);
        return ans;
    }
    // Decodes your encoded data to tree.
    TreeNode* deserialize(string& data) { // 此处引用传递，避免值拷贝，提高效率
        n = data.size();
        if(idx >= n) return NULL;
        string num = "";
        while(idx < n && data[idx] != ',') {
            num += data[idx];
            ++idx;
        }
        ++idx;    // 跳过逗号
        if(num == "") return NULL;
        TreeNode* root = new TreeNode(stoi(num));
        root->left = deserialize(data);
        root->right = deserialize(data);
        return root;
    }
};
```



#### [450. 删除二叉搜索树中的节点](https://leetcode.cn/problems/delete-node-in-a-bst/)：删除二叉树的节点

> 直接调用了`delete`函数，不如华为oj规范

```PHP
/* Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    TreeNode* deleteNode(TreeNode* root, int key) {
        //第一种情况，不存在被删除节点
        if (root == NULL) return root;
        if (root->val == key) {
            //第二种情况，删除节点左右孩子都为空
            if (root->left == NULL && root->right == NULL) {
                delete root;
                return NULL;
            }
            //第三种情况，左孩子不为空，右孩子为空
            if (root->left != NULL && root->right == NULL) {
                TreeNode* node = root->left;
                delete root;
                return node;
            }
            //第四种情况，左孩子为空，右孩子不为空
            if (root->left == NULL && root->right != NULL) {
                TreeNode* node = root->right;
                delete root;
                return node;
            }
            //第五种情况，都不为空，将左子树放到右子树的最左侧
            if (root->left != NULL && root->right != NULL) {
                TreeNode* node = root->right;
                while (node->left != NULL) {
                    node = node->left;
                }
                node->left = root->left;
                TreeNode* tmp = root->right;
                delete root;
                return tmp;
            }
        }
        if (root->val > key) root->left = deleteNode(root->left, key);
        if (root->val < key) root->right = deleteNode(root->right, key);
        return root;
    }
};
```



#### [513. 找树左下角的值](https://leetcode.cn/problems/find-bottom-left-tree-value/)：dfs+bfs模板 

法1：dfs，用全局变量记录结果！

```C%2B%2B
class Solution {
public:
    int maxDep, ans = 0;
    int findBottomLeftValue(TreeNode* root) {
        dfs(root, 1);
        return ans;
    }
    void dfs(TreeNode* root, int depth) {
        if (root == NULL) return;
        if (depth > maxDep) {
            maxDep = depth;
            ans = root->val;
        }
        dfs(root->left, depth + 1);
        dfs(root->right, depth + 1);
    }
};
```

法2：bfs

需要先把它的非空右子节点放入队列，然后再把它的非空左子节点放入队列，这样才能保证从右到左遍历每一层的节点

```C%2B%2B
class Solution {
public:
    int findBottomLeftValue(TreeNode* root) {
        int ans = 0;
        queue<TreeNode *> q;
        q.push(root);
        while (!q.empty()) {
            TreeNode* p = q.front();
            q.pop();
            if (p->right) q.push(p->right);
            if (p->left) q.push(p->left);  // 找出左下角，因此要区分顺序，先右再左
            ans = p->val;
        }
        return ans;
    }
};
```



#### [515. 在每个树行中找最大值](https://leetcode.cn/problems/find-largest-value-in-each-tree-row/)

bfs

```C%2B%2B
class Solution {
public:
    vector<int> largestValues(TreeNode* root) {
        if (root == NULL) return {};
        vector<int> res;
        queue<TreeNode*> q;
        q.push(root);
        while (!q.empty()) {
            int len = q.size();
            int maxVal = INT_MIN;
            while (len > 0) {
                len--;
                TreeNode* p = q.front();
                q.pop();
                maxVal = max(maxVal, p->val);
                if (p->left) q.push(p->left);
                if (p->right) q.push(p->right);
            }
            res.push_back(maxVal);
        }
        return res;
    }
};
```



#### [563. 二叉树的坡度](https://leetcode-cn.com/problems/binary-tree-tilt/)：递归地进行dfs

> 向上记录每一层的坡度

![img](https://uestc.feishu.cn/space/api/box/stream/download/asynccode/?code=MTM1MWE3YTAzODM5NzRmYjNiYTQzNThjMmZmMGE3NGFfNXBNV3Bucmd3VUFvYlFLMGhIVkxtMTRaMkdTbE1jTGJfVG9rZW46Ym94Y25vMVlqaUZaTFNmZDZlMmQ4alVVQmJoXzE2NTY0ODY2MTE6MTY1NjQ5MDIxMV9WNA)

```C%2B%2B
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    int ans = 0; //记录每次搜索中，暂时用到的返回结果
    int findTilt(TreeNode* root) {
        dfs(root);
        return ans;
    }

    int dfs(TreeNode* node){
        if(node == NULL)
            return 0;
        int sumLeft = dfs(node->left); //左边的和，所以dfs()的返回值也应...⭐
        int sumRight = dfs(node->right);
        ans += abs(sumLeft - sumRight);
        return sumLeft + sumRight + node->val;
    }
};
```



#### [863. 二叉树中所有距离为 K 的结点](https://leetcode-cn.com/problems/all-nodes-distance-k-in-binary-tree/)：



#### [938. 二叉搜索树的范围和](https://leetcode-cn.com/problems/range-sum-of-bst/)：同上bfs中



#### [965. 单值二叉树](https://leetcode.cn/problems/univalued-binary-tree/)：**模板题** dfs / bfs

**法1：dfs**

```C%2B%2B
class Solution {
public:
    bool dfs(int val, TreeNode* root) {
        if (root == NULL) return true;
        if (root->val != val) return false;
        return dfs(root->val, root->left) && dfs(root->val, root->right);
    }
    bool isUnivalTree(TreeNode* root) {
        return dfs(root->val, root);
    }
};
```

或者升级版：

```C%2B%2B
class Solution {
public:
    int val = -1;
    bool isUnivalTree(TreeNode* root) {
        if (val == -1) val = root->val;
        if (root == NULL) return true;
        if (root->val != val) return false;
        return isUnivalTree(root->left) && isUnivalTree(root->right);
    }
};
```

**法2：bfs**

```C%2B%2B
class Solution {
public:
    bool isUnivalTree(TreeNode* root) {
        queue<TreeNode*> q;
        q.push(root);
        int val = root->val;
        while (!q.empty()) {
            TreeNode* node = q.front();
            q.pop();
            if (node == NULL) continue;
            if (node->val != val) return false;
            q.push(node->left);
            q.push(node->right);
        }
        return true;
    }
};
```



#### [1022. 从根到叶的二进制数之和](https://leetcode.cn/problems/sum-of-root-to-leaf-binary-numbers/)：两种dfs写法

> 递归有使用**「函数返回值」**和**「全局变量」**两种实现方式。

法1：使用函数返回值

```PHP
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    int dfs(TreeNode* root, int cur) {
        int ans = 0;
        cur = cur * 2 + root->val;  // (cur << 1) + root.val
        if (root->left != NULL) ans += dfs(root->left, cur);
        if (root->right != NULL) ans += dfs(root->right, cur);
        return (root->left == NULL && root->right == NULL) ? cur : ans;
    }
    int sumRootToLeaf(TreeNode* root) {
        return dfs(root, 0);
    }
};
```

法2：全局变量

```PHP
class Solution {
public:
    int ans = 0;
    void dfs(TreeNode* root, int cur) {
        cur = cur * 2 + root->val;  // (cur << 1) + root.val
        if (root->left != NULL) dfs(root->left, cur);
        if (root->right != NULL) dfs(root->right, cur);
        if (root->left == NULL && root->right == NULL) ans += cur;
        return;
    }
    int sumRootToLeaf(TreeNode* root) {
        dfs(root, 0);
        return ans;
    }
};
```





#### [1305. 两棵二叉搜索树中的所有元素](https://leetcode-cn.com/problems/all-elements-in-two-binary-search-trees/)：注意vector作为形参

![img](https://uestc.feishu.cn/space/api/box/stream/download/asynccode/?code=MDc0ZWU5NmM5ZmFkMzc5NmUxYzkxOTQ3ZTI3NDIxOWJfdUpWZHQ2VE5SQTlsOEhlTkZwTTlOS0ZyekJvQjh1MWhfVG9rZW46Ym94Y25pZDI4ZWhRbzd6R2RoeTk0a1JsN3NiXzE2NTY0ODY2MTE6MTY1NjQ5MDIxMV9WNA)

- > **中序遍历的有序性；**

- > **将两个有序序列合并成一个有序序列则是利用了经典的「归并排序」**

```C%2B%2B
// 中序遍历后，合并（归并排序）
class Solution {
public:
    void dfs(TreeNode* curNode, vector<int> &list)
    {
        if (curNode == NULL) return;
        dfs(curNode->left, list);
        list.push_back(curNode->val);
        dfs(curNode->right, list);
    }
    vector<int> getAllElements(TreeNode* root1, TreeNode* root2) {
        vector<int> ans;
        vector<int> list1, list2;
        dfs(root1, list1);
        dfs(root2, list2);
        int m = list1.size(), n = list2.size();
        int i = 0, j = 0;
        while(i < m || j < n) {
            int a = i < m ? list1[i] : INT_MAX;
            int b = j < n ? list2[j] : INT_MAX;
            if (a <= b) {
                ans.push_back(a);
                i++;
            }
            else {
                ans.push_back(b);
                j++;
            }
        }
        return ans;
    }
};
```



#### [面试题 04.06. 后继者](https://leetcode.cn/problems/successor-lcci/)：二叉搜索树的性质⭐

![img](https://uestc.feishu.cn/space/api/box/stream/download/asynccode/?code=NDBlYTVkNWNhODAwM2JkN2Q4MjZiMjBkMTEzZTJmMWRfUG11eTExa3NNSFhhZFZTbzd1cm1iYWdDTEg5TlRUaU5fVG9rZW46Ym94Y25HV01vWEpRYnhMczVRQkFjbzJxNEtlXzE2NTY0ODY2MTE6MTY1NjQ5MDIxMV9WNA)![img](https://uestc.feishu.cn/space/api/box/stream/download/asynccode/?code=MmRjYjkxZDY4MWU2MzU1MzczNzI2ZWI5YmVjOTIwMTJfbHBvMXBPTU1hNXlHbFgxaEd3WGNrZXEyYjNUWUN3MDBfVG9rZW46Ym94Y25seDR6WWtQVlU3VUtndEtybVpDQzRmXzE2NTY0ODY2MTE6MTY1NjQ5MDIxMV9WNA)

- > 当`root.val<=p.val`时，去root右子树上找p，返回结果一定在`root.right`上；所以递归到右子树，无右子树则返回NULL

- > 当`root.val>p.val`时，去root左子树上找p，p一定在`root.left`上；如果p有右子树，返回递归到右子树，无右子树则返回root

- > 再者：如果p是左子树上的，返回p的`root`；如果p是右子树上的，返回`p.right`（看p相对于上一个是左是右）

- > 特殊一点的：p=4需要返回5

```C%2B%2B
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    TreeNode* inorderSuccessor(TreeNode* root, TreeNode* p) {
        if (root == NULL) return NULL;
        if (p->val >= root->val)
            return inorderSuccessor(root->right, p);
        TreeNode* ans = inorderSuccessor(root->left, p);  // 默认往左走
        return ans == NULL ? root : ans;
    }
};
```

**法2：中序遍历⭐**

BST的性质，中序遍历的方式似乎好理解一些：思路是，**深度优先**，用中序遍历恢复出递增的序列

```C%2B%2B
class Solution {
public:
    bool isFind = false;
    TreeNode* ans;
    void dfs(TreeNode* curRoot, TreeNode* p) {
        if (curRoot == NULL) return;    // 先判空
        dfs(curRoot->left, p);          // 左子树
        if (isFind) {                   // 是否已经找到p，若已找到，当前就是要返回的
            if (ans == NULL) ans = curRoot;
            return;
        }
        if (curRoot->val == p->val) isFind = true;
        dfs(curRoot->right, p);        // 右子树
    }
    TreeNode* inorderSuccessor(TreeNode* root, TreeNode* p) {
        dfs(root, p);
        return ans;
    }
};
```





## (6)链表

#### [剑指 Offer II 029. 排序的循环链表](https://leetcode.cn/problems/4ueAj6/)：链表作循环队列

```PHP
/*
class Node {
public:
    int val;
    Node* next;
    Node() {}
    Node(int _val) {
        val = _val;
        next = NULL;
    }
    Node(int _val, Node* _next) {
        val = _val;
        next = _next;
    }
};
*/

class Solution {
public:
    Node* insert(Node* head, int insertVal) {
        if (head == NULL) {
            Node* ans = new Node(insertVal);
            ans->next = ans;
            return ans;
        }
        Node* p = head;
        while (!(p->val <= insertVal && insertVal <= p->next->val)) {
            p = p->next;
            if (p == head || (p->val > p->next->val && (insertVal >= p->val || insertVal <= p->next->val))) break;
        }
        p->next = new Node(insertVal, p->next);
        return head;
    }
};
```



## (7)哈希表

无法复制加载中的内容



#### [398. 随机数索引](https://leetcode-cn.com/problems/random-pick-index/)：双解，哈希or蓄水池抽样

> 题目并没有很看懂

**法1：哈希表**

```C%2B%2B
class Solution {
public:
    unordered_map<int, vector<int>> position;  // 用哈希表记录相同元素下标位置⭐
    Solution(vector<int>& nums) {
        for (int i = 0; i < nums.size(); ++i) {
            position[nums[i]].push_back(i);
        }
    }
    
    int pick(int target) {
        auto idx = position[target];  // 取target下标构成列表
        return idx[rand() % idx.size()];
    }
};
```



#### [442. 数组中重复的数据](https://leetcode-cn.com/problems/find-all-duplicates-in-an-array/)：原地哈希

自己的解法可能会浪费空间，

```C%2B%2B
vector<int> findDuplicates(vector<int>& nums) {
    int n = nums.size();
    vector<bool> isExist(n, false);
    vector<int> ans;
    for (int i = 0; i < n; ++i) {
        if (!isExist[nums[i] - 1])
            isExist[nums[i] - 1] = true;
        else ans.push_back(nums[i]);
    }
    return ans;
}
```

- > 直接使用哈希表，把次数为2的数字输出：不满足复杂度要求；

- > **原地哈希：**`**h(value) = value - 1**`

> 题目说：nums 的所有整数都在范围 [1, n] 内，那可能不难想到要使用**原地哈希**的方法，简单来说，就是将题目给的数组当成一个哈希表

> 为什么要构建这样的一个哈希函数呢？首先，我们的数组下标是[0, n - 1]的，而数据范围是 [1, n]，如果数据范围内的数字每个都出现一次，那么很容易就能找到nums[val - 1] = val的哈希函数使得每个数值不重不漏的映射到唯一的数组下标，并填满整个数组。

> 若有整数出现不止一次，那么必定某些数值缺少，而缺失数值的位置被重复的数值占据了，我们只需调整数组满足上述的哈希映射，即可很容易找到重复的数据。

![img](https://uestc.feishu.cn/space/api/box/stream/download/asynccode/?code=ZmQ0NzYwM2VkZGI4YWFhZGMzOWIxMjU2YmVhODBjMDJfUWhYWXVEQzBQdzZCUHNnb1JLWGRjbWYxakJocDM5dkFfVG9rZW46Ym94Y25CVXRndVFzU0Jlak1TaHlGRGRIWDlHXzE2NTY0ODY2MTE6MTY1NjQ5MDIxMV9WNA)

原地哈希的实现是交换元素位置：**每一次交换操作会使得至少一个元素被交换到对应的正确位置**

1. 一个不太好的写法：

```C%2B%2B
    vector<int> findDuplicates(vector<int>& nums) {
        vector<int> ans;
        int n = nums.size();
        for (int i = 0; i < n; i++) {
            if (nums[i] < 0 || nums[i] - 1 == i) continue;
            if (nums[nums[i] - 1] == nums[i]) {
                ans.push_back(nums[i]);
                nums[i] *= -1;
            }
            else {
                int c = nums[nums[i] - 1];
                nums[nums[i] - 1] = nums[i];
                nums[i--] = c;
            }
        }
        return ans;
    }
```

1. 第二种写法⭐：

```C%2B%2B
vector<int> findDuplicates(vector<int>& nums) {
    int n = nums.size();
    for (int i = 0; i < n; ++i) {                 // 遍历nums上的每一位
        while (nums[i] != nums[nums[i] - 1]) {    // 保证每一次i位上都有正确的数
            swap(nums[i], nums[nums[i] - 1]);
        }
    }
    vector<int> ans;
    for (int i = 0; i < n; ++i) {
        if (nums[i] - 1 != i) {
            ans.push_back(nums[i]);
        }
    }
    return ans;
}
```

1. 直接**用正负号做标记**，进一步简化⭐：负数说明已经至少出现过一次

![img](https://uestc.feishu.cn/space/api/box/stream/download/asynccode/?code=MjljMDJlZGI1N2E0YTllMWVhMzg5MWI2NzAxMDA1Mjhfa1FKaUhkQ3c5WTRuOTdxeFdFSlJjaDRpbEx6TlZMeGFfVG9rZW46Ym94Y25oSzJDRHJHc29QMFdvTTRCSDRsWm9lXzE2NTY0ODY2MTE6MTY1NjQ5MDIxMV9WNA)

```C%2B%2B
vector<int> findDuplicates(vector<int>& nums) {
    int n = nums.size();
    vector<int> ans;
    for (int i = 0; i < n; ++i) {
        int x = abs(nums[i]);
        if (nums[x - 1] > 0) {
            nums[x - 1] = -nums[x - 1];
        }
        else {
            ans.push_back(x);
        }
    }
    return ans;
}
```



#### [1001. 网格照明](https://leetcode-cn.com/problems/grid-illumination/)：哈希表+set，线性映射模拟❗

![img](https://uestc.feishu.cn/space/api/box/stream/download/asynccode/?code=ZjcwZjVjZDdjYWIzOGIwMzk3ZjVlODczZDMwY2ZjYTRfSVc0ZkFuakVMM0FFbTdURzd5bWJBdEowZmJjR2ZlWHJfVG9rZW46Ym94Y25nREs5d09URlM5M3ZTNWdRaFhqblpiXzE2NTY0ODY2MTE6MTY1NjQ5MDIxMV9WNA)

> 再看看原题！



#### [2006. 差的绝对值为 K 的数对数目](https://leetcode-cn.com/problems/count-number-of-pairs-with-absolute-difference-k/)：要想到用map（哈希表）

**法1：直接朴素地进行简单模拟**

```C%2B%2B
class Solution {
public:
    int countKDifference(vector<int>& nums, int k) {
        int n = nums.size(), ans = 0;
        for (int i = 0; i < n; i++){
            for (int j = i + 1; j < n; j++){
                if (abs(nums[i] - nums[j]) == k)
                    ans++;
            }
        }
        return ans;
    }
};
class Solution:
    def countKDifference(self, nums: List[int], k: int) -> int:
        n, m = 0, len(nums)
        for i in range(m-1):
            for j in range(i, m):
                if abs(nums[i] - nums[j]) == k:
                    n += 1
        return n
```

**法2：哈希表**

**再来说得深入一点：【三叶】の题解**

![img](https://uestc.feishu.cn/space/api/box/stream/download/asynccode/?code=OWMxNjU3NTQzMTM2ZjA4YjAyMjgyOWE0MzZiOGQ3YjhfTW85cVNFa1ZoaGtrb1cyZDI2dzRPYXdyam4yOUpXVkpfVG9rZW46Ym94Y25UTFFzSUdOS2FvMEE0MGpUZ2NFRVdlXzE2NTY0ODY2MTE6MTY1NjQ5MDIxMV9WNA)

![img](https://uestc.feishu.cn/space/api/box/stream/download/asynccode/?code=NzhmNDgyMmRhNWJkNDk1MzEyYzQzZWZlNWZjNzg4YjFfYjI5bDAxdHQzeENYMGJUWTlvQVZDMmlldUxhdEpRY2RfVG9rZW46Ym94Y250NWExVHJHNmNiTTNPT1JWMWtsbUVlXzE2NTY0ODY2MTE6MTY1NjQ5MDIxMV9WNA)

于是，遍历一遍，把每个元素的对应两个值记录到哈希表中：

```C%2B%2B
class Solution {
public:
    int countKDifference(vector<int>& nums, int k) {
        unordered_map<int, int> cnt;
        int ans = 0;
        for (auto n : nums) {
            cnt[n]++;
            ans += cnt[n-k];
            ans += cnt[n+k];
        }
        return ans;
    }
};
```

升级解法：用数组代替哈希表进行提速（多亏题目说nums[i]<100）

```C%2B%2B
class Solution {
public:
    int countKDifference(vector<int>& nums, int k) {
        int cnt[101] = {0};
        int ans = 0;
        for (auto n : nums) {
            cnt[n]++;
            if (n-k>0) ans += cnt[n-k];
            if (n+k<101) ans += cnt[n+k];
        }
        return ans;
    }
};
```







## (8)堆/优先队列

#### [1005. K 次取反后最大化的数组和 ](https://leetcode-cn.com/problems/maximize-sum-of-array-after-k-negations/)？？？



## (9)树

#### [1719. 重构一棵树的方案数](https://leetcode-cn.com/problems/number-of-ways-to-reconstruct-a-tree/)：❓❓困难题

> 说实话，题意没看懂。。。

> 参考【微扰理论】の题解

![img](https://uestc.feishu.cn/space/api/box/stream/download/asynccode/?code=N2QyMzk2MzdlOGZjOWQ2MDhiMWQ0MWNiYjI4N2M4OTlfakIxYmZMbVJFamJROUx5Y2FWbk5mOWxPcFlNUTg4OVhfVG9rZW46Ym94Y25RYjdLUnlqUWxlVlhJdG50blJYRVpjXzE2NTY0ODY2MTE6MTY1NjQ5MDIxMV9WNA)

![img](https://uestc.feishu.cn/space/api/box/stream/download/asynccode/?code=NDU4NTM4ZmEwOTIzMDJhYTFiYWVjOWRmYjY2MzE5MjlfZDM0SnYwRXpwVG9Gc3VGdWRhMHBZU2JiNHpFcWxVZHZfVG9rZW46Ym94Y24yWVZLTXowQ2pSenpUbjE3RE0xYmNiXzE2NTY0ODY2MTE6MTY1NjQ5MDIxMV9WNA)

![img](https://uestc.feishu.cn/space/api/box/stream/download/asynccode/?code=MTBhODljOTVjNDI5MDgzN2M0ZGFkMWM2ZTk5YzQzYTBfOHRzN0Y0TnQ0cUFMZnFXZWk4eFdvb2xPT3Q2bHhybnhfVG9rZW46Ym94Y24xVjFhTThRRk94dGwxMmtGbG91MzFmXzE2NTY0ODY2MTE6MTY1NjQ5MDIxMV9WNA)





# 子串匹配

#### [28. 实现 strStr()](https://leetcode-cn.com/problems/implement-strstr/)：若用模式匹配 KMP

使用find内置函数当然可以解题，两次遍历的方法也可以；但是，这里介绍的是：KMP算法！







#### [686. 重复叠加字符串匹配](https://leetcode-cn.com/problems/repeated-string-match/)：子串匹配 多解⭐

![img](https://uestc.feishu.cn/space/api/box/stream/download/asynccode/?code=Zjk5ZGE4Mzc3ZmRjNzA1NGEwYWFiMzY0YmE0ZTUxYjNfalVRckVzUEN3ZzJpcXRYSUx2Y0tDalRQbXpPQjFQaUVfVG9rZW46Ym94Y24yZHp3bmhtRVg3WVRIQmhwVk9aR3dVXzE2NTY0ODY2MTE6MTY1NjQ5MDIxMV9WNA)

**基本分析：**

首先，可以分析复制**次数**的「下界」和「上界」为何值：

对于**「下界」**的分析是容易的：**至少将 a 复制长度大于等于 b 的长度**，才有可能匹配。

在明确了「下界」后，再分析再经过多少次复制，能够明确得到答案，能够得到明确答案的最小复制次数即是上界。画个图！

由于主串是由 a 复制多次而来，并且是从主串中找到子串 b，因此可以明确子串的起始位置，不会超过 a 的长度。即长度越过 a 长度的起始匹配位置，必然在此前已经被匹配过了。

由此，我们可知复制次数**「上界」最多为「下界 + 1」**。

- 令 a 的长度为 n，b 的长度为 m，下界次数为 c1，上界次数为 c2 = c1 + 1。
- 因此我们可以对 a 复制 c2 次，得到主串后匹配 b，如果匹配成功后的结束位置不超过了 n * c1，说明复 c1即可，返回c1，超过则返回c2；匹配不成功则返回-1。



**法1：直接上下界控制+直接用C++内置函数find()**

```C%2B%2B
class Solution {
public:
    int repeatedStringMatch(string a, string b) {
        string s = a;
        int ans = 1;  //下界
        while(s.size() < b.size()){ //不是<=，注意边界⭐
            s += a;  //s.append(a);
            ans++;
        }
        s += a;  //直接与上界次数的进行子串匹配
        size_t fd = s.find(b);
        if(fd == string::npos) return -1;
        return fd + b.size() > a.size() * ans ? ans + 1 : ans;
    }
};
```

python的代码更好看一些：

```Python
class Solution:
    def repeatedStringMatch(self, a: str, b: str) -> int:
        s = a
        ans = 1
        while len(s) < len(b):
            s += a
            ans += 1
        s += a
        fd = s.find(b)
        if(fd == -1): return -1
        return ans + 1 if fd + len(b) > len(a) * ans else ans
```



**法2：KMP算法**

关于KMP初次，在：[28. 实现 strStr()](https://leetcode-cn.com/problems/implement-strstr/)



**法3：Rabin-Karp**

见官方题解的讲解





#### [1044. 最长重复子串](https://leetcode-cn.com/problems/longest-duplicate-substring/)：？没做

![img](https://uestc.feishu.cn/space/api/box/stream/download/asynccode/?code=NTMwZWYwMmNlN2NlMDVhMTgxNDFhNTYyMWMyM2EzOGVfcW41bERLcXZ3SEFic1JGeTh1dW1pd0pJS2xBSlFZZlZfVG9rZW46Ym94Y25LQzZlbUQxT1FRWFRuM2p0ZjFPUHVkXzE2NTY0ODY2MTE6MTY1NjQ5MDIxMV9WNA)

**法0：python暴力解法**

```Python
class Solution:
    def longestDupSubstring(self, s: str) -> str:
        ans = ""
        for i in range(len(s)):
            while s[i:i+len(ans)+1] in s[i+1:]:
                ans = s[i:i+len(ans) + 1]
        return ans
```



**法1：字符串哈希+二分**

![img](https://uestc.feishu.cn/space/api/box/stream/download/asynccode/?code=YWIwMGE0ZDAzZDk0ZGQ4ZmQ0ZTg0ZTBiMjVmNWM0NGJfd2E4NGNvMU5WeGtnQmZCV2tpOHRLWVVUWWFWdklkbHRfVG9rZW46Ym94Y25kSDcxZ0pGOERZUGFwN0lCdGVCR1ZoXzE2NTY0ODY2MTE6MTY1NjQ5MDIxMV9WNA)









**法1：Rabin-Karp**

> 参见微扰的题解，

![img](https://uestc.feishu.cn/space/api/box/stream/download/asynccode/?code=NTE3NDBjZjc5ODhmZDQ4NTEyZWQyNzdkNzM1OThmY2VfMW5HVGQ1cHY2RUw2VmhRajN0Z3ZZN1B5eHNIUW1iTHBfVG9rZW46Ym94Y254NHNONzZYRU83UTdqV1dzdU9YSGVlXzE2NTY0ODY2MTE6MTY1NjQ5MDIxMV9WNA)

![img](https://uestc.feishu.cn/space/api/box/stream/download/asynccode/?code=MGE1OGVjMjliMjdjNmE4NjVkZTM2MmY3M2JkZTVlYjVfQXFFYURRTVN6cGRZQjhNNmxCb2s0UW5ySDRJbWd1Z0hfVG9rZW46Ym94Y25JbUY0dnpCZUNaOHF4elE2Wm1DTU13XzE2NTY0ODY2MTE6MTY1NjQ5MDIxMV9WNA)

![img](https://uestc.feishu.cn/space/api/box/stream/download/asynccode/?code=NzczNmMyOTFjM2M3YTBlNTAyOTg1YTY1MDI5OWM5MTVfZlFsMWtqd0h0RzlFb0ZaTHdWV3RPQ3hoZkNwVHo5anJfVG9rZW46Ym94Y25CYmlIdDd6V3FxaEhyeTMySjFTNXpmXzE2NTY0ODY2MTE6MTY1NjQ5MDIxMV9WNA)











# 排序

无法复制加载中的内容

#### [937. 重新排列日志文件](https://leetcode-cn.com/problems/reorder-data-in-log-files/)：自定义规则排序

> 注意一下自定义排序书写方法

![img](https://uestc.feishu.cn/space/api/box/stream/download/asynccode/?code=ZWI0N2I3YzU1MWI5ZTBhMDkzNmNhZWIwNGY2NWYyMjVfOHB5YWtSZENYcW80ZWNmeWFIQzd0S1gxdjRmd2E1OXJfVG9rZW46Ym94Y244dmpFcXptdFBLNm5mMloza2NpYkdnXzE2NTY0ODY2MTE6MTY1NjQ5MDIxMV9WNA)

![img](https://uestc.feishu.cn/space/api/box/stream/download/asynccode/?code=NThiODg1YzMzMjc1NDY4MjFiODQ5ODI5YjU4YjhlMmNfM2RPVTVNZmdOWmRiM1VFajNYdnl1NFhRSlFqYXhoZG5fVG9rZW46Ym94Y256QmoxQktjZEdDbVVZcnU0aGFMTXBGXzE2NTY0ODY2MTE6MTY1NjQ5MDIxMV9WNA)

```C%2B%2B
class Solution {
public:
    static bool logCompare(string log1, string log2)
    {
        int i = log1.find(' '), j = log2.find(' ');
        if (log1.substr(i + 1) != log2.substr(j + 1)) {
            return log1.substr(i + 1) < log2.substr(j + 1);
        }
        return log1 < log2;
    }

    vector<string> reorderLogFiles(vector<string>& logs) {
        int n = logs.size();
        if (n <= 1) return logs;
        vector<string> digit, letter;
        for (int i = 0; i < n; ++i) {
            int j = logs[i].find(' ');
            if (isdigit(logs[i][j + 1])) {
                digit.push_back(logs[i]);
            }
            else {
                letter.push_back(logs[i]);
            }
        }
        // 自定义规则对字母日志排序
        sort(letter.begin(), letter.end(), logCompare);
        letter.insert(letter.end(), digit.begin(), digit.end());
        return letter;
    }
};
```





# 回溯算法

无法复制加载中的内容

#### [1219. 黄金矿工](https://leetcode-cn.com/problems/path-with-maximum-gold/)：dfs解决⚒ dx,dy+vis

**dx, dy控制移动方向：**类似的参考，“图论-1034.边界着色”中，注意dx, dy移动方法

还有一个注意的：**dfs函数的参数**

- 本题可以当作模板题

移动方法+dfs的写法1：

```C%2B%2B
class Solution {
public:
    vector<vector<int>> g;  // 为了gird能全局地访问⭐
    vector<vector<bool>> vis;
    int m, n;
    int dx[4] = {1, -1, 0, 0};
    int dy[4] = {0, 0, 1, -1};
    
    int getMaximumGold(vector<vector<int>>& grid) {
        m = grid.size();  // m行
        n = grid[0].size();  // n列
        g = grid;
        vis = vector<vector<bool>>(m, vector<bool>(n));
        int ans = 0;
        for(int i = 0; i < m; ++i)
            for(int j = 0; j < n; ++j) {
                vis[i][j] = true;
                ans = max(ans, dfs(i, j));
                vis[i][j] = false;
            }
        return ans;
    }

    int dfs(int i, int j) {
        int ans = g[i][j];
        for(int k = 0; k < 4; ++k){
            int x = i + dx[k], y = j + dy[k];
            if(x >= m || y >= n || x < 0 || y < 0) continue;
            if(g[x][y] == 0) continue;
            if(vis[x][y]) continue;
            vis[x][y] = true;
            ans = max(ans, g[i][j] + dfs(x, y));
            vis[x][y] = false;
        }
        return ans;
    }
};
```

其中如注释所说，专门定义一个vector<vector<int>> g 是为了gird数组能全局地访问⭐，当然还有一种方法，如下，在**dfs函数的参数**的地方有区别！

另外，关于vis数组的创建和初始化，两种方法

```C%2B%2B
方法1：
visited = vector<vector<bool>>(m, vector<bool>(n, false));
visited = vector<vector<int>>(m, vector<int>(n, 0));

方法2：这里用的就是另一种，
直接创建 vis = vector<vector<bool>>(m, vector<bool>(n));
然后再循环中初始化
```

移动写法2：

```C%2B%2B
public:
    vector<vector<int>> direct = {{1,0},{-1,0},{0,1},{0,-1}};  
    int getMaximumGold(vector<vector<int>>& grid) {...}
    int dfs(int i, int j) {
        int ans = g[i][j];
        for(auto d : direct){
            int x = i + d[0], y = j + d[1];
            ...
        }
        return ans;
    }
```

**python写法：**

```Python
class Solution:
    def getMaximumGold(self, grid: List[List[int]]) -> int:
        m, n = len(grid), len(grid[0])  # 计算 List[List[int]] m行n列
        ans = 0         
        
        def dfs(x, y):
            if x < 0 or y < 0 or x == m or y == n or not grid[x][y]:
                return 0
            record = grid[x][y]
            grid[x][y] = mx = 0
            for dx, dy in (0, 1), (1, 0), (0, -1), (-1, 0):
                mx = max(mx, dfs(x + dx, y + dy))
            grid[x][y] = record
            return record + mx
                
        for i in range(m):
            for j in range(n):
                ans = max(ans, dfs(i, j))
        
        return ans
```









# 图论

## (1)dfs / bfs

#### [1034. 边界着色](https://leetcode-cn.com/problems/coloring-a-border/)：dfs 理解题意 四个方向 vis

四个方向只要有一个与自己颜色不同则就在边界上！

```C%2B%2B
class Solution {
public:
    vector<vector<int>> visited;  //记录当前[i][j]是否被访问过
    int m, n;  //m行 n列
    int dx = {0, 0, -1, 1}  //横向移动：上，下，左，右
    int dy = {1, -1, 0, 0}  //纵向移动：上，下，左，右
    vector<vector<int>> colorBorder(vector<vector<int>>& grid, int row, int col, int color) {
        // 注意二维vector的行列数计算⭐
        m = grid.size();
        n = grid[0].size();
        // 不要忘记visited也要创建和初始化
        visited = vector<vector<int>>(m, vector<int>(n, 0));

        target = grid[row][col];
        dfs(grid, row, col, target);  //根据指定的颜色，开始深度优先搜索

        //搜索完成后，直接遍历整个数组，更改颜色
        for(int i = 0; i < m; ++i){
            for(int j = 0; j < n; ++j){
                if(grid[i][j] == 0){
                    grid[i][j] = color;
                }
            }
        }
        return grid;
    }

    void dfs(vector<vector<int>>& grid, int row, int col, int target) {
        //target是起始点参考用的颜色grid[row][col]
        if(visited[row][col]) return;
        visited[row][col] = 1;
        if(grid[row][col] != target) return;

        int cnt = 0;  //记录四个方向尝试的次数，用来区分“连通集内”的边界与非边界
        for(int i = 0; i < 4; ++i){
            // 考虑当前(row,col)移动某方向后的(x,y)
            int x = row + dx[i];
            int y = col + dy[i];
            if(0 <= x < m && 0 <= y < n){
                if(grid[x][y] == target || grid[x][y] == 0){
                    // 注意 grid[x][y] == 0 也要包含在内⭐
                    dfs(grid, x, y, target);
                    cnt++;
                }
            }
        }
        if(cnt != 4) grid[row][col] = 0;  //把0作为特殊色，因为据题意，所有的值都不会是0
    }
};
class Solution:
    def colorBorder(self, grid: List[List[int]], row: int, col: int, color: int) -> List[List[int]]:
        m, n = len(grid), len(grid[0])
        visited = [[False] * n for _ in range(m)]
        borders = []  # 记录边界的坐标(i,j)
        target = grid[row][col]

        self.dfs(grid, row, col, visited, borders, target)
        for x, y in borders:
            grid[x][y] = color
        return grid

    def dfs(self, grid, row, col, visited, borders, target):  
        visited[row][col] = True
        isBorder = False

        m, n = len(grid), len(grid[0])
        direc = ((-1, 0), (1, 0), (0, -1), (0, 1))

        for dx, dy in direc:
            x, y = row + dx, col + dy
            if 0 <= x < m and 0 <= y < n and grid[x][y] == grid[row][col]:
                if not visited[x][y]:
                    self.dfs(grid, x, y, visited, borders, target)
            else:
                isBorder = True  #说明(x,y)与矩阵边界或颜色不同点相邻，因此该点为连通块边界
        if isBorder:
            borders.append((row, col))
```

#### [200. 岛屿数量](https://leetcode-cn.com/problems/number-of-islands/)：是同类题

```C%2B%2B
class Solution {
public:
    int m, n;

    int numIslands(vector<vector<char>>& grid) {
        //m行 n列
        m = grid.size();
        n = grid[0].size();
        // if (!m) return 0;

        int num = 0;
        for (int i = 0; i < m; ++i) {
            for (int j = 0; j < n; ++j) {
                if (grid[i][j] == '1') {
                    num++;
                    dfs(grid, i, j);
                }
            }
        }
        return num;
    }

    void dfs(vector<vector<char>>& grid, int row, int col){
        grid[row][col] = '0';
        if(row-1>=0 && grid[row-1][col] == '1') dfs(grid, row-1, col);
        if(row+1<m && grid[row+1][col] == '1') dfs(grid, row+1, col);
        if(col-1>=0 && grid[row][col-1] == '1') dfs(grid, row, col-1);
        if(col+1<n && grid[row][col+1] == '1') dfs(grid, row, col+1);
    }
};
```





## (2)拓扑排序

#### [851. 喧闹和富有](https://leetcode-cn.com/problems/loud-and-rich/)：❗拓扑 or dfs

> 看起来不太适合作为拓扑的入门

> 补一下：**[拓扑排序入门](https://mp.weixin.qq.com/s?__biz=MzU4NDE3MTEyMA==&mid=2247489706&idx=1&sn=771cd807f39d1ca545640c0ef7e5baec&chksm=fd9cb3b5caeb3aa333809633f09e3967c8f62d10feec5a463c7e30d4781e1fecb50e7f46e4af&token=126965152&lang=zh_CN#rd)**

```C%2B%2B
class Solution {
public:
    // 需要使用全局变量了！
    vector<int> ans;  // 全局使用
    vector<int> quiet;
    vector<vector<int>> g;  // n行的，比i更有钱邻接矩阵
    vector<int> loudAndRich(vector<vector<int>>& richer, vector<int>& _quiet) {
        quiet = _quiet;
        int n = quiet.size();
        ans = vector<int>(n, -1);
        g = vector<vector<int>>(n);
        // 将拓扑排序图存入矩阵
        for(auto r : richer)
            g[r[1]].push_back(r[0]);
        // dfs
        for(int i = 0; i < n; ++i)
            dfs(i);
        return ans;
    }
    int dfs(int i){
        if(ans[i] != -1)
            return ans[i];
        else ans[i] = i;
        // 对比i有钱的所有节点遍历搜寻（在邻接矩阵中找）
        for(auto n : g[i]){
            if(quiet[dfs(n)] < quiet[ans[i]])
                ans[i] = dfs(n);
        }
        return ans[i];
    }
};
class Solution {
public:
    vector<int> loudAndRich(vector<vector<int>>& richer, vector<int>& quiet) {
        int n = quiet.size();
        vector<vector<int>> g(n);
        vector<int> inDegree(n);       
        // 将拓扑排序图存入矩阵+入度
        for(auto r : richer){
            g[r[0]].push_back(r[1]);  //这里与dfs不同！
            ++inDegree[r[1]];
        }
        vector<int> ans(n);
        for(int i = 0; i < n; ++i) ans[i] = i;      
        queue<int> que;
        for(int i = 0; i < n; ++i){
            if(inDegree[i] == 0)
                que.push(i);
        }
        // 拓扑：从入度为0的结点开始（从更有钱的开始，与dfds那个不同）
        while(!que.empty()){
            int x = que.front();
            que.pop();
            for(auto y : g[x]){
                if(quiet[ans[y]] > quiet[ans[x]])
                    ans[y] = ans[x];
                if(--inDegree[y] == 0)
                    que.push(y);
            }
        }
        return ans;
    }
};
```



#### [剑指 Offer II 114. 外星文字典](https://leetcode.cn/problems/Jf1JuT/)

> 困难题，没做。。



## (3)最短路径



## (4)最小生成树









# 递归 & 迭代

## DFS

无法复制加载中的内容



#### 208.Trie树：this? 模板

```C%2B%2B
class Trie {
private:
    vector<Trie*> children;
    bool isEnd;

    Trie* searchPrefix(string prefix) {
        Trie* node = this;
        for (char ch : prefix) {
            ch -= 'a';
            if (node->children[ch] == nullptr) {
                return nullptr;
            }
            node = node->children[ch];
        }
        return node;
    }

public:
    Trie() : children(26), isEnd(false) {}

    void insert(string word) {
        Trie* node = this;
        for (char ch : word) {
            ch -= 'a';
            if (node->children[ch] == nullptr) {
                node->children[ch] = new Trie();
            }
            node = node->children[ch];
        }
        node->isEnd = true;
    }

    bool search(string word) {
        Trie* node = this->searchPrefix(word);
        return node != nullptr && node->isEnd;
    }

    bool startsWith(string prefix) {
        return this->searchPrefix(prefix) != nullptr;
    }
};
class Trie:
    def __init__(self):
        self.children = [None] * 26
        self.isEnd = False
    
    def searchPrefix(self, prefix: str) -> "Trie":
        node = self
        for ch in prefix:
            ch = ord(ch) - ord("a")
            if not node.children[ch]:
                return None
            node = node.children[ch]
        return node

    def insert(self, word: str) -> None:
        node = self
        for ch in word:
            ch = ord(ch) - ord("a")
            if not node.children[ch]:
                node.children[ch] = Trie()
            node = node.children[ch]
        node.isEnd = True

    def search(self, word: str) -> bool:
        node = self.searchPrefix(word)
        return node is not None and node.isEnd

    def startsWith(self, prefix: str) -> bool:
        return self.searchPrefix(prefix) is not None
        
# Your Trie object will be instantiated and called as such:
# obj = Trie()
# obj.insert(word)
# param_2 = obj.search(word)
# param_3 = obj.startsWith(prefix)
```





#### 221.添加与搜索单词



#### [473. 火柴拼正方形](https://leetcode.cn/problems/matchsticks-to-square/)

> 剪纸？

```C%2B%2B
class Solution {
public:
    int m;
    int edgs[4] = {0};
    bool makesquare(vector<int>& match) {
        if (match.size() < 4) return false;
        int sum = accumulate(match.begin(), match.end(), 0);
        if (sum % 4 != 0) return false;
        m = sum / 4;
        sort(match.begin(), match.end(), greater<int>());  // 从大到小排序，优先选用大边可以令不成功的情况更快返回
        return dfs(match, 0);
    }
    bool dfs(vector<int>& match, int idx) {
        if (idx >= match.size()) {
            return edgs[0] == edgs[1] && edgs[1] == edgs[2] && edgs[2] == m;
        }
        for (int i = 0; i < 4; i++) {
            if (edgs[i] + match[idx] > m) continue;  // 这根火柴不能放到当前边上
            else {
                edgs[i] += match[idx];
                if (dfs(match, idx + 1)) return true;
                else edgs[i] -= match[idx];
            }
        }
        return false;
    }
};
```



#### [508. 出现次数最多的子树元素和](https://leetcode.cn/problems/most-frequent-subtree-sum/)：正常dfs

> 题意描述不清，应该理解为：

> 二叉树所有子树（包括包含根节点的树）的元素和当中，出现次数最多的，返回

1. > 所有的子树和为： [2, -3, 4] 都是出现一次，所以返回所有

2. > 所有的子树和为： [2, -5, 2] 2出现两次 ，为出现的次数最多，返回出现次数最多的元素 ：[2]

> 

- > 因此，要用上哈希表，哈希表在for(auto)中的用法，跟pair的用法一样

- > 使用dfs对树进行遍历，同时将每棵子树的总和值存入哈希表（以元素和为 key，出现次数为 value），并实时维护最大子树和，使用变量 max 存储。

- > 当遍历完整棵树后，将哈希表中值为 max 的键存入答案。

```C%2B%2B
class Solution {
public:
    unordered_map<int, int> sumMap;
    int maxCnt = 0;

    int dfs(TreeNode* node) {
        if (node == NULL) return 0;
        int sum = node->val + dfs(node->left) + dfs(node->right);
        maxCnt = max(maxCnt, ++sumMap[sum]);
        return sum;
    }
    vector<int> findFrequentTreeSum(TreeNode* root) {
        (void)dfs(root);
        vector<int> ans;
        for (auto s : sumMap) {
            if (s.second == maxCnt) ans.push_back(s.first);
        }
        return ans;
    }
};
```





#### [1020. 飞地的数量](https://leetcode-cn.com/problems/number-of-enclaves/)：直接dfs就可以，模板题⭐

![img](https://uestc.feishu.cn/space/api/box/stream/download/asynccode/?code=NDMxNDM4ODhmYzQzMDY0ZjdiMzQ1NmVmYjlkMDQwMTlfd3huQXhWV0NOTk94SjdacVl0TllLUWZFQlVzbzU1QzdfVG9rZW46Ym94Y25zMXFhOHBXcjN3NG1scThxajRzdXBjXzE2NTY0ODY2MTE6MTY1NjQ5MDIxMV9WNA)

```C%2B%2B
class Solution {
public:
    vector<vector<int>> direct = {{1,0},{-1,0},{0,1},{0,-1}};
    vector<vector<int>> g;
    int m, n;
    int numEnclaves(vector<vector<int>>& grid) {
        g = grid;
        m = grid.size(), n = grid[0].size();  // m行n列
        int ans = 0;  // 等价于找到不和边缘相连的独立块的面积和
        for (int i = 0; i < m; ++i) {
            for (int j = 0; j < n; ++j) {
               if (i == 0 || j == 0 || i == m-1 || j == n-1)
                dfs(i, j); 
            }
        }

        for (int i = 0; i < m; ++i) {
            for (int j = 0; j < n; ++j) {
                ans += g[i][j];
            }
        }
        return ans;
    }

    void dfs(int x, int y) {
        if (0 <= x && x < m && 0 <= y && y < n && g[x][y]) {
            g[x][y] = 0;  // 能到边缘的陆地置为0
            for (auto d : direct)
                dfs(x+d[0], y+d[1]);
        }
    }
};
```









## BFS

无法复制加载中的内容



#### [433. 最小基因变化](https://leetcode-cn.com/problems/minimum-genetic-mutation/)：BFS模板题



BFS总共有两个模板：

**模板一：**

如果不需要确定当前遍历到了哪一层，BFS 模板如下。

```C%2B%2B
while queue 不空：
    cur = queue.pop()
    if cur 有效且未被访问过：
        进行处理
    for 节点 in cur 的所有相邻节点：
        if 该节点有效：
            queue.push(该节点)
```

**模板二：**

如果要确定当前遍历到了哪一层，BFS 模板如下。

这里增加了 level 表示当前遍历到二叉树中的哪一层了，也可以理解为在一个图中，现在已经走了多少步了。size 表示在当前遍历层有多少个元素，也就是队列中的元素数，我们把这些元素一次性遍历完，即把当前层的所有元素都向外走了一步。

```C%2B%2B
level = 0
while queue 不空：
    size = queue.size()
    while (size --) {
        cur = queue.pop()
        if cur 有效且未被访问过：
            进行处理
        for 节点 in cur的所有相邻节点：
            if 该节点有效：
                queue.push(该节点)
    }
    level ++;
```





#### 559.N 叉树的最大深度：dfs bfs 注意写法

```Python
"""
# Definition for a Node.
class Node:
    def __init__(self, val=None, children=None):
        self.val = val
        self.children = children
"""
# dfs
class Solution:
    def maxDepth(self, root: 'Node') -> int:
        return max((self.maxDepth(child) for child in root.children), default = 0) + 1 if root else 0
# bfs
class Solution:
    def maxDepth(self, root: 'Node') -> int:
        if root is None:
            return 0
        ans = 0
        queue = [root]
        while queue:
            queue = [child for node in queue for child in node.children]
            ans += 1
        return ans
```



#### [675. 为高尔夫比赛砍树](https://leetcode.cn/problems/cut-off-trees-for-golf-event/)：BFS模板⭐ / 迪杰斯特拉

- > 包括需要记录层数的广度优先搜索

- > 可以使用自定义规则排序，也可以直接要比较的那个放在pair的前者

![img](https://uestc.feishu.cn/space/api/box/stream/download/asynccode/?code=YmE2YjY1NWU5MzRlYTNhMDM2ZTJkNWViY2U2ZWExYWZfcExJbnBDU0hIN0FHUExRcElDenJad1RmYzZkT2lIdm5fVG9rZW46Ym94Y25Od2hJb1F1d2pFMDZab0J1N3d4NE9nXzE2NTY0ODY2MTE6MTY1NjQ5MDIxMV9WNA)

- > 砍完所有的🌳

- > 只要不是障碍都可以走，但是树只能从低到高砍；也就是**不是目前最矮的树可以路过，但是不能砍**。

![img](https://uestc.feishu.cn/space/api/box/stream/download/asynccode/?code=M2YxNDViZTVhZjc0YjNlNjg4Mjk0MjJiNmE1OGYzMGVfQ0hXYjg1N3JWR0tnVDRYYXFMRzE2ekFXN2tVOEFuRlVfVG9rZW46Ym94Y25LTUpFWlZ5b3lTQTlMdFd6UGNyakJlXzE2NTY0ODY2MTE6MTY1NjQ5MDIxMV9WNA)![img](https://uestc.feishu.cn/space/api/box/stream/download/asynccode/?code=NzljNjc4Y2NmYzc1MGQ1MTI5OGQxOTlkMTMzYTVlMDFfVjltTTBxVHBldnByMTRiQmV6UmJFQ0dZN0xOR1NhU1JfVG9rZW46Ym94Y241N1RZZTdLbVJPajAySlprZ3pCTE1jXzE2NTY0ODY2MTE6MTY1NjQ5MDIxMV9WNA)

**法1：BFS⭐**

```C%2B%2B
class Solution {
public:
    int m, n;
    vector<vector<int>> direct = {{1,0},{-1,0},{0,1},{0,-1}};
    vector<vector<int>> g;

    int bfs(pair<int, int>& start, pair<int, int>& goal) {  // 从起点到目标砍的树
        if (start.first == goal.first && start.second == goal.second) return 0;
        queue<pair<int, int>> q;
        q.push(start);
        int step = 0;
        vector<vector<bool>> vis(m, vector<bool>(n, false));
        vis[start.first][start.second] = true;
        while (!q.empty()) {
            step++;
            int size = q.size();
            
            while (size--) {
                pair<int, int> p = q.front();
                q.pop();

                for (auto d : direct) {
                    int x = p.first + d[0], y = p.second + d[1];
                    if (x < 0 || y < 0 || x >= m || y >= n) continue;
                    if (g[x][y] == 0) continue;
                    if (vis[x][y]) continue;
                    if (x == goal.first && y == goal.second) return step;

                    vis[x][y] = true;
                    q.push(make_pair(x, y));
                }
            }
        }
        return -1;
    }

    int cutOffTree(vector<vector<int>>& forest) {
        m = forest.size(), n = forest[0].size();
        g = forest;
        if (g[0][0] == 0) return -1;
        vector<pair<int, pair<int, int>>> tree;  //pair<height, (i,j)>
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                if (g[i][j] > 1) tree.push_back(make_pair(g[i][j], make_pair(i, j)));
            }
        }
        sort(tree.begin(), tree.end());  // 这里可能会需要对tree.first排序

        pair<int, int> start = make_pair(0, 0);
        int ans = 0;
        for (auto t : tree) {
            int step = bfs(start, t.second);
            if (step == -1) return -1;
            ans += step;
            start = t.second;
        }
        return ans;
    }
};
```

- > BFS只搜索，并不找路径

- > 对于dx,dy的方向移动，direct的方式用时更长！

```C%2B%2B
这种写法似乎更省时！！
int dx[4] = {1, -1, 0, 0};
int dy[4] = {0, 0, 1, -1};
for (int i = 0; i < 4; i++) {
    int x = p.first + dx[i], y = p.second + dy[i];
    ...
}
```



**法2：Dijkstra 算法**

![img](https://uestc.feishu.cn/space/api/box/stream/download/asynccode/?code=MGVlMDJhMDJlOGEyYzU0OTI2ZWJlNjgyYzI5NTQ5YzhfV1kzQ2F0STZONmpDc2ludE5kVmx3clRSZXhWY3VxU29fVG9rZW46Ym94Y25aVkx5VEZab1ZWNzExZFRvM2EyM09nXzE2NTY0ODY2MTE6MTY1NjQ5MDIxMV9WNA)

```C%2B%2B
class Solution {
public:
    int dirs[4][2] = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};

    int bfs(vector<vector<int>>& forest, int sx, int sy, int tx, int ty) {
        if (sx == tx && sy == ty) return 0;

        int row = forest.size();
        int col = forest[0].size();
        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> pq;
        vector<vector<bool>> visited(row, vector<bool>(col, false));
        pq.emplace(0, sx * col + sy);
        visited[sx][sy] = true;
        while (!pq.empty()) {
            auto [dist, loc] = pq.top();
            pq.pop();
            for (int j = 0; j < 4; ++j) {
                int nx = loc / col + dirs[j][0];
                int ny = loc % col + dirs[j][1];
                if (nx >= 0 && nx < row && ny >= 0 && ny < col) {
                    if (!visited[nx][ny] && forest[nx][ny] > 0) {
                        if (nx == tx && ny == ty) return dist + 1;
                        pq.emplace(dist + 1, nx * col + ny);
                        visited[nx][ny] = true;
                    }
                }
            }
        }
        return -1;
    }

    int cutOffTree(vector<vector<int>>& forest) {
        vector<pair<int, int>> trees;
        int row = forest.size();
        int col = forest[0].size();
        for (int i = 0; i < row; ++i)
            for (int j = 0; j < col; ++j)
                if (forest[i][j] > 1) trees.emplace_back(i, j);

        sort(trees.begin(), trees.end(), [&](const pair<int, int> & a, const pair<int, int> & b) {
            return forest[a.first][a.second] < forest[b.first][b.second];
        });
        
        int cx = 0;
        int cy = 0;
        int ans = 0;
        for (int i = 0; i < trees.size(); ++i) {
            int steps = bfs(forest, cx, cy, trees[i].first, trees[i].second);
            if (steps == -1) {
                return -1;
            }
            ans += steps;
            cx = trees[i].first;
            cy = trees[i].second;
        }
        return ans;
    }
};
```





#### [691. 贴纸拼词](https://leetcode.cn/problems/stickers-to-spell-word/)：BitMap / 状态压缩 / 记忆化搜索

> 困难题

![img](https://uestc.feishu.cn/space/api/box/stream/download/asynccode/?code=MWJjMGRiNmNkMjRkYTQ4MmQ0MGY4ODViZWQ2ZTI1NzhfVnlkMlphUWhud2oxWFBRVFl0anR1eEZRc0FaaWdKVGZfVG9rZW46Ym94Y243c3BVcjF3cng4VmNFRzNnM2VYM01DXzE2NTY0ODY2MTE6MTY1NjQ5MDIxMV9WNA)

**使用位图+动态规划dp的方式：**

![img](https://uestc.feishu.cn/space/api/box/stream/download/asynccode/?code=NTVkZTYzYmUxN2M2ZjliYTdkNzE5Nzk3YmVlNDBhYzFfQ1pYYVE5RmxlMHJjRzdjaEkyS1VnMGxrQmx5bzhKalJfVG9rZW46Ym94Y243dFR3YmE0RFlrcE1zanpjRDgzSExoXzE2NTY0ODY2MTE6MTY1NjQ5MDIxMV9WNA)

```C%2B%2B
class Solution {
public:
    int minStickers(vector<string>& stickers, string target) {
        int n = target.size();
        vector<int> dp((1 << n), 0);
        queue<int> q;  // bfs
        q.push(0);
        while (!q.empty()) {
            int cur = q.front();  // 当前位的状态
            q.pop();
            for (auto s : stickers) {
                int state = cur;
                vector<int> cnt(26);
                for (auto c : s) cnt[c-'a']++;
                // 更改target每一位的state
                for (int i = 0; i < n; i++) {
                    if (cnt[target[i]-'a'] > 0 && (state & (1 << i)) == 0) {
                        state |= 1 << i;  // 第i位置为1
                        cnt[target[i]-'a']--;
                    }
                }
                if (dp[state] || state == 0) continue;
                q.push(state);
                dp[state] = dp[cur] + 1;;
                if (state == (1 << n) - 1) {
                    return dp[state];
                }
            }
        }
        return -1;
    }
};
```





#### [938. 二叉搜索树的范围和](https://leetcode-cn.com/problems/range-sum-of-bst/)：？二叉搜索树的中序遍历是有序的

```C%2B%2B
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    int rangeSumBST(TreeNode* root, int low, int high) {
        if(root==nullptr) return 0;
        if(root->val<low) return rangeSumBST(root->right,low,high);
        if(root->val>high) return rangeSumBST(root->left,low,high);
        return root->val+rangeSumBST(root->left,low,high)+rangeSumBST(root->right,low,high);
    }
};
```

优秀解法：**二叉搜索树的中序遍历是有序的**

```C%2B%2B
class Solution {
public:
    int ans = 0, low, high;
    int rangeSumBST(TreeNode* root, int _low, int _high) {
        low = _low, high = _high;
        dfs(root);
        return ans;
    }

    void dfs(TreeNode* root){
        if(root==nullptr) return;
        dfs(root->left);
        if(root->val >= low && root->val <= high) ans += root->val;
        dfs(root->right);
    }
};
```



#### [1609. 奇偶树](https://leetcode-cn.com/problems/even-odd-tree/)：bfs用队列，python无穷大inf

```C%2B%2B
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    // 直接广度优先bfs
    bool isEvenOddTree(TreeNode* root) {
        queue<TreeNode*> q;
        q.push(root);
        int level = 0;
        while (!q.empty()) {
            int size = q.size(); 
            int prev = level % 2 == 0 ? INT_MIN : INT_MAX;  // prev记录当前层的上一节点的值
            
            for (int i = 0; i < size; i++) {  //根据当前层有几个节点，来决定循环次数
                TreeNode * node = q.front();
                q.pop();
                int cur = node->val;
                if (level % 2 == cur % 2) {  // 要保证奇数层是偶数、偶数层是奇数
                    return false;
                }
                if ((level % 2 == 0 && cur <= prev) || (level % 2 == 1 && cur >= prev)) {
                    return false;
                }
                prev = cur;
                if (node->left != nullptr) q.push(node->left);
                if (node->right != nullptr) q.push(node->right);
            }
            level++;
        }

        return true;
    }
};
```

python的inf用法：

```Python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def isEvenOddTree(self, root: Optional[TreeNode]) -> bool:
        level, nodes = 0, [root]
        while nodes:
            nxt, cur = [], float("inf") if level % 2 else 0  # 奇数降序，偶数升序
            for node in nodes:
                if (level % 2 == node.val % 2) or (level % 2 and cur <= node.val) or ((not level % 2) and cur >= node.val):
                        return False
                cur = node.val
                if node.left: nxt.append(node.left)
                if node.right: nxt.append(node.right)
            nodes = nxt
            level += 1
        return True
```



# 滑动窗口

无法复制加载中的内容



#### 594. 最长和谐子序列：sort 滑动窗口 or 哈希表

2种解法：更像是枚举的滑动窗口 & 哈希表！

```C%2B%2B
class Solution {
public:
    // 比起滑动窗口，本题这个解法更像是枚举的方法
    // 本题的子序列并不是连续的子序列，可以断开，因此直接把序列sort
    int findLHS(vector<int>& nums) {
        sort(nums.begin(),nums.end());  //vector的begin和end是使用迭代器
        int begin = 0;
        int res = 0;  //res记录当前最大的
        for (int end = 0; end < nums.size(); end++) {
            while (nums[end] - nums[begin] > 1) {
                begin++;
            }
            if (nums[end] - nums[begin] == 1) {
                res = max(res, end - begin + 1);
            }
        }
        return res;
    }
};
class Solution {
public:
    // 官方题解：哈希表的方法⭐
    int findLHS(vector<int>& nums) {
        unordered_map<int, int> cnt;  // 村塾每个数出现的次数
        int res = 0;
        // 先构建哈希表
        for (int num : nums) {
            cnt[num]++;
        }
        // 再利用键值对查询次数
        for (auto [key, val] : cnt) {
            if (cnt.count(key + 1)) {
                res = max(res, val + cnt[key + 1]);
            }
        }
        return res;
    }
};
# 官方：哈希表
class Solution:
    def findLHS(self, nums: List[int]) -> int:
        cnt = Counter(nums)
        return max((val + cnt[key + 1] for key, val in cnt.items() if key + 1 in cnt), default=0)
class Solution:
    # 一个好理解的python版本，结合IDLE截图理解⭐
    def findLHS(self, nums: List[int]) -> int:
        res = 0
        cnt = collections.Counter(nums)

        for key in cnt.keys():
            if key + 1 in cnt.keys():
                res = max(res, cnt[key] + cnt[key + 1])
        return res
```

![img](https://uestc.feishu.cn/space/api/box/stream/download/asynccode/?code=ZjEwMGM5NzIwMWE5NDhkZGRkYmZiNzVhYzQ5YWY3ODdfbVd3WmFFc3U2YzVCUUNHTnlxNGpJNFhEdUdqbHRtUTJfVG9rZW46Ym94Y25tYUpMZ3FpWjhzZTd4WkRxN3I3M0JlXzE2NTY0ODY2MTE6MTY1NjQ5MDIxMV9WNA)

![img](https://uestc.feishu.cn/space/api/box/stream/download/asynccode/?code=OGZhNDM1ZDJmMjI4ZWNhMTI1YTE0YTc1OWY3NTI1OThfYk1wY3lGWFB4UUVrZXJGTnlFZXRwSm1PWjdEY1ZzR01fVG9rZW46Ym94Y25oeTJNYjJ6WGE0NjQwOWNsaXRlTWxpXzE2NTY0ODY2MTE6MTY1NjQ5MDIxMV9WNA)





#### [689. 三个无重叠子数组的最大和](https://leetcode-cn.com/problems/maximum-sum-of-3-non-overlapping-subarrays/)：3个滑动窗口

![img](https://uestc.feishu.cn/space/api/box/stream/download/asynccode/?code=MjEzY2NkZjEzNDk5OGJlNzQ1OGY3ZTQ2YjBjYmEzY2VfZXVpbjlwcm5sSHZ2NTV0c3JqMkxYc214end4UkZkR1FfVG9rZW46Ym94Y25ZandmZ1NmQXNPeFlnMFZOeWF1T1JoXzE2NTY0ODY2MTE6MTY1NjQ5MDIxMV9WNA)

三次过程中，下标要分别保存！不然就会像第一次那样出错。。

```C%2B%2B
class Solution {
public:
    vector<int> maxSumOfThreeSubarrays(vector<int> &nums, int k) {
        vector<int> ans;
        int sum1 = 0, maxSum1 = 0, maxSum1Idx = 0;
        int sum2 = 0, maxSum12 = 0, maxSum12Idx1 = 0, maxSum12Idx2 = 0;
        int sum3 = 0, maxTotal = 0;
        for (int i = k * 2; i < nums.size(); ++i) {
            sum1 += nums[i - k * 2];
            sum2 += nums[i - k];
            sum3 += nums[i];
            if (i >= k * 3 - 1) {
                if (sum1 > maxSum1) {
                    maxSum1 = sum1;
                    maxSum1Idx = i - k * 3 + 1;
                }
                if (maxSum1 + sum2 > maxSum12) {
                    maxSum12 = maxSum1 + sum2;
                    maxSum12Idx1 = maxSum1Idx;
                    maxSum12Idx2 = i - k * 2 + 1;
                }
                if (maxSum12 + sum3 > maxTotal) {
                    maxTotal = maxSum12 + sum3;
                    ans = {maxSum12Idx1, maxSum12Idx2, i - k + 1};
                }
                sum1 -= nums[i - k * 3 + 1];
                sum2 -= nums[i - k * 2 + 1];
                sum3 -= nums[i - k + 1];
            }
        }
        return ans;
    }
};
```



#### [713. 乘积小于 K 的子数组](https://leetcode-cn.com/problems/subarray-product-less-than-k/)：变长滑动窗口

```C%2B%2B
class Solution {
public:
    // 滑动窗口or双指针
    int numSubarrayProductLessThanK(vector<int>& nums, int k) {
        if (k <= 1) return 0;
        int n = nums.size(), ans = 0;
        for (int l = 0, r = 0, cur = 1; r < n; r++) {
            cur *= nums[r];
            while (cur >= k) cur /= nums[l++];
            ans += (r - l + 1);
        }
        return ans;
    }
};
```



#### [1984. 学生分数的最小差值](https://leetcode-cn.com/problems/minimum-difference-between-highest-and-lowest-of-k-scores/)：排序+滑动窗口

这是个很简单的题

![img](https://uestc.feishu.cn/space/api/box/stream/download/asynccode/?code=YjRlMWVmNTI2NjdiNzc1YzExY2U1YmM5M2MyOTE3M2JfdzQ1bXFndkN4YkR1TzJkMDN0YmVLRmRjcGJ0NFI5V1BfVG9rZW46Ym94Y24wMkdWaEFWVDlqWFExZ2JPY0pRaHFkXzE2NTY0ODY2MTE6MTY1NjQ5MDIxMV9WNA)

![img](https://uestc.feishu.cn/space/api/box/stream/download/asynccode/?code=MjE0NDJkMTVhZmY4ZGU2N2VmMmMzYzYwM2ZhZGEzZTBfWU15RzFicnlmbU03U2E1cEZJQUtaaHlPOTRxWEZWWUJfVG9rZW46Ym94Y25mNGxMSGtUUWswVlJKNzBNZFVrWkliXzE2NTY0ODY2MTE6MTY1NjQ5MDIxMV9WNA)

```C%2B%2B
class Solution {
public:
    int minimumDifference(vector<int>& nums, int k) {
        sort(nums.begin(), nums.end());
        int n = nums.size(), ans = nums[k-1] - nums[0];
        // 滑动窗口长度为k
        for (int i = k; i < n; ++i) {
            ans = min(ans, nums[i] - nums[i-k+1]);
        }
        return ans;
    }
};
```

**在python中，排序的函数有两个**

- 第一个是sort()，sort函数对序列进行永久性的改变，
- 第二个是sorted()，sorted函数在排序后会生成一个新的序列，原序列不变。

```Python
class Solution:
    def minimumDifference(self, nums: List[int], k: int) -> int:
        nums.sort()
        n = len(nums)
        ans = nums[k-1] - nums[0]
        # 滑动窗口长度为k
        for i in range(k, n):
            ans = min(ans, nums[i] - nums[i-k+1])
        return ans

        # return min(s[i + k - 1] - s[i] for i in range(len(s) - k + 1)) if k > 1 and (s:=sorted(nums)) else 0
```





# 双指针

无法复制加载中的内容



#### 3.无重复字符最长子串：滑动窗口 哈希集合unordered_set

哈希集合：记录字符是否出现过！！

如果我们依次递增地枚举子串的起始位置，那么子串的结束位置也是递增的！

这里的原因在于，假设我们选择字符串中的第k个字符作为起始位置，并且得到了不包含重复字符的最长子串的结束位置为r_k。那么当我们选择第 k+1个字符作为起始位置时，首先从k+1到 r_k的字符显然是不重复的，并且由于少了原本的第k个字符，我们可以尝试继续增大r_k ，直到右侧出现了重复字符为止。

这样一来，我们就可以使用「滑动窗口」来解决这个问题了

```C%2B%2B
class Solution {
public:
    int lengthOfLongestSubstring(string s) {
        unordered_set<char> win;  // 哈希集合，记录每个字符是否出现过
        int n = s.size();
        int rk = -1, ans = 0;  // 右指针rk
        for(int i = 0; i < n; ++i){
            if(i != 0){  //第一个开始的窗口不移动
                win.erase(s[i-1]);
            }
            while(rk+1<n && !win.count(s[rk+1])){
                win.insert(s[rk+1]);
                ++rk;
            }
            ans = max(ans, rk-i+1);
        }
        return ans;
    }
};
```



#### [825. 适龄的朋友](https://leetcode-cn.com/problems/friends-of-appropriate-ages/)：排序+双指针

这个解法，是以y为视角，看哪个x可以给自己发

![img](https://uestc.feishu.cn/space/api/box/stream/download/asynccode/?code=YTNiYzIyZjczMTI3NGQ3NTgwNGQ3NzAzOWMwNWQ5NzhfazJsVWdnbzVVN0Q4RXFpZ0liU3NaeHhmdlhocEFsdzBfVG9rZW46Ym94Y25lcE1sV016SFVyZVNtRGFZdUV2MkxnXzE2NTY0ODY2MTE6MTY1NjQ5MDIxMV9WNA)

```C%2B%2B
class Solution {
public:
    // x只会向比自己小的发送
    // 从y的视角，(i,j]， 使用双指针
    // 即对于一个确定的y，会发送好友请求的x范围为连续段：同龄y~在限定条件下的一定范围
    int numFriendRequests(vector<int>& ages) {
        sort(ages.begin(), ages.end());
        int ans = 0, n = ages.size();
        for(int k = 0, i = 0, j = 0; k < n; k++){
            while(i < k && !check(ages[i], ages[k])) i++;  // i+1开始就可以发送
            if(j < k) j = k + 1;
            while(j < n && check(ages[j], ages[k])) j++;  // 直到j之后就不能再发送
            if(j > i) ans += j - i - 1;
        }
        return ans;
    }

    // 判断条件统一写！检查是否 x->y 发送，发送则为true
    bool check(int x, int y){
        if(y <= 0.5 * x + 7) return false;
        if(y > x) return false;
        if(y > 100 && x < 100) return false; 
        return true;
    }
};
```



#### [917. 仅仅反转字母](https://leetcode-cn.com/problems/reverse-only-letters/)：

```C%2B%2B
class Solution {
public:
    string reverseOnlyLetters(string s) {
        int n = s.size();
        for (int i = 0, j = n - 1; i < j; ) {
            while (i < j && !isalpha(s[i])) i++;
            while (i < j && !isalpha(s[j])) j--;
            if (i < j) {
                swap(s[i], s[j]);
                i++, j--;
            }
        }
        return s;
    }
};
class Solution:
    def reverseOnlyLetters(self, s: str) -> str:
        ls = list(s)
        i, j = 0, len(ls)-1
        while True:
            while i < j and not ls[i].isalpha(): i += 1
            while i < j and not ls[j].isalpha(): j -= 1
            if i >= j: break
            ls[i], ls[j] = ls[j], ls[i]
            i += 1
            j -= 1
        return ''.join(ls)
```



#### [1021. 删除最外层的括号](https://leetcode.cn/problems/remove-outermost-parentheses/)：双指针模拟更好理解

> 只需要找出外层括号，删除；于是就相当于记录一下括号的深度

![img](https://uestc.feishu.cn/space/api/box/stream/download/asynccode/?code=MjllZWU3NzNmYmY3OTdiN2I3YjI5ZGRmYzY2NTgxMDVfN3NJWFQwSDFldGZXanFoV3FmYjlaMWZoUGQzaFViSFdfVG9rZW46Ym94Y25qY09BZW4xdFY4eHNPNklMOHM5ajdnXzE2NTY0ODY2MTE6MTY1NjQ5MDIxMV9WNA)

**法1：双指针**

- > 注意C++中，求子串`s.substr(a,b) `是指从a开始的b个；

- > **注意边界！！**

```C%2B%2B
string removeOuterParentheses(string s) {
    string ans;
    int n = s.size();
    for (int i = 0; i < n; i++) {
        int j = i;
        int score = 0;
        while (i == j || score != 0) {
            score += (s[j++] == '(') ? 1 : -1;
        }
        ans += s.substr(i + 1, j - i - 2);  // [i+1, j−1)  j-2-i-1+1
        i = j - 1;
    }
    return ans;
}
```

**法2：直接做一个标记，顺序很重要！**

```C%2B%2B
string removeOuterParentheses(string s) {
    string ans;
    int tag = 0;
    for (auto c : s) {
        if (c == ')') tag--;
        if (tag != 0) ans.push_back(c);
        if (c == '(') tag++;
    }
    return ans;
}
```



#### [1446. 连续字符](https://leetcode.cn/problems/consecutive-characters/)：按照下标一次遍历

> 求连续字符长度：遍历



#### [1748. 唯一元素的和](https://leetcode-cn.com/problems/sum-of-unique-elements/)：双指针 or 哈希表

![img](https://uestc.feishu.cn/space/api/box/stream/download/asynccode/?code=NTRjMDk1MTEyYWVmODZkYjRmMTFkNTAzNjc3MDUyZmZfQURKNUpKQ1lnUUo2VTlTUVZmdFF3QjhoZ1JlYmNPUUlfVG9rZW46Ym94Y25TNmlYdmpxSXQzazhrZ1ZFbkNiMEZDXzE2NTY0ODY2MTE6MTY1NjQ5MDIxMV9WNA)

**双指针的方法：**

```C%2B%2B
class Solution {
public:
    int sumOfUnique(vector<int>& nums) {
        sort(nums.begin(), nums.end());
        int n = nums.size(), ans = 0;
        for(int i = 0; i < n; ){
            int j = i;
            while(j < n && nums[j] == nums[i])
                j++;
            if(j - i == 1)
                ans += nums[i];
            i = j;
        }
        return ans;
    }
};
```



**哈希表的方法：**

```C%2B%2B
class Solution {
public:
    int sumOfUnique(vector<int>& nums) {
        unordered_map<int, int> map;
        int ans = 0;
        for(auto &i : nums)
            map[i]++;
        for(auto &i : nums){
            if(map[i] == 1)
                ans += i;
        }
        return ans;
    }
};
class Solution:
    def sumOfUnique(self, nums: List[int]) -> int:
        return sum(i for i, j in Counter(nums).items() if j == 1)
```











# 二分



> **二分查找**有不同的应用：

1. > 找到 target 的位置（常见）

2. > 找到大于等于 target 的第一个位置

3. > 找到大于 target 的第一个位置

4. > 找到小于等于 target 的第一个位置

5. > 找到小于 target 的第一个位置

总结起来，其方法：

## **几种常见的二分法及相应使用场景**

1. ### 在一个单调递增区间内查找某个值

- 使用left <= right，left初始值指向区间第一个索引（一般是0），right初始值指向区间最后一个索引（一般是n-1）；
- 找到直接返回mid；
- 如果nums[mid] < target,则left = mid + 1;
- 否则nums[mid] > target,则right = mid - 1。

```Java
public int bsearch(int[] nums, int target) {
    int left = 0, right = nums.length - 1;
    while (left <= right) {
        int mid = left + (right - left) / 2;
        if (nums[mid] == target) return mid;
        
        else if (nums[mid] < target) left = mid + 1;
        else right = mid - 1;
    }
    // 找不到target返回-1
    return -1;
}
```

1. ### 在一个单调递增区间内查找一个大于等于某个值的最小索引或小于等于某个值的最大索引

此时，如果找到这个mid值，不能直接返回，还需要判断这个值是否是最大索引或最小索引，有对应的**向左逼近**的二分查找和**向右逼近**的二分查找方法（这里的逼近是指当nums[mid]==target时，搜索域向左逼近或向右逼近）。

#### 2.1 向左逼近：查找第一个大于等于给定值的元素

> 找==目标的右侧

```Java
向左逼近：查找第一个大于等于给定值的元素
public static int bsearch1(int[] nums, int target) {
    int left = 0, right = nums.length;
    while (left < right) {
        int mid = left + (right - left) / 2;
        if (nums[mid] < target) left = mid + 1;
        else right = mid;
    }
    if (left == nums.length) return -1;
    return left;
}
```

#### 2.2 向右逼近：查找最后一个小于等于给定值的元素

> 找==目标的左侧

```Java
向右逼近：查找最后一个小于等于给定值的元素
public static int bsearch2(int[] nums, int target) {
    int left = 0, right = nums.length;
    while (left < right) {
        int mid = left + (right - left) / 2;
        if (nums[mid] > target) right = mid;
        else left = mid + 1;
    }
    if (left == 0) return -1;
    return left - 1;
}
```

#### 2.3 向左逼近和向右逼近的区别

区别主要在对nums[mid] == target场景的处理，此时，

- 如果处理为right = mid，可理解为right指针向左移动逼近mid，则是向左逼近；
- 如果处理为left = mid + 1，可理解为left指针向右移动逼近mid，则是向右逼近。

二分查找完成后返回值不一样，向左逼近是返回left，向右逼近是返回left - 1，为什么是这样，又如何理解？

- 首先明确一点，**当使用left < right类的二分查找结束时**，**left == right**，退出while循环；
- 向左逼近是当nums[mid] == target，采取right = mid，所以循环最后得到可用的mid的值，是等于right的，也等于left，所以返回left；
- 而向右逼近，当nums[mid] == target，采取的是left = mid + 1，故 mid = left - 1, 即循环最后得到可用的mid的值，是等于left - 1的，所以返回left - 1。



> 但是，不必拘泥于上述的模板！！

## 题目

#### [436. 寻找右区间](https://leetcode.cn/problems/find-right-interval/)：排序+二分

> 寻找当前区间是否有重叠区间？

> 定义：当区间 *B* 的起点 **大于等于** 区间 *A* 的终点，我们就说区间 *B* 在区间 *A* 的右侧。

![img](https://uestc.feishu.cn/space/api/box/stream/download/asynccode/?code=OTQwOWRkODg1MjgzZWM0MDA4NmYzZjM1NDU3ZWZhN2JfY2pVbkxEWUVEMzRRMWJ3eDV2dGVpVW85dnY3bVEwRVVfVG9rZW46Ym94Y25XVk1wS3pPcmNoRDE0eVc0WGtwOGhlXzE2NTY0ODY2MTE6MTY1NjQ5MDIxMV9WNA)

> 这里的二分查找，就是找>=target的第一个位置

![img](https://uestc.feishu.cn/space/api/box/stream/download/asynccode/?code=Y2FkNDk3MTIxNzgzNDY1Y2E3NTBmYjE4MDkzNjA5NWRfRnRjVktSUFo1TFVWMUZNbGJYd1lQZUx0ZGxMdzZVSlpfVG9rZW46Ym94Y25OaldldXROOHdoYnhZZjRpMVhDTExjXzE2NTY0ODY2MTE6MTY1NjQ5MDIxMV9WNA)

```Java
class Solution {
    public int[] findRightInterval(int[][] its) {
        int n = its.length;
        int[][] clone = new int[n][2];
        for (int i = 0; i < n; i++) clone[i] = new int[]{its[i][0], i};
        Arrays.sort(clone, (a,b)->a[0]-b[0]);
        int[] ans = new int[n];
        for (int i = 0; i < n; i++) {
            int l = 0, r = n - 1;
            while (l < r) {
                int mid = l + r >> 1;
                if (clone[mid][0] >= its[i][1]) r = mid;
                else l = mid + 1;
            }
            ans[i] = clone[r][0] >= its[i][1] ? clone[r][1] : -1;
        }
        return ans;
    }
}
官方题解：
    vector<int> findRightInterval(vector<vector<int>>& its) {
        vector<pair<int, int>> itsPair;
        int n = its.size();
        for (int i = 0; i < n; i++) {
            itsPair.emplace_back(its[i][0], i);
        }
        sort(itsPair.begin(), itsPair.end());

        vector<int> ans(n, -1);
        for (int i = 0; i < n; i++) {
            auto it = lower_bound(itsPair.begin(), itsPair.end(), make_pair(its[i][1], 0));
            if (it != itsPair.end()) {
                ans[i] = it->second;
            }
        }
        return ans;
```

- > `lower_bound`用于查找容器中大于等于某值的数，返回这个数的指针。

- > `upper_bound`用于查找容器中大于某值的数，返回这个数的指针。

- > `#include <algorithm>`



#### [475. 供暖器](https://leetcode-cn.com/problems/heaters/)：含有贪心思想的双指针？

关于复杂度的计算：

![img](https://uestc.feishu.cn/space/api/box/stream/download/asynccode/?code=ZDkxYjA5MzRiOGIxODFiZmQ3OWJlYWFlYWRkMGM3YzBfemM2bllwSllCRkw5cnBDbVFHRjJ2enlEZTkwbVk0bEFfVG9rZW46Ym94Y256cWJzbGV4MXp0SkdacHQyUVU1TTNkXzE2NTY0ODY2MTE6MTY1NjQ5MDIxMV9WNA)

优解：在heater两端设置两个极限情况，用来控制边界

```C%2B%2B
class Solution {
public:
    int findRadius(vector<int>& houses, vector<int>& heaters) {
        sort(houses.begin(), houses.end());
        sort(heaters.begin(), heaters.end());
        // 增加左右两个控制边界的heater
        heaters.insert(heaters.begin(), INT_MIN);
        heaters.push_back(INT_MAX);

        long long r = 0;
        int n = heaters.size(), m = houses.size();
        int cur = 0;
        for(int i = 0; i < m; i++){
            while(cur <= n + 1){
                if(heaters[cur] >= houses[i])
                    break;
                else cur++;
            }
            long long x = min((long long)heaters[cur] - houses[i], (long long)houses[i] - heaters[cur - 1]);
            r = max(r, x);
        }

        return r;
    }
};

// 一个技巧：我们可以直接在左边和右边分别放置一个最远的加热器，
// 它不会成为到房屋最近的加热器，但是让我们不再需要处理边界条件了
```



#### [540. 有序数组中的单一元素](https://leetcode-cn.com/problems/single-element-in-a-sorted-array/)：脑筋急转弯？明确要求复杂度

![img](https://uestc.feishu.cn/space/api/box/stream/download/asynccode/?code=MGUzY2FjNTE2ZTBhOGE1ZDkxNWYyMzg0OGM2Nzc0OWNfV1VCZFdpbnBBVVFCeDRNZHJ6eGhIajJZclAwdkIxMWVfVG9rZW46Ym94Y25EVW12V3NvdHBJeFFEOWJGRlR4Nm9nXzE2NTY0ODY2MTE6MTY1NjQ5MDIxMV9WNA)

关键在于：怎么样二分？由于这是一个有序数组：

![img](https://uestc.feishu.cn/space/api/box/stream/download/asynccode/?code=NTU5NDBkYWMwMDQxMzAzMDNkMGMxODk0MjRmZmE1YzJfbldNd1Bkb083amFXcUlURGpwT2w1UE9LaW82WGZudDJfVG9rZW46Ym94Y244Z1R6dmtZQzh2TDlJRTJIYVgxbmVkXzE2NTY0ODY2MTE6MTY1NjQ5MDIxMV9WNA)

```C%2B%2B
class Solution {
public:
    // 题目明确要求O(log n)的时间复杂度：二分查找😅
    int singleNonDuplicate(vector<int>& nums) {
        int n = nums.size();
        int l = 0, r = n - 1;
        while (l < r) {
            int mid = (l + r) / 2;
            if (mid % 2 == 0) {
                if (mid + 1 < n && nums[mid] == nums[mid + 1]) l = mid + 1;  //说明在mid右边
                else r = mid;  // 说明在mid左边
            }
            else {
                if (mid - 1 >= 0 && nums[mid - 1] == nums[mid]) l = mid + 1;
                else r = mid;
            }
        }
        return nums[r];
    }
};
```

> 由于数组有序，且只有一个元素出现一次；剩下所有元素结对出现。

> 那么对于 [l, mid]，[mid+1, r] 两段区间而言，唯一的元素 target 必然出现在两者之一的位置。

> 考虑数组中任意偶数下标x的元素：如果x之前，没有出现过 target，显然 x 和 x+1 对应的元素应该是一样的，因为没有出现target则意味着所有元素都是成对出现。



#### [668. 乘法表中第k小的数](https://leetcode.cn/problems/kth-smallest-number-in-multiplication-table/)：困难题，妙思

![img](https://uestc.feishu.cn/space/api/box/stream/download/asynccode/?code=Yzk3ODE5NDA3ZjBlMTNiNmQ2NTdhZDQ2MzlhODI3NWRfRG8ya3Q0UlUyTkZYVUxNaGMzelMwcUZDTkY1ejNpNGdfVG9rZW46Ym94Y255SURrd2RmYmtuUXdrRFhMMEM0cDdiXzE2NTY0ODY2MTE6MTY1NjQ5MDIxMV9WNA)

![img](https://uestc.feishu.cn/space/api/box/stream/download/asynccode/?code=MTdkNzJkZWFlNTczNTdhYTRhZGYyMjgxMzE2OTZlOGRfOFkweFRMb1pvRkp4Q2lCUVJXZDJ6dGU0eEMzMk9oRjdfVG9rZW46Ym94Y255dnAwaUtxWnN6MHdYY0NJajF4QVVoXzE2NTY0ODY2MTE6MTY1NjQ5MDIxMV9WNA)

**本题的关键思想：**

![img](https://uestc.feishu.cn/space/api/box/stream/download/asynccode/?code=ZGQxODFhNzgyYzA5ZWI2YjI4OWIxOTc2OWI1ZWFmMmNfNVFrTnpiTEVuWW9yejFybmw4Z0J6MkJFVEUwMEhSd1BfVG9rZW46Ym94Y25Pa2ozUG9BRklpQkFyN0Jub0pRSDdnXzE2NTY0ODY2MTE6MTY1NjQ5MDIxMV9WNA)

```Java
class Solution {
public:
    int getCnt(int m, int n, int k) {  // 获取<=k的数目
        int res = 0;
        for (int i = 1; i <= m; i++) {
            res += min(k / i, n);
        }
        return res;
    }
    int findKthNumber(int m, int n, int k) {
        int l = 1, r = m * n;  // l,r 规定了候选区间的左右边界
        while (l < r) {   // 不能写成<=，会死循环！！
            int mid = l + (r - l) / 2;
            if (getCnt(m, n, mid) >= k) r = mid;
            else l = mid + 1;
        }
        return l;
    }
};
```



#### [719. 找出第 K 小的数对距离](https://leetcode.cn/problems/find-k-th-smallest-pair-distance/)：二分+双指针

转化了一下思路：“第k小的”-->“距离取值范围，取到哪个会让恰好有k个”

- > 思路：我们先对数组进行排序，设数对距离为dis，则dis的取值范围是**[0,nums[n-1]-nums[0]]**，然后我们通过**二分查找**第k小距离是多少。

- > 为了找到当前小于mid的数对个数，我们可以通过**双指针**来计算贡献值。

- > 可统计值小于等于 mid 的数量：枚举左端点 i，每次找第一个不满足条件的右端点 j

- > 由于j是第一个不满足条件的值，因此合法右端点范围为`[i+1, j-1]`，共`j-i-1`个，

- > 利用 nums 有序，并且所有nums[i]均为正数，可知 j 会随着 i 增大而逐步增大，即这部分利用「双指针」可实现 O(n) 复杂度

```C%2B%2B
class Solution {
public:
    int check(int mid, vector<int> nums)  // 间距比mid小的个数
    {
        int n = nums.size(), ans = 0;
        for (int i = 0, j = 1; i < n; i++) {
            while (j < n && nums[j] - nums[i] <= mid) j++;
            ans += (j - i - 1);
        }
        return ans;
    }
    int smallestDistancePair(vector<int>& nums, int k) {
        sort(nums.begin(), nums.end());
        int n = nums.size();
        int l = 0, r = nums[n - 1] - nums[0];  // 间距的取值左右边界
        while (l < r) {
            int mid = l + (r - l) / 2;
            if (check(mid, nums) >= k) r = mid;  // 比mid小的个数是否有k个
            else l = mid + 1;
        }
        return r;  // l=r=mid，因为是第k个！
    }
};
```



#### [875. 爱吃香蕉的珂珂](https://leetcode.cn/problems/koko-eating-bananas/)：分析好边界！

```PowerShell
示例 1：
输入：piles = [3,6,7,11], h = 8
输出：4
示例 2：
输入：piles = [30,11,23,4,20], h = 5
输出：30
示例 3：
输入：piles = [30,11,23,4,20], h = 6
输出：23
```

- > 速度大于`max(piles[i])`，实则是无效的，因为每小时一堆；

- > 当h太小，吃不完就可以摆烂了😅

![img](https://uestc.feishu.cn/space/api/box/stream/download/asynccode/?code=MDdmM2Q5NTAzZjQ5NWE0NzYxYWU2YTM4ZmNmYTQ5ZmVfNjA5bUo3cFFieldMYXVjNG93VVlVVU0zZkRkVlVKbENfVG9rZW46Ym94Y25CenJMM1lGY291aDhJM1cwS0pDV2RmXzE2NTY0ODY2MTE6MTY1NjQ5MDIxMV9WNA)

- 计算出以当前mid的速度吃掉，需要消耗多少时间，也很重要！
- 我的解法：`ans += pile%mid==0 ? pile/mid : pile/mid + 1;`

![img](https://uestc.feishu.cn/space/api/box/stream/download/asynccode/?code=OTY5ZDJmMWMxOTc2MmMxMDE0ZTk1YWQ5ZjRjYzc0YWJfNXhGdTZwU2hwQ3ozYXFwVDVWMXlHcEhXc1ZFZ1ZONmlfVG9rZW46Ym94Y25nNnN2VGhIR2lneEJtcGdheXRZczBkXzE2NTY0ODY2MTE6MTY1NjQ5MDIxMV9WNA)

```C%2B%2B
class Solution {
public:
    bool check (vector<int>& piles, int h, int mid) {
        int ans = 0;
        for (int& pile : piles) 
            // ans += (pile + mid - 1) / mid;
            ans += pile%mid==0 ? pile/mid : pile/mid + 1;
        if (ans <= h) return true;
        else return false;
    }
    int minEatingSpeed(vector<int>& piles, int h) {
        int maxNum = INT_MIN;  // #include <limits.h>
        for (auto& pile : piles) maxNum = max(maxNum, pile);

        int l = 1, r = maxNum;
        while (l < r) {
            int mid = l + (r - l) / 2;
            if (check(piles, h, mid)) r = mid; // r是最起码的速度
            else l = mid + 1;
        }
        return l;
    }
};
```







#### [911. 在线选举](https://leetcode-cn.com/problems/online-election/)：

实现思路：可以参考演草

![img](https://uestc.feishu.cn/space/api/box/stream/download/asynccode/?code=OWM5YWY1ZWI3MDdmY2NiY2Y1YjYxZmFmYzFjZDQ3ZWZfQWdPZ1VuM3FSaVVJUGtnNWwzbUNVdFFzQmdBYWo5V1VfVG9rZW46Ym94Y240bTBMTmdkVUo4QVNpVzhKSjNlcGtmXzE2NTY0ODY2MTE6MTY1NjQ5MDIxMV9WNA)

#### 









# 并查集

无法复制加载中的内容





# 数学

#### [50. Pow(x, n)](https://leetcode-cn.com/problems/powx-n/)：二进制移位，快速幂

```C%2B%2B
class Solution {
public:
    double myPow(double x, int n) {
        long long N = n;
        return N >= 0 ? quickMul(x, N) : 1.0 / quickMul(x, -N);
    }
    double quickMul(double x, long long N) {
        double ans = 1.0;
        while (N > 0){
            if(N&1)
                ans *= x;
            x *= x;
            N >>= 1;
        }
        return ans;
    }
};
class Solution:
    def myPow(self, x: float, n: int) -> float:
        return self.quickMul(x, n) if n >= 0 else 1.0 / self.quickMul(x, -n)
    def quickMul(self, x, N):
        ans = 1.0
        while N > 0:
            if N % 2 == 1:
                ans *= x
            x *= x
            N //= 2
        return ans
```



#### [372. 超级次方](https://leetcode-cn.com/problems/super-pow/)：秦九韶，快速幂

C++注意防止越界！

```C%2B%2B
class Solution {
public:
    // 直接：秦九韶算法的思想
    const int MOD = 1337;
    int superPow(int a, vector<int>& b) {
        int ans = 1;
        for(int i : b){
            // [(a^i1)^10 * a^i2]^10 * a^i3
            ans = (long) mypow(ans, 10) * mypow(a, i) % MOD;
        }
        return ans;
    }

    int mypow(int a, int n){
        // 化为二进制快速幂，a^n(mod 1337)，其中n是个位数
        int res = 1;
        while(n){
            if(n & 1){
                res = (long) res * a % MOD;
            }
            a = (long) a * a % MOD;
            // 遇到问题： runtime error: signed integer overflow
            n >>= 1;  // n /= 2;同理
        }
        return res;
    }
};
class Solution:
    def superPow(self, a: int, b: List[int]) -> int:
        # a^b(mod 1337)
        MOD = 1337
        ans = 1
        for e in b:
            ans = pow(ans, 10, MOD) * pow(a, e, MOD) % MOD
        return ans
```



#### [478. 在圆内随机生成点](https://leetcode.cn/problems/generate-random-point-in-a-circle/)：圆内的随机数

![img](https://uestc.feishu.cn/space/api/box/stream/download/asynccode/?code=Mjg5NGI0ZDBlZDExZDQ0ZmI2MTJhZjVlYzg5MDViYTFfRk8zbDVibXV1VmdHcWJLS3BBRHNsMFc1QU1IZ3JPTmRfVG9rZW46Ym94Y24yNFFUM1FRSHNFT0RGUWQ2cUhzbk1nXzE2NTY0ODY2MTE6MTY1NjQ5MDIxMV9WNA)

![img](https://uestc.feishu.cn/space/api/box/stream/download/asynccode/?code=Njg1NmIwM2IyZWU0ZTFkZWE5N2M5YzdhZTZiZTYwNDdfNDBaT052SFlPOEFwNUZ4NEpSc0lTSHdycUtoRU9RZGxfVG9rZW46Ym94Y24yM1hEOEJFOGpqeHZWQWxxc0FtVGplXzE2NTY0ODY2MTE6MTY1NjQ5MDIxMV9WNA)

1. > `rand() / double(RAND_MAX) `产生随机数的范围是0至1；

2. > `rand() / double(RAND_MAX) * 2 * r` 产生随机数范围为0至2r;

3. > `rand() / double(RAND_MAX) * 2 * r - r + x`产生随机数范围为x-r至x+r

```C%2B%2B
#include <cmath>
class Solution {
public:
    double r, x, y;
    Solution(double radius, double x_center, double y_center): r(radius), x(x_center), y(y_center) {}
    
    vector<double> randPoint() {
        while (1) {
            double ranx = rand() / double(RAND_MAX) * 2 * r - r + x;
            double rany = rand() / double(RAND_MAX) * 2 * r - r + y;
            if (pow(x - ranx, 2) + pow(y - rany, 2) <= pow(r, 2))
                return vector<double> {ranx, rany};
        }
        // return vector<double>();
    }
};

/**
 * Your Solution object will be instantiated and called as such:
 * Solution* obj = new Solution(radius, x_center, y_center);
 * vector<double> param_1 = obj->randPoint();
 */
```

- 注意`class Solution`的初始化；
- 注意`rand()`函数的使用方法



#### [497. 非重叠矩形中的随机点](https://leetcode.cn/problems/random-point-in-non-overlapping-rectangles/)：按面积抽样

方法1：直接按照面积来分配概率

![img](https://uestc.feishu.cn/space/api/box/stream/download/asynccode/?code=NjM2M2RmMjc1NmNmZGM1NjFjZmI1NzE4MGQyNzhlYTBfM3dqbTRhNHpBWG4wYlFaWHJidEYyR0dwellhT3ZUMlFfVG9rZW46Ym94Y25pQlllOXEzUkswOUpyYlFUa2dFaElnXzE2NTY0ODY2MTE6MTY1NjQ5MDIxMV9WNA)

```C%2B%2B
class Solution {
public:
    vector<vector<int>> recs;
    Solution(vector<vector<int>>& rectangles) {
        recs = rectangles;
    }
    
    vector<int> pick() {
        int idx = 0, curp = 0, allp = 0;
        int n = recs.size();
        for (int i = 0; i < n; i++) {
            int x1 = recs[i][0], y1 = recs[i][1];
            int x2 = recs[i][2], y2 = recs[i][3];
            curp = (x2 - x1 + 1) * (y2 - y1 + 1);
            allp += curp;
            if (rand() % allp < curp) idx = i;
        }
        int x = recs[idx][0] + rand() % (recs[idx][2] - recs[idx][0] + 1);
        int y = recs[idx][1] + rand() % (recs[idx][3] - recs[idx][1] + 1);
        return {x, y};
    }
};
```

> 如何选定一个矩形，还是按照随机的方式：巧思！



方法2：前缀和+二分？









#### [829. 连续整数求和](https://leetcode.cn/problems/consecutive-numbers-sum/)：运用数论

```Makefile
给定一个正整数 n，返回 连续正整数满足所有数字之和为 n 的组数 。 

示例 1:
输入: n = 5
输出: 2
解释: 5 = 2 + 3，共有两组连续整数([5],[2,3])求和后为 5。

示例 2:
输入: n = 9
输出: 3
解释: 9 = 4 + 5 = 2 + 3 + 4

示例 3:
输入: n = 15
输出: 4
解释: 15 = 8 + 7 = 4 + 5 + 6 = 1 + 2 + 3 + 4 + 5
```

原来数学也能解决算法题！！

![img](https://uestc.feishu.cn/space/api/box/stream/download/asynccode/?code=ZThkMWRhYWFkY2ZmMjU2Y2Y3MTg1NWUwODlkM2VlZWRfTFpiRXNNNXluVDNWaHE3eUZrUEhhd21pZkhOc3Q0NWJfVG9rZW46Ym94Y250R1VSWEFZcnlCRVFBZ2tJMFhxRDZjXzE2NTY0ODY2MTE6MTY1NjQ5MDIxMV9WNA)

```Java
class Solution {
public:
    int consecutiveNumbersSum(int n) {
        int ans = 0;
        for (int k = 1; k*k < 2*n; k++) {
            if (2*n % k != 0) continue;
            // (2a+k−1)×k=2n 
            if ((2*n/k - (k-1)) % 2 == 0) ans++;
        }
        return ans;
    }
};
```



#### [1610. 可见点的最大数目](https://leetcode-cn.com/problems/maximum-number-of-visible-points/)：极坐标+滑动窗口

注意极坐标的转化方法！

```C%2B%2B
class Solution {
public:
    // 全部换为[0,2π]上的极坐标就行，计算角度，从小到大放入排序？+滑动窗口
    int visiblePoints(vector<vector<int>>& points, int angle, vector<int>& location) {
        int sameCnt = 0;
        vector<double> polarDegrees;
        for (auto & point : points) {
            if (point[0] == location[0] && point[1] == location[1]) {
                sameCnt++;
                continue;
            }
            // atan2的返回值范围为[−π,π]，覆盖范围为2π，atan2(y,x)=>arctan(y/x)
            double degree = atan2(point[1] - location[1], point[0] - location[0]);
            polarDegrees.push_back(degree);
        }
        sort(polarDegrees.begin(), polarDegrees.end());
        int m = polarDegrees.size();
        for (int i = 0; i < m; ++i) {
            polarDegrees.push_back(polarDegrees[i] + 2 * M_PI);  // 全部把区间换为[0,2π]
        }

        int maxCnt = 0;
        int right = 0;  // 滑动窗口右下标
        double polar_angle = angle * M_PI / 180;
        for (int i = 0; i < m; ++i) {
            while (right < polarDegrees.size() && polarDegrees[right] <= polarDegrees[i] + polar_angle) {
                right++;  // 符合角度范围条件就一直增大窗口
            }
            maxCnt = max(maxCnt, right - i);
        }
        return maxCnt + sameCnt;
    }
};
```

####  

#### [1447. 最简分数](https://leetcode-cn.com/problems/simplified-fractions/)：利用gcd(a,b)

```C%2B%2B
class Solution {
public:
    vector<string> simplifiedFractions(int n) {
        vector<string> ans;
        for (int b = 2; b <= n; ++b) {
            for (int a = 1; a < b; ++a) {
                if (gcd(a, b) == 1)
                    ans.push_back(to_string(a) + "/" + to_string(b));  // =>a/b
            }
        }
        return ans;
    }
};
class Solution:
    def simplifiedFractions(self, n: int) -> List[str]:
        return ["{}/{}".format(a,b) for b in range(2, n + 1) for a in range(1,b) if gcd(a, b) == 1]
```

这里，还可尝试几种求解最大公约数的方法：

**辗转相除法：**

一行代码就能实现gcd！！

```Python
class Solution:
    def simplifiedFractions(self, n: int) -> List[str]:
        
        def my_gcd(a, b):
            return my_gcd(b % a, a) if b % a else a

        return ["{}/{}".format(a,b) for b in range(2, n + 1) for a in range(1,b) if my_gcd(a, b) == 1]
class Solution {
public:
    vector<string> simplifiedFractions(int n) {
        vector<string> ans;
        for (int b = 2; b <= n; ++b) {
            for (int a = 1; a < b; ++a) {
                if (_gcd(a, b) == 1)
                    ans.push_back(to_string(a) + "/" + to_string(b));  // =>a/b
            }
        }
        return ans;
    }

    int _gcd (int a, int b) {
        return b % a == 0 ? a : gcd(b % a, a);
    }

};
```

**更相减损术：**

```Python
class Solution:
    def simplifiedFractions(self, n: int) -> List[str]:
        def my_gcd(a, b):
            while True:
                if a>b: a-=b
                elif a<b: b-=a
                else: return a

        return ["{}/{}".format(a,b) for b in range(2, n + 1) for a in range(1,b) if my_gcd(a, b) == 1]
```

**素数筛：**

```Python
class Solution:
    def simplifiedFractions(self, n: int) -> List[str]:
        isPrime = [True] * (n + 1)
        primes = []
        for i in range(2, n + 1):  # j/i
            if isPrime[i]:
                for j in range(i * i, n + 1, i):
                    isPrime[j] = False
                primes.append(i)
        ans = []
        # 枚举分母
        for i in range(2, n + 1):
            if isPrime[i]:
                ans += ["{}/{}".format(j, i) for j in range(1, i)]
            else:
                idx, ps = 0, set()
                # 分母的所有质因子
                while idx < len(primes) and primes[idx] < i // 2 + 1:
                    if not i % primes[idx]:
                        ps.add(primes[idx])
                    idx += 1
                s = set()
                # 构造分母的所有最大公约数不为1的分子
                for p in ps:
                    for j in range(p, i, p):
                        s.add(j)
                ans += ["{}/{}".format(j, i) for j in range(1, i) if j not in s]
        return ans
```



#### [1518. 换酒问题](https://leetcode-cn.com/problems/water-bottles/)

![img](https://uestc.feishu.cn/space/api/box/stream/download/asynccode/?code=MTExMmZiODFiODQzYzIwYmFhMjg4Nzg2NGU5MDA4NWZfSURSVlJpNTV3cGp6aFZZT3VCQVJsQzBqcnMxb0tZZlNfVG9rZW46Ym94Y25ERUp0SFFIckFBYUNVdm5ZWGJKUGg3XzE2NTY0ODY2MTE6MTY1NjQ5MDIxMV9WNA)

```Python
class Solution:
    def numWaterBottles(self, numBottles: int, numExchange: int) -> int:
        ans = numBottles
        while numBottles >= numExchange:
            a, b = numBottles // numExchange, numBottles % numExchange
            ans += a
            numBottles = a + b
        return ans
```

#### [2022. 一维数组变成二维](https://leetcode-cn.com/problems/convert-1d-array-into-2d-array/)：巧妙的写法+emplace_back

```C%2B%2B
class Solution {
public:
    vector<vector<int>> construct2DArray(vector<int>& original, int m, int n) {
        vector<vector<int>> ans;
        if(original.size() != m * n)
            return ans;
        for(auto p = original.begin(); p != original.end(); p += n){
            ans.emplace_back(p, p + n);
        }
        return ans;
    }
};
class Solution:
    def construct2DArray(self, original: List[int], m: int, n: int) -> List[List[int]]:
        length = len(original)
        if length != m * n:
            return []
        return [original[i : i + n] for i in range(0, length, n)]
```





# 动态规划

- > 发现dp的问题大多与**前缀和**有关：**前缀和就是从位置1到位置i这个区间内的所有的数字之和**

## (0)动态规划





## [(1)记忆化搜索](https://github.com/SharingSource/LogicStack-LeetCode/wiki/记忆化搜索)

## [(2)线性 DP](https://github.com/SharingSource/LogicStack-LeetCode/wiki/线性-DP)

无法复制加载中的内容

#### [467. 环绕字符串中唯一的子字符串](https://leetcode.cn/problems/unique-substrings-in-wraparound-string/)：DP or 前缀和

- 无限环绕字符串s任意两个相邻字符都满足字典序上的相邻，`s[i] == (s[i-1] + 1) % 26`
- 这意味着所以p中的子串如果是s的子串，也必须同样满足这个性质

**我们可以定义** ***dp*****[*****α*****] 表示** ***p*** **中以字符** ***α*** **结尾且在** ***s*** **中的子串的最长长度**

![img](https://uestc.feishu.cn/space/api/box/stream/download/asynccode/?code=ZjNiMDFlMDA4NGU5YTFkY2I3N2MyMjYxNWU5YTRkZTNfOTl5eEExRGg5U2lSSlhrUVNoMGY0V3AzcjZQVTNPZDRfVG9rZW46Ym94Y254MHU4d3dMbjdzNHdTUE0xdlRBSzVjXzE2NTY0ODY2MTE6MTY1NjQ5MDIxMV9WNA)

```C%2B%2B
    int findSubstringInWraproundString(string p) {
        int n = p.size();
        int k = 0;
        vector<int> dp(26);
        for (int i = 0; i < n; i++) {
            if (i > 0 && (p[i] - p[i - 1] + 26) % 26 == 1) k++;
            else k = 1;
            dp[p[i] - 'a'] = max(k, dp[p[i] - 'a']);  // 不能重复算上子串 
        }
        return accumulate(dp.begin(), dp.end(), 0);
    }
```



#### [688. 骑士在棋盘上的概率](https://leetcode-cn.com/problems/knight-probability-in-chessboard/)：概率一定是连续递推

首先是动规DP的思想

此外，要注意移动方向dx、dy两种写法

**【三叶】の题解：**

![img](https://uestc.feishu.cn/space/api/box/stream/download/asynccode/?code=MzMwNTg3NTdiMjMzNTk2OGM1NzQ1NTk1NjE5OTI5NzRfc1hvdzJrTk16Q3BxS29kSG9xM2tyTkFYamJiNnlqNE1fVG9rZW46Ym94Y25xYVpvM3Y1cVpoamp3eHVrbGJNSDVnXzE2NTY0ODY2MTE6MTY1NjQ5MDIxMV9WNA)

```
**dp[i][j][p] => 从位置(i, j)出发，走不超过p步后仍在棋盘内的概率**
class Solution {
public:
    // 移动k步过程中离开棋盘就不算了。。
    // dp[i][j][p] => 从位置(i, j)出发，走不超过p步后仍在棋盘内的概率
    double knightProbability(int n, int k, int row, int column) {
        int dirs[8][2] = {{-1,-2},{-1,2},{1,-2},{1,2},{-2,1},{-2,-1},{2,1},{2,-1}};
        // double dp[n][n][k+1]; 没有初始化❌
        // double dp[n][n][k+1] = {0}; 这种初始化是错误的写法❌
        vector<vector<vector<double>>> dp(n, vector<vector<double>>(n, vector<double>(k+1)));  // 才是可以的
        (k + 1, vector<vector<double>>(n, vector<double>(n)));
        for (int i = 0; i < n; ++i)
            for (int j = 0; j < n; ++j)
                dp[i][j][0] = 1;
        for (int p = 1; p <= k; ++p) {
            for (int i = 0; i < n; ++i) {
                for (int j = 0; j < n; ++j) {
                    for (auto d : dirs) {
                        int nx = i + d[0], ny = j + d[1];
                        if (nx < 0 || nx >= n || ny < 0 || ny >= n) continue;
                        dp[i][j][p] += dp[nx][ny][p-1] / 8;
                    }
                }
            }
        }
        return dp[row][column][k];
    }
};
```

注意关于**数组的初始化**！

- `double dp[n][n][k+1];` 没有初始化❌
- `double dp[n][n][k+1] = {0};` 这种初始化是错误的写法❌
- 只有`**vector**``<vector<vector<double>>> dp(n, vector<vector<double>>(n, vector<double>(k+1))); `  才是正确的写法，**不用单独进行初始化**！

```Python
class Solution:
    def knightProbability(self, n: int, k: int, row: int, column: int) -> float:
        dp = [[[0] * (k+1) for _ in range(n)] for _ in range(n)]
        for i in range(n):
            for j in range(n):
                dp[i][j][0] = 1
        for p in range(1, k+1):
            for i in range(n):
                for j in range(n):
                    for dx, dy in ((-2, -1), (-2, 1), (2, -1), (2, 1), (-1, -2), (-1, 2), (1, -2), (1, 2)):
                        nx, ny = i + dx, j + dy
                        if nx < 0 or nx >= n or ny < 0 or ny >= n: continue
                        dp[i][j][p] += dp[nx][ny][p-1] / 8
        return dp[row][column][k]
```

> **Python 解法要注意：for循环的层次不要写错！！**



#### [926. 将字符串翻转到单调递增](https://leetcode.cn/problems/flip-string-to-monotone-increasing/)：前缀和？线性遍历

**思路1：前缀和**

我们发现，如果一个字符串单调递增，那么该字符串一定可以分为两部分，前一部分全为字符 0，后一部分全为字符 1。

那么，我们可以遍历所有的 n 个位置，分别作为目标字符串 0 与 1 的分界线。这样，我们只需要对于每个位置，计算将 s 转化为目标字符串的翻转次数。并取所有可能的最小值即可。

算法细节：我们假设位置 i 为当前字符 0 与 1 的分界线，也即 [0, i−1] 位置均为字符 0，[i+1, n]位置均为 1，而位置 i 是 0 还是 1 均可。

所以我们需要将 [0, i−1] 区间内的所有字符 1 进行翻转，也即我们需要提前维护一个前缀和数组，记录 [0, i−1] 区间内字符 1 的个数。同理，我们也需要一个数组，记录[i+1, n-1] 区间内字符 0 的个数。

```C%2B%2B
class Solution {
public:
    int minFlipsMonoIncr(string s) {
        int n = s.size();
        vector<int> cnt_0(n + 1), cnt_1(n + 1);
        for (int i = 0; i < n; i++) {
            // [0, i-1] 的 1 数量
            cnt_1[i + 1] = cnt_1[i] + (s[i] == '1');  // cnt_1[1:n]
        }
        for (int i = n; i > 0; i--) {
            // [i, n-1] 的 0 的数量
            cnt_0[i - 1] = cnt_0[i] + (s[i - 1] == '0');  // cnt_0[0:n-1]
        }
        int ans = n;
        for (int i = 0; i < n; i++) {  // i 位置为分界线，该位置是 0 或 1 无所谓
            // [0, i-1]的所有1翻转为0， [i+1, n-1]的所有0翻转为1
            // [0, i-1]的1在cnt_1[i-1]，[i+1, n-1]的0在cnt_0[i+1]，注意下标换一下⭐
            int cur = cnt_1[i] + cnt_0[i + 1];
            ans = min(ans, cur);
        }
        return ans;
    }
};
```

思路2：传统一点的递推

1. 确定dp数组以及下标的含义：

dp[i][0] 和 dp[i][1]分别表示下标i处的字符为0和1的情况下使得s[0..i]单调递增的最小翻转次数。

1. 确定递推公式：

- 如果s[i] == '1'，有`dp[i][0] = dp[i-1][0]`
- 如果s[i] == '0'，有`dp[i][1] = min(dp[i-1][0], dp[i-1][1]) + 1`

1. 初始状态：

- 如果 s[i] == '0'，即 dp[i][0] = 0
- 如果 s[i] == '1'，即 dp[i][1] = 1

等价于代码中的count的处理

1. 返回值：dp[i][0]和dp[i][1]中间的最小值

- > 代码中直接用dp变量进行记录最小反转次数

- > 注：上述只是为了方便理解用了dp[i],由于dp[i] 的值只和dp[i−1] 有关，所以可以进行状态压缩

```C%2B%2B
    int minFlipsMonoIncr(string s) {
        int dp = 0;
        if(s.size() == 1) return dp;
        int count = 0;
        if(s[0] == '1') count = 1;
        for(int i = 1; i < s.size(); i++) {
            if(s[i] == '1') count++;
            else dp = min(dp + 1, count);
        }
        return dp;
    }
```



#### [剑指 Offer II 091. 粉刷房子](https://leetcode.cn/problems/JEj789/)

- > 相邻的房子颜色不相同，所以要动态规划

- > 用dp[i][j]表示第i+1个房子粉刷颜色j时，前i+1个房子的最小花费。那么，min{dp[n - 1][0, 1, 2]}就是答案（把第n个粉刷成3种颜色中的一个，前n个的最小花费）

- > 相邻两个方块颜色不能相同。因此递推公式：

  - > `dp[i][0] = min(dp[i - 1][1], dp[i - 1][2]) + costs[i][0]`

  - > `dp[i][1] = min(dp[i - 1][0], dp[i - 1][2]) + costs[i][1]`

  - > `dp[i][2] = min(dp[i - 1][0], dp[i - 1][1]) + costs[i][2]`

> 如果允许修改costs数组，可直接用costs来代替dp，`costs[i][j] += min(costs[i - 1][xx])`

```Prolog
class Solution {
public:
    int minCost(vector<vector<int>>& cs) {
        int n = cs.size();
        for (int i = 1; i < n; i++) {
            cs[i][0] += min(cs[i - 1][1], cs[i - 1][2]);
            cs[i][1] += min(cs[i - 1][0], cs[i - 1][2]);
            cs[i][2] += min(cs[i - 1][0], cs[i - 1][1]);
        }
        return min(cs[n - 1][0], min(cs[n - 1][1], cs[n - 1][2]));
    }
};
```









## [(3)背包 DP](https://github.com/SharingSource/LogicStack-LeetCode/wiki/背包-DP)

> 三叶的の背包系列 🍭🍭🍭 ：见1995题解文末

无法复制加载中的内容

#### [1995. 统计特殊四元组](https://leetcode-cn.com/problems/count-special-quadruplets/)：暴力 / 哈希⭐ / 背包

![img](https://uestc.feishu.cn/space/api/box/stream/download/asynccode/?code=ZDg3OTE4MjFhMTQ3YTMyNzJkODI5OGFmNGNjM2U3MThfSFducmNuVW1pODF2YjEyMXhwQzBud3dEcnNzUWxsS3ZfVG9rZW46Ym94Y24xN1NwbndtVmd0WFhmWWdsd2ZUdFNwXzE2NTY0ODY2MTE6MTY1NjQ5MDIxMV9WNA)

> 和LC第一题有异曲同工之处。枚举左边两者和，枚举右边两者差，动态更新相同数目到答案。

> 另外同样可以采用背包动态规划思想，我们要**选三个**到背包里，维护不选的各个值的个数、选一个各个值的个数、选两个各个值的个数、选三个各个值的个数。

> 在遍历到每个数，统计选三个了的各值中该数的个数就是答案的一部分。

**法2.1：哈希，使用哈希表存储nums[d]**

```C%2B%2B
class Solution {
public:
    int countQuadruplets(vector<int>& nums) {
        int n = nums.size();
        int ans = 0;
        unordered_map<int, int> cnt;  // 使用哈希表存储nums[d]
        for(int c = n-2; c >= 2; --c){
            cnt[nums[c + 1]]++;
            for(int a = 0; a < c; ++a){
                for(int b = a + 1; b < c; ++b){
                    ans += cnt[nums[a] + nums[b] + nums[c]];  //⭐
                }
            }
        }
        return ans;
    }
};
```

**法2.2：哈希，作为两数之和的进阶版本，nums[a] + nums[b] = nums[d] - nums[c]**

引：运用两数之和的思想（python用Counter来当作哈希表！！）

```Python
class Solution:
    def countQuadruplets(self, nums: List[int]) -> int:
        l, ans = Counter(), 0
        for i in range(1, len(nums) - 2):
            # 到目前为止统计了所有0到i的两坐标和
            for j in range(i):
                l[nums[i] + nums[j]] += 1
            # 目前第三个坐标为i+1，枚举第四个坐标j的范围
            for j in range(i + 2, len(nums)):
                # 叠加以前统计的左半段和的结果，i+1作为第三个idx和j最多组成这么多
                ans += l[nums[j] - nums[i+1]]
        return ans
class Solution {
public:
    int countQuadruplets(vector<int>& nums) {
        int n = nums.size();
        unordered_map<int, int> cnt;
        int ans = 0;

        for (int b = n - 3; b >= 1; b--) {
            int c = b + 1;
            for (int d = c + 1; d < n; d++) {
                cnt[nums[d]-nums[c]]++;  //存哈希
            }
            for (int a = 0; a < b; a++) {
                ans += cnt[nums[a]+nums[b]];  //找哈希
            }
        }
        return ans;
    }
};
```

**法3：多维背包?**













## [(4)序列 DP](https://github.com/SharingSource/LogicStack-LeetCode/wiki/序列-DP)

无法复制加载中的内容

#### [472. 连接词](https://leetcode-cn.com/problems/concatenated-words/)：没做，困难

![img](https://uestc.feishu.cn/space/api/box/stream/download/asynccode/?code=M2NlYzRiMjljNTNlYWYxZThmMzg3MTU1ODZhMTBiZjdfT2VhQ2xLc1J2QjU1WVFJUTlYaFFodGc1YXFaOVVRSXBfVG9rZW46Ym94Y25JakZzZEZROUtJMDVJQ053Ukp1Y3FlXzE2NTY0ODY2MTE6MTY1NjQ5MDIxMV9WNA)















## [(5)区间 DP](https://github.com/SharingSource/LogicStack-LeetCode/wiki/区间-DP)

#### [730. 统计不同回文子序列](https://leetcode.cn/problems/count-different-palindromic-subsequences/)：枚举边缘字符

- > 枚举边缘字符的区间 DP 运用题

- > 这是一道困难题，真的比较难想出来

- > “通过从 s 中删除 0 个或多个字符来获得子序列。”

- > 与其说回文，更像是“轴对称”

![img](https://uestc.feishu.cn/space/api/box/stream/download/asynccode/?code=MTZkOWMzZjljYjhiMjNiZDJjNDc1NjE0MDgzMDMwNmZfcTl0M3U5dFlkdzBTUTJxT05NY1BESTZWeGQ1SGJDbkRfVG9rZW46Ym94Y25PNHhmM2RHNmtNT0c3ZGRFNzF2WHNlXzE2NTY0ODY2MTE6MTY1NjQ5MDIxMV9WNA)

![img](https://uestc.feishu.cn/space/api/box/stream/download/asynccode/?code=N2NhOWM1M2I5NWEzNjcxYzA4NDgxYzQwNGViN2EzOTVfdDZpRFBVcUpkZVVBRkpTUjlQMHdnTzhrTWVoVXFYUTZfVG9rZW46Ym94Y25DZHk0V2VEdlhCZ3lNcjRubHUzRmhiXzE2NTY0ODY2MTE6MTY1NjQ5MDIxMV9WNA)

**一个不错的讲解：**

由于长字符串会依赖短字符串的回文序列数量，所以我们可以采用动态规划来实现。

设**dp[i][j]**表示字符串**从i到j的回文序列个数**，我们可以将长字符串看作短字符串左右加上两个字符

于是我们有`s[i,j] = s[i] + s [i+1,j-1] + s[j]`，如："bccb" 可以看作 "cc"两边分别加上"b"，此时我们分情况进行讨论：

(1) 若s[i] == s[j]，相当于我们给s[i+1,j-1] 左右加上两个相同的字符，然后我们计算回文序列的个数

- ① s[i+1,j-1]中没有字符和s[i]相等（bcb+aa）

设有字符串"bcb"，则"bcb"的回文子序列是：b、c、bb、bcb

若两边加上相同的字符，相当于给"bcb"的回文子序列左右各加一个相同字符，仍然构成回文子序列。假设我们给"bcb"左右加一个字符"a"，则相当于给"bcb"的子序列都左右加一个字符可构成新的回文子序列。

![img](https://uestc.feishu.cn/space/api/box/stream/download/asynccode/?code=Mjg4MTA2ZTVlOGJkZTg0MDc4MTQ3ZjE2ZTJkOGMzNjlfT1R3NHg3UGo1bDBQRGVaM0pBQmZYQnprRDhBU1ZIRFFfVG9rZW46Ym94Y25yTDd1a3pNTkZHb1J1OHRQWEcxaWFoXzE2NTY0ODY2MTE6MTY1NjQ5MDIxMV9WNA)

再加上"a"(字符本身就是一个回文子序列)和"aa"(两个相同字符的回文子序列)

所以此时dp[i][j] = 2dp[i+1][j-1] + 2（本身的4个+新生成的4个+2个单独生成的）

- ② s[i+1,j-1]中有一个字符和s[i]相等（bcb+bb）

假设有一个字符相等，则之前已经记录了此单字符的回文子序列(只能加上"aa"，不能加"a")

所以此时dp[i][j] = 2dp[i+1][j-1] + 1（本身的4个+新生成的4个+1个单独生成的）

- ③ s[i+1,j-1]中有两个及以上字符和s[i]相等

若有两个及以上的字符,则我们需要找到其位置，并**删掉重复计算的回文子序列**，并且两个单独的之前也已经计算。

假设有字符串"dabcbad"，我们向两边加入字符"a"

则此时的"a"字符会和中间的"bcb"组成重复的回文子序列，因为之前已经有"a"和"bcb"组成回文子序列

![img](https://uestc.feishu.cn/space/api/box/stream/download/asynccode/?code=MmFmZTEyNjE1MmI5MDFhNDIyOTFhNDVjNGMyYjljYjBfMW5WT0dvTTJ4eXN1c29BWWRZTFc5OTFlNllYeEZDbzJfVG9rZW46Ym94Y25xMGJMVnM3UU55V1hReXo5eUttT0dkXzE2NTY0ODY2MTE6MTY1NjQ5MDIxMV9WNA)

![img](https://uestc.feishu.cn/space/api/box/stream/download/asynccode/?code=ZWRjM2UxYTM1M2FhMzNlZDE3Mzg1MWRhY2ViYjJkNDNfMkFrNzRXUUo2VkhJWm5iaUpPbTVJSU96VDY2WlhsN09fVG9rZW46Ym94Y254OVJrVUtxVDJQckVFeWNiaUEwUnJoXzE2NTY0ODY2MTE6MTY1NjQ5MDIxMV9WNA)

(2) 若s[i] != s[j]，则我们给之前任何一个回文子序列左右加上s[i]和s[j]都不能组成回文子序列，只能单独计算

![img](https://uestc.feishu.cn/space/api/box/stream/download/asynccode/?code=OWM4NDhiZWY5NmIwOWU5ZmFkNmZjMDgzZGU4Y2ZjODBfOUdlbVhZSDlRcUVLNnEwaXJuNVo3eGFidnRHUUxIRHdfVG9rZW46Ym94Y241YmJaTVNXeEF6Sjg4cnRPb3FBVTVlXzE2NTY0ODY2MTE6MTY1NjQ5MDIxMV9WNA)

综上所述，状态转移方程为：

![img](https://uestc.feishu.cn/space/api/box/stream/download/asynccode/?code=NTYyYzhjYzhiNWNiMjI5NGZmOGNmNTY1NTA1YzM3ZGNfcWg2ZjFTOWhhZlVLM292S2huWUU5MDFDYU5rSHNsQktfVG9rZW46Ym94Y25uMTlDSmVqazg5ak9IY2NQbGNCZlJjXzE2NTY0ODY2MTE6MTY1NjQ5MDIxMV9WNA)









## [(6)状压 DP](https://github.com/SharingSource/LogicStack-LeetCode/wiki/状压-DP)

## [(7)状态机 DP](https://github.com/SharingSource/LogicStack-LeetCode/wiki/状态机-DP)

## [(8)数位 DP](https://github.com/SharingSource/LogicStack-LeetCode/wiki/数位-DP)









# 贪心 ⭐

#### [435. 无重叠区间](https://leetcode-cn.com/problems/non-overlapping-intervals/)：区间贪心

![img](https://uestc.feishu.cn/space/api/box/stream/download/asynccode/?code=MjI3Njc3ZTIxNzI5YjM2YjNjMTY3YWM2ZjFjYWIxYjdfMEcxWDhCWmc0d3ZQdVppaDBlT2cwU0VLZkFPbmU0OUpfVG9rZW46Ym94Y25EckhEbnpwZTVMWjNCbG1GR1ZiZjVkXzE2NTY0ODY2MTE6MTY1NjQ5MDIxMV9WNA)

要找移除得最小数量，

**法1：按照右边界排序，则****从左向右遍历，优先选右边界小的**

```C%2B%2B
class Solution {
public:
    // 按照区间右边界<排序，自己写一个排序规则！
    static bool cmp (const vector<int>& a, const vector<int>& b) {
        return a[1] < b[1];
    }
    int eraseOverlapIntervals(vector<vector<int>>& intervals) {
        if (intervals.size() == 0) 
            return 0;
        
        sort(intervals.begin(), intervals.end(), cmp);
        // 从左向右遍历，优先选右边界小的
        int cnt = 1;  // 记录非交叉区间的个数
        int end = intervals[0][1];  // 第一个的右边界
        // 从下一个开始遍历
        for (int i = 1; i < intervals.size(); i++) {
            // 如果左边不符合条件，下一个
            // 如果左边界符合条件：符合，更新end
            if (intervals[i][0] >= end) {
                end = intervals[i][1];
                cnt++;
            }
        }
        return intervals.size() - cnt;
    }
};
class Solution:
    def eraseOverlapIntervals(self, intervals: List[List[int]]) -> int:
        n = len(intervals)
        if n == 0: return 0
        intervals.sort(key=lambda x: x[1]) #按右边界排序
        end = intervals[0][1] #最左元素的右边界作为基准
        cnt = 1 

        #记录非交叉区间的个数 局部最优：从左向右(优先考量右边界小的区间) 
        for i in range(1,n):
            if intervals[i][0] >= end: #不交叉
                cnt += 1 
                end = intervals[i][1]            
        return n - cnt
```



**法2：按照左边界排序，则****从右向左遍历，优先选左边界大的**

```Python
class Solution:
    def eraseOverlapIntervals(self, intervals: List[List[int]]) -> int:
        n = len(intervals)
        if n == 0: return 0

        intervals.sort(key=lambda x: x[0]) # O(nlogn) 按左边界排序
        leftend = intervals[n-1][0] # 选取左边界最大的元素作为基准
        cnt = 1 

        for i in range(n-2,-1,-1):
            if intervals[i][1] <= leftend: 
                cnt += 1
                leftend = intervals[i][0]

        return n - cnt
```

**法3：动态规划**

![img](https://uestc.feishu.cn/space/api/box/stream/download/asynccode/?code=NWQ3ODRkNmU0ODE4ZjcwYTNlMzE5ZDQ0NjliZGYwMWZfZmthSmNkaUpycUl4ck41ZUw4UTBkd0FhUVh4cmxRdm1fVG9rZW46Ym94Y25ZQXpDbTl0ZUlQTXF2R1g2VWpmZ3FnXzE2NTY0ODY2MTE6MTY1NjQ5MDIxMV9WNA)



#### [462. 最少移动次数使数组元素相等 II](https://leetcode.cn/problems/minimum-moves-to-equal-array-elements-ii/)：中位数

![img](https://uestc.feishu.cn/space/api/box/stream/download/asynccode/?code=MmM5ZjY4ODhhMjM5MTM5M2VmM2E4Zjk3NDk1YzMzMmFfckFjMmFNZm1CZWEzTXpxOERWT21vbFY1bm5vWFJDQ1JfVG9rZW46Ym94Y241eUZKVjNnb2JjR25FSWZOUWI0OHpoXzE2NTY0ODY2MTE6MTY1NjQ5MDIxMV9WNA)

> 准确来说没有用到贪心，

> 设从小到大的数列{x1,x2,...,xn}，设x是从x1到xn与其绝对差之和最小的数，显然x∈[x1,xn]

> ∵x1，xn与它们之间的任意一点的距离之和都相等，且都等于xn-x1，因此接下来可以不考虑x1与xn

> 而又∵中位数是离数列中最中间那个数距离最小的那个

> ∴**用中位数来**...

```C%2B%2B
class Solution {
public:
    int minMoves2(vector<int>& nums) {
        sort(nums.begin(), nums.end());
        int n = nums.size(), mid = nums[n / 2];
        int ans = 0;
        for (int i = 0; i < n; ++i) {
            ans += abs(nums[i] - mid);
        }
        return ans;
    }
};
```



#### [553. 最优除法](https://leetcode-cn.com/problems/optimal-division/)：数学+贪心

![img](https://uestc.feishu.cn/space/api/box/stream/download/asynccode/?code=ZTU2ZmRiOGVmMDg1NDAxN2RlYWY3ODYwNGNiNWRiNmJfRkNlRHVQeXZ1ckZhTER2M2pnRVBCNmdSQTJNT2tKeGJfVG9rZW46Ym94Y25JS0Jjc01RcUlKVXdGYzFLTDB2R3lnXzE2NTY0ODY2MTE6MTY1NjQ5MDIxMV9WNA)

**思路：**不管怎么添加括号，第一个数字永远是唯一的分子，而第二个数字永远是分母的一部分。

分子是不能变大的，要想尽可能大，只能从分母入手，把分母变得尽可能小。

而这显然只需要让第二个数字尽可能地除后面越多的数越好（因为都是正整数）。

【三叶】の题解：

![img](https://uestc.feishu.cn/space/api/box/stream/download/asynccode/?code=MTEwYzQzMTAzMzM3ZThiYjg3MzM1NjA2MTNhZWU0ZDdfRjdLUTFFbk9BNnhibXlPaG9peVI3SmIyOWlyV1pnTFRfVG9rZW46Ym94Y25lb0ZZeXhUWXpqNG5yZENNSmtJV0ZmXzE2NTY0ODY2MTE6MTY1NjQ5MDIxMV9WNA)

由此：只要nums长度>2，把后面的统一加上括号

```C%2B%2B
class Solution {
public:
    string optimalDivision(vector<int>& nums) {
        int n = nums.size();
        string ans = "";

        if (n == 1) return to_string(nums[0]);
        if (n == 2) return to_string(nums[0]) + '/' + to_string(nums[1]);
        else {
            ans += to_string(nums[0]) + "/(";
            for (int i = 1; i < n; ++i) {
                ans += to_string(nums[i]) + '/';
            }
            ans.pop_back();
            ans.push_back(')');
        }
        return ans;
    }
};
```









#### [807. 保持城市天际线](https://leetcode-cn.com/problems/max-increase-to-keep-city-skyline/)：python官方写法？

![img](https://uestc.feishu.cn/space/api/box/stream/download/asynccode/?code=MWFmODRiMmI0NmRmYWIyZmU5ZGZlZTU1YzA0ZDJhM2FfNkJvbjNZRnFScTNpYWVsMlo5N2licU9oSU1hekxLa2dfVG9rZW46Ym94Y25RT2I1SXBjOXFhWHpNTkNjeGVkZ3NoXzE2NTY0ODY2MTE6MTY1NjQ5MDIxMV9WNA)

![img](https://uestc.feishu.cn/space/api/box/stream/download/asynccode/?code=NDdlOTA1NzI0YzQ5MDcwYjgyZjM4NGIxZmI2YTM4YjVfeHM5Q3V4aWFkZjRWWFVhMXg1QTlhTjhxSnNOTHFqb1hfVG9rZW46Ym94Y25MRHZvRVhZZlJQdWFlZEVvUWFrSnRoXzE2NTY0ODY2MTE6MTY1NjQ5MDIxMV9WNA)

![img](https://uestc.feishu.cn/space/api/box/stream/download/asynccode/?code=N2JjNDRjNWYwNjQzYjc5MDQxMWJmZTA1NzJhN2JlN2FfRWJIZXNhc2MxRk5EMmJIUU84NEFkS3ltNTVDZkJDNWxfVG9rZW46Ym94Y25nZlA2SnZXZ0RoWkx3N1U2Z2tJTDdiXzE2NTY0ODY2MTE6MTY1NjQ5MDIxMV9WNA)

C++的写法很正常

```C%2B%2B
class Solution {
public:
    // 变为所在行列，最大高度里的最小者
    int maxIncreaseKeepingSkyline(vector<vector<int>>& grid) {
        int n = grid.size(); //n行，其实也是n列
        vector<int> rowMax(n);
        vector<int> colMax(n);
        for(int i = 0; i < n; ++i){
            for(int j = 0; j < n; ++j){
                rowMax[i] = max(rowMax[i], grid[i][j]);
                colMax[j] = max(colMax[j], grid[i][j]);
            }
        }
        int ans = 0; // 最大高度增量总和
        // 遍历整个矩阵的第i行，第j列
        for (int i = 0; i < n; i++){
            for (int j = 0; j < n; j++){
                ans += min(rowMax[i], colMax[j]) - grid[i][j];
            }
        }
        return ans;
    }
};
class Solution:
    def maxIncreaseKeepingSkyline(self, grid: List[List[int]]) -> int:
        rowMax = list(map(max, grid))
        colMax = list(map(max, zip(*grid)))
        return sum(min(rowMax[i], colMax[j]) - h for i, row in enumerate(grid) for j, h in enumerate(row))
```



#### [630. 课程表 III](https://leetcode-cn.com/problems/course-schedule-iii/)：注意贪心的思想和实现 ⭐

![img](https://uestc.feishu.cn/space/api/box/stream/download/asynccode/?code=OTA1NDQ5MTFiZWZkNjY3MDAxMGNlZDRiZDFlMzU5NGZfSGZpMlViOEZnTmYzdUJUMFpheTZJQzI5YndFUGVKbVVfVG9rZW46Ym94Y25TdHk3ZWdmVDVORXN3WUNBZmlBNWhjXzE2NTY0ODY2MTE6MTY1NjQ5MDIxMV9WNA)

**贪心**：就是默认前面已经是最优的前提下，继续考虑

要考虑两个一级条件：

- 1.趁着ddl前，当前能修则修
- 2.在都能修的都修了（这个不能再修了）的前提下，看能否把持续时间长的某一个替换出来：
  - 把曾经duration长的换成新的，反正数量不会再变了

```C%2B%2B
class Solution {
public:
    int scheduleCourse(vector<vector<int>>& courses) {
        sort(courses.begin(), courses.end(), [](const auto& a, const auto& b){return a[1] < b [1];});

        priority_queue<int> q;
        int t_now = 0; // 修完某门课后的时间，也是下一门课的开始时间
        for (auto course: courses) {
            if (course[1]-course[0] >= t_now) {
                // 可以修
                t_now += course[0];
                q.push(course[0]);
                continue;
            }
            if (!q.empty() && q.top() > course[0]) {
                // 在当前课程可以修的前提下，进一步看duration最长的那个是否被修了
                t_now -= q.top();
                t_now += course[0];
                q.pop();
                q.push(course[0]);
            }        
        }
        return q.size();
    }
};
```

python的实现注意语法，

```Python
class Solution:
    def scheduleCourse(self, courses: List[List[int]]) -> int:
        courses.sort(key=lambda c: c[1])

        q = list()
        t_now = 0  # 优先队列中所有课程的总时间

        for ti, di in courses:
            if t_now + ti <= di:
                t_now += ti
                # Python 默认是小根堆
                heapq.heappush(q, -ti)
            elif q and -q[0] > ti:
                t_now -= -q[0] - ti
                heapq.heappop(q)
                heapq.heappush(q, -ti)

        return len(q)
```



#### [942. 增减字符串匹配](https://leetcode.cn/problems/di-string-match/)：构造折线

> 直接从0开始构造，然后整体上下移动

```C%2B%2B
vector<int> diStringMatch(string s) {
    int n = s.size();
    int min = 0, max = 0;
    vector<int> ans(n + 1, 0);
    for (int i = 0; i < n; i++) {
        if (s[i] == 'I')
            ans[i + 1] = ++max;
        else
            ans[i + 1] = --min;
    }
    for (int &a : ans) a -= min;  //必须加上引用，不然vector没有改
    return ans;
}
```

![img](https://uestc.feishu.cn/space/api/box/stream/download/asynccode/?code=ZDQzMTllY2ZiY2M0ZjhmYTcxODk0ZjdiNmZmNzcyNjBfZXprdTlVUnliQ0c5TTFFaHRsR2ppb0xtdlhRd2d1TzVfVG9rZW46Ym94Y244S2dYTnM1SUVsbk9YeDVjNEduV0ZmXzE2NTY0ODY2MTE6MTY1NjQ5MDIxMV9WNA)



#### [1405. 最长快乐字符串](https://leetcode-cn.com/problems/longest-happy-string/)：❗优先级队列 pair

![img](https://uestc.feishu.cn/space/api/box/stream/download/asynccode/?code=ODk0NmNkYTVmODQ3MDc3Njc4NjVmODg0NzlhNDg2OTVfSEptY1N2NEVWbk9yR1VDMzJPU0RmOXJvaTdTbXZsVWNfVG9rZW46Ym94Y25IREp4SzVCU3R4MzhtckdNMmo5aFNiXzE2NTY0ODY2MTE6MTY1NjQ5MDIxMV9WNA)

（好在只有3个字符），

**优先使用剩余数量最多的字符**

来自【三叶】の题解：

![img](https://uestc.feishu.cn/space/api/box/stream/download/asynccode/?code=MzRkYjQ0OTk4NjMyZTZlZGU3YWQwMGYyNjcyZWFlNzVfNUtkV0ZtWENJUGJNWmFlblhhaVFWUVlvNElDbDhpdU9fVG9rZW46Ym94Y25vTmxiN1hpRlQ0eDd6TFE5NG9sOEdmXzE2NTY0ODY2MTE6MTY1NjQ5MDIxMV9WNA)

按照这个思路，写出如下解法：

```C%2B%2B
class Solution {
public:
    // 根本思想：贪心！！
    // 用优先队列，这样就“自动地”保证了：每次取出字符都要进行判断数量 ==> 大根堆⭐
    // 每次取堆顶元素（剩余数量最多的元素）
    string longestDiverseString(int a, int b, int c) {
        priority_queue<pair<int, int>, vector<pair<int, int>>, cmp> q;
        if (a > 0) q.push({0, a});  // a,b,c分别是它们对应的数量，0,1,2用来表示编号
        if (b > 0) q.push({1, b});
        if (c > 0) q.push({2, c});
        string ans;
        while (!q.empty()) {
            pair<int, int> cur = q.top();
            q.pop();
            int n = ans.size();
            if (n >= 2 && ans[n-1]-'a'==cur.first && ans[n-2]-'a'==cur.first) {  // 连续两个和当前最多的相同
                if (q.empty()) break;  // 如果q中无其他字符pair，则退出循环
                pair<int, int> next = q.top();
                q.pop();
                ans.push_back('a'+next.first);  // 把第二多的字符添加进ans
                // 再看第二多的字符是否还有剩余？还有剩余则更新数量重新入堆
                if (--next.second != 0) q.push(next);  // 只有next变化了，所以只更新它即可
                q.push(cur);  // 同时将此前取的最多字符pair也重新入堆⭐
            }
            else {
                // 不违反连续三个字符相同，则说明当前字符能够追加到当前答案尾部
                ans.push_back('a'+cur.first);
                // 若追加后还有字符剩余，则更新剩余数量重新入堆
                if (--cur.second != 0) q.push(cur);
            }
        }
        return ans;
    }


    struct cmp {
        template <typename T, typename U>
        bool operator()(T const &left, U const &right) {
            if (left.second < right.second)
                return true;
            return false;
        }
    };

};
```

升序队列，小根堆：`priority_queue <int,vector<int>,greater<int> > p;`

降序队列，大根堆：`priority_queue <int,vector<int>,less<int> >q;`

对于基础数据类型，默认是大顶堆：`priority_queue<int> r;    //等同于 priority_queue<int, vector<int>, less<int> > r;`

- > 自定义一个优先队列的排序方法：

- > 因为**pair的优先级队列**都是**先first升序，再second升序**

- > https://blog.csdn.net/u014257954/article/details/78623215

- > https://blog.csdn.net/ruohua3kou/article/details/97070552?spm=1001.2014.3001.5501

**其实还能写得简单一些：**

```C%2B%2B
class Solution {
public:
    // 根本思想：贪心！！
    // 用优先队列，这样就“自动地”保证了：每次取出字符都要进行判断数量 ==> 大根堆⭐
    // 每次取堆顶元素（剩余数量最多的元素）
    string longestDiverseString(int a, int b, int c) {
        priority_queue<pair<int, int>> q;
        if (a > 0) q.push({a, 0});  // a,b,c分别是它们对应的数量，0,1,2用来表示编号
        if (b > 0) q.push({b, 1});
        if (c > 0) q.push({c, 2});
        string ans;
        while (!q.empty()) {
            pair<int, int> cur = q.top();
            q.pop();
            int n = ans.size();
            if (n >= 2 && ans[n-1]-'a'==cur.second && ans[n-2]-'a'==cur.second) {  // 连续两个和当前最多的相同
                if (q.empty()) break;  // 如果q中无其他字符pair，则退出循环
                pair<int, int> next = q.top();
                q.pop();
                ans.push_back('a'+next.second);  // 把第二多的字符添加进ans
                // 再看第二多的字符是否还有剩余？还有剩余则更新数量重新入堆
                if (--next.first != 0) q.push(next);  //只有next变化了，所以只更新它即可
                q.push(cur);  // 同时将此前取的最多字符pair也重新入堆⭐
            }
            else {
                // 不违反连续三个字符相同，则说明当前字符能够追加到当前答案尾部
                ans.push_back('a'+cur.second);
                // 若追加后还有字符剩余，则更新剩余数量重新入堆
                if (--cur.first != 0) q.push(cur);
            }
        }
        return ans;
    }
};
```

**python也有一种朴素一点的写法：**

```Python
class Solution:
    def longestDiverseString(self, a: int, b: int, c: int) -> str:
        # 字符不需要用完
        stack = []
        h = [] # 
        if a: h.append([a,"a"])
        if b: h.append([b,"b"])      
        if c: h.append([c,"c"])
            
        h.sort()
        def check(ele): 
            if len(stack) >= 2 and stack[-1] == ele and stack[-2] == ele:
                return False 
            return True 
        
        while h:
            times,ele = h.pop()
            if check(ele):
                stack.append(ele)
                times -= 1
                if times != 0:
                    h.append([times,ele])
                    h.sort() # 暴力的点
            else:
                if h:
                    times2,ele2 = h.pop()
                    stack.append(ele2)
                    times2 -= 1
                    if times2 != 0:
                        h.append([times2,ele2])
                    h.append([times,ele])
                    h.sort() # 暴力的点
                else:
                    break

        return "".join(stack)
```





#### [1414. 和为 K 的最少斐波那契数字数目](https://leetcode-cn.com/problems/find-the-minimum-number-of-fibonacci-numbers-whose-sum-is-k/)：分治？递归？硬做？

一个思想就是：首先找到所有**不超过k**的斐波那契数字，然后每次贪心地选取不超过k的最大斐波那契数字，将k减去该斐波那契数字，重复该操作直到k变为0，此时选取的斐波那契数字满足和为k且数目最少。

![img](https://uestc.feishu.cn/space/api/box/stream/download/asynccode/?code=ZmFiZDUzNGFiNDM3NGZmYWFmOWUzODM2MWE0ODc3ZDVfUlhjUFRjd1pPWVdmaG14SzJhUk1mb2VrQ2RqMVlGbVhfVG9rZW46Ym94Y24yemNueThGMVZ4bkp4T2pMbmRoMDFmXzE2NTY0ODY2MTE6MTY1NjQ5MDIxMV9WNA)

**一种解法：贪心**

```C%2B%2B
class Solution {
public:
    int findMinFibonacciNumbers(int k) {
        int a = 1, b = 1;
        int ans = 0;
        // 找到比 k 小的最大的 b
        while(b <= k){
            int c = a + b;
            a = b, b = c;
        }
        while(k != 0){
            if(k >= b){
                k -= b;
                ans++;
            }
            int c = b - a;
            b = a, a = c;
        }
        return ans;
    }
};
```

**另一种解法：分治+递归**

```Java
class Solution {
public:
    int findMinFibonacciNumbers(int k) {
        if(k == 0) 
            return 0;
        int a = 1, b = 1;
        // 找到比k小的最大的b
        while(b <= k){
            int c = a + b;
            a = b, b = c;
        }
        return 1 + findMinFibonacciNumbers(k-a);
    }
};
class Solution:
    def findMinFibonacciNumbers(self, k: int) -> int:
        if not k:
            return 0
        f1, f2 = 1, 1
        while f2 <= k:
            f1, f2 = f2, f1 + f2
        return 1 + self.findMinFibonacciNumbers(k - f1)
```



#### [1705. 吃苹果的最大数目](https://leetcode-cn.com/problems/maximum-number-of-eaten-apples/)：贪心 优先队列/map

贪心：优先吃快要过期的🍎，设置一个苹果堆来存放

![img](https://uestc.feishu.cn/space/api/box/stream/download/asynccode/?code=YjE1N2QyMzhkZDA3YjE4ZmJjZDMyZjEyMTljODllMWVfMDNxVG1nUkZRdGw3THRIbmRqU05CTXpGSDRCTmgwUjFfVG9rZW46Ym94Y25oRVVEVmlQNlRVMGFSNGlmNk8yVmtmXzE2NTY0ODY2MTE6MTY1NjQ5MDIxMV9WNA)

```C%2B%2B
class Solution {
public:
    int eatenApples(vector<int>& apples, vector<int>& days) {
        int ans = 0;
        int d = 0, alldays = days.size();
        // 升序的一个苹果堆，pair(能吃到第几天,苹果数量)
        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> q;
        while (d < alldays || !q.empty()) {
            if (d < alldays) 
                q.push(make_pair(days[d]+d-1, apples[d]));
            auto apple = q.top();
            // 跳过所有已经过期的苹果
            while (apple.first < d) { //对过期的苹果的处理
                q.pop();
                if (q.size() == 0) break;
                apple = q.top();
            }
            // 如果当天没有可以吃的苹果了，等一天
            if (q.size() == 0) { 
                d++; 
                continue; 
            }
            // 如果有可以吃的苹果；我们要把这一天过期的苹果数量减1
            if (apple.second > 0) {
                q.pop();
                apple.second--;
                // 如果苹果还有剩余，我们把它放回堆中
                if (apple.second > 0) q.push(apple);
                ans++;

                // apple.second--;
                // ans++;
                // if(apple.second = 0) q.pop();
                // 这种方法是不对的！等于说队里面的没修改成功！
            }
            d++;
        }
        return ans;
    }
};
```

**另一种解法：使用map⭐**

由于TreeMap可以直接在过期日期上关联苹果数量；所以代码会简单的多。而我们只需要将取堆顶元素的操作换成取map第一个元素的操作即可。 

底层是红黑树；所有操作也是O(logn)的时间复杂度。

```C%2B%2B
class Solution {
public:
    int eatenApples(vector<int>& apples, vector<int>& days) {
        int ans = 0;
        int d = 0;
        // 提高效率使用map
        map<int, int> m; // (expire, cnt)
        while (d < days.size() || !m.empty()) {
            if (d < days.size()) 
                m[days[d] + d - 1] += apples[d];           
            // 尝试从map中取出一个最接近过期但是没有过期的苹果
            while(!m.empty()) {
                if (m.begin()->first < d || m.begin()->second == 0) 
                    m.erase(m.begin()->first);
                else {
                    // 如果找到了 我们就吃掉它
                    ans++;
                    m.begin()->second--;  // 苹果数要减1
                    break;
                }
            }
            d++;
        }
        return ans;
    }
};
```

# 



# 脑筋急转弯

#### [419. 甲板上的战舰](https://leetcode-cn.com/problems/battleships-in-a-board/)：遍历地扫描

![img](https://uestc.feishu.cn/space/api/box/stream/download/asynccode/?code=MjAzMmE5OTBmOTkwYTRiOTg5YTBkOWVkMzAzNmVkM2JfR3JteThMbXBkRDF0NGw3M21kUGg4V0J6Q1ZMZXJHRFVfVG9rZW46Ym94Y25tZk0zSW5CTnVCWVVCQVl0UGtEZlpkXzE2NTY0ODY2MTE6MTY1NjQ5MDIxMV9WNA)

方法二可以节省时间复杂度





# 区间求和

## (1)线段树

#### [729. 我的日程安排表 I](https://leetcode.cn/problems/my-calendar-i/)

不冲突加入日程返回true，冲突不加入日程返回false

法1：可以简单模拟

```C%2B%2B
class MyCalendar {
public:
    vector<pair<int, int>> calen;
    MyCalendar() {}
    
    bool book(int start, int end) {
        for (auto [x, y] : calen) {
            if (x < end && y > start) return false;
        }
        calen.emplace_back(make_pair(start, end));
        return true;
    }
};
/**
 * Your MyCalendar object will be instantiated and called as such:
 * MyCalendar* obj = new MyCalendar();
 * bool param_1 = obj->book(start,end);
 */
```

> `push_back()`也是可以的





#### [731. 我的日程安排表 II](https://leetcode.cn/problems/my-calendar-ii/)



#### [732. 我的日程安排表 III](https://leetcode.cn/problems/my-calendar-iii/)

法1：硬做

```C%2B%2B
class MyCalendarThree {
public:
    vector<pair<int, int>> calen;
    MyCalendarThree() {}
    static bool cmp(pair<int, int>& a, pair<int, int>& b) {
        return a.first < b.first;
    }
    int book(int start, int end) {
        calen.push_back(pair{start, end});
        sort(calen.begin(), calen.end(), cmp);
        int ans = 1, cnt = 0;
        priority_queue<int, vector<int>, greater<int>> q;  // 小根堆，升序
        for (auto c : calen) {
            q.push(c.second);
            cnt++;
            while (!q.empty() && q.top() <= c.first) {
                q.pop();
                cnt--;
            }
            ans = max(ans, cnt);
        }
        return ans;
    }
};
```

- > `static bool cmp(...)`必须加上static关键字



法2：线段树

法3：珂朵莉树

```C%2B%2B
struct node {
    int l, r;
    mutable int v;
    node(int l, int r = 0, int v = 0) : l(l), r(r), v(v) {}
    bool operator < (const node& t) const {
        return l < t.l;
    }
};
class MyCalendarThree {
public:
    set<node> s;
    int mx = 0;
    auto split(int pos) {
        auto it = s.lower_bound(pos);
        if(it != s.end() && it->l == pos) return it;
        --it;
        int l = it->l, r = it->r, v = it->v;
        s.erase(it);
        s.insert(node(l, pos - 1, v));
        return s.insert(node(pos, r, v)).first;
    }
    int add(int l, int r) {
        auto right = split(r), left = split(l);
        for(auto itl = left;itl != right;itl++) {
            ++itl->v;
            mx = max(itl->v, mx);
        }
        return mx;
    }
    MyCalendarThree() {
        s.clear();
        mx = 0;
        s.insert(node(0, 1e9, 0));
    }
    
    int book(int start, int end) {
        return add(start, end);
    }
};
/**
 * Your MyCalendarThree object will be instantiated and called as such:
 * MyCalendarThree* obj = new MyCalendarThree();
 * int param_1 = obj->book(start,end);
 */
```









# 博弈论



#### [464. 我能赢吗](https://leetcode.cn/problems/can-i-win/)：博弈论 dp

题意：m个数累加，看谁先超过t

- > **二维博弈论 DP**

- > **记忆化递归**，就是保存已经知道的状态和结果，下一次遇到同样的参数就不用重新计算了

- > BitMap的再次使用

```C%2B%2B
class Solution {
public:
    int f[1 << 20] = {0};  // state下当前玩家能否获胜，1能，-1不能
    bool dfs(int state, int sum, int m, int t) {
        if (f[state] != 0) return f[state] == 1 ? true : false;  // 状态记录下来
        for (int i = 0; i < m; i++) {
            if (((state >> i) & 1) == 1) continue;  // i被用过了
            if (sum + i + 1 >= t) {
                f[state] = 1;
                return true;
            }
            if (dfs((state | (1 << i)), sum + i + 1, m, t) == false) {  // 当前玩家选择i判断对方会输
                f[state] = 1;
                return true;
            }
        }
        f[state] = -1;
        return false;
    }
    bool canIWin(int m, int t) {
        if (m >= t) return true;
        if ((m + 1) * m / 2 < t) return false;
        return dfs(0, 0, m, t);
    }
};
```







#### [1728. 猫和老鼠 II](https://leetcode.cn/problems/cat-and-mouse-ii/)：记忆化搜索 dp

> **困难题：**记忆化搜索解决博弈类问题 ｜ 双方永远选择最有利自己的情况

**解题思路**

> 这种完全信息的博弈类游戏中，双方中必有一方有必不败策略。 Zermelo's theorem（策梅洛定理）

而去寻找最优策略最简单的做法就是进行**搜索**；而这种搜索要建立在双方都试图寻找最优解的基础上；也就是如果一方在某一步可以获得胜利，则他一定会选择可以获胜的下法。

我们在这种策略下，按照奇偶轮次逐一判断每个局面的情况即可。为了避免对同一局面的重复搜索；我们可以采用记忆化数组去记录每个局面的赢家是谁；每个“局面“就是一种状态；由猫鼠双方的位置+当前的轮次所决定。

搜索终点就是胜利确定的局面包括以下几种：

- m == c 说明猫抓住了老鼠，返回1
- m == f 说明猫先找到食物，返回1
- m == f 说明老鼠先找到食物；返回2

step > N 步长超过某个阈值，说明老鼠无法及时找到食物；返回1

在老鼠的轮次，如果移动一次有一个局面可以让老鼠获得胜利，则当前局面应该被标记为老鼠获胜的局面。

在猫的轮次，如果一动一次有一个局面可以让猫获得胜利，则当前局面应该被标记为猫获胜的局面。

显然，由于步数有上限，游戏一定有胜负；我们对每个局面进行搜索，理所应当可以确定当前局面的获胜者是谁。

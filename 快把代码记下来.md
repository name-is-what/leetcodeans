快把代码记下来

# 一、模拟

|      |      |      |
| ---- | ---- | ---- |
|      |      |      |
|      |      |      |
|      |      |      |

题目题解难度推荐指数[1. 两数之和](https://leetcode-cn.com/problems/two-sum/)[LeetCode 题解链接](https://leetcode-cn.com/problems/two-sum/solution/po-su-jie-fa-ha-xi-biao-jie-fa-by-ac_oie-yf7o/)简单✔🤩🤩🤩🤩🤩[2. 两数相加](https://leetcode-cn.com/problems/add-two-numbers/)[LeetCode 题解链接](https://leetcode-cn.com/problems/add-two-numbers/solution/po-su-jie-fa-shao-bing-ji-qiao-by-ac_oie-etln/)中等✔🤩🤩🤩🤩🤩[5. 最长回文子串](https://leetcode-cn.com/problems/longest-palindromic-substring/)[LeetCode 题解链接](https://leetcode-cn.com/problems/longest-palindromic-substring/solution/shua-chuan-lc-po-su-jie-fa-manacher-suan-i2px/)中等❗🤩🤩🤩🤩🤩[6. Z 字形变换](https://leetcode-cn.com/problems/zigzag-conversion/)[LeetCode 题解链接](https://leetcode-cn.com/problems/zigzag-conversion/solution/shua-chuan-lc-zhi-guan-gui-lu-jie-fa-shu-8226/)中等🤩🤩🤩[7. 整数反转](https://leetcode-cn.com/problems/reverse-integer/)[LeetCode 题解链接](https://leetcode-cn.com/problems/reverse-integer/solution/shua-chuan-lc-bu-wan-mei-jie-fa-wan-mei-919rd/)简单🤩🤩🤩[8. 字符串转换整数 (atoi)](https://leetcode-cn.com/problems/string-to-integer-atoi/)[LeetCode 题解链接](https://leetcode-cn.com/problems/string-to-integer-atoi/solution/shua-chuan-lc-jian-ji-jie-fa-by-ac_oier-69tp/)中等🤩🤩🤩[12. 整数转罗马数字](https://leetcode-cn.com/problems/integer-to-roman/)[LeetCode 题解链接](https://leetcode-cn.com/problems/integer-to-roman/solution/shua-chuan-lc-tan-xin-jie-fa-by-ac_oier-5kbw/)中等🤩🤩[13. 罗马数字转整数](https://leetcode-cn.com/problems/roman-to-integer/)[LeetCode 题解链接](https://leetcode-cn.com/problems/roman-to-integer/solution/shua-chuan-lc-ha-xi-biao-by-ac_oier-mooy/)简单🤩🤩[14. 最长公共前缀](https://leetcode-cn.com/problems/longest-common-prefix/)[LeetCode 题解链接](https://leetcode-cn.com/problems/longest-common-prefix/solution/shua-chuan-lc-die-dai-mo-ni-by-ac_oier-8t4q/)简单🤩🤩🤩🤩[31. 下一个排列](https://leetcode-cn.com/problems/next-permutation/)[LeetCode 题解链接](https://leetcode-cn.com/problems/next-permutation/solution/miao-dong-xi-lie-100-cong-xia-yi-ge-pai-gog8j/)中等🤩🤩🤩[38. 外观数列](https://leetcode-cn.com/problems/count-and-say/)[LeetCode 题解链接](https://leetcode-cn.com/problems/count-and-say/solution/shua-chuan-lc-100-mo-ni-ti-shi-yong-shao-w8jl/)简单🤩🤩[43. 字符串相乘](https://leetcode-cn.com/problems/multiply-strings/)[LeetCode 题解链接](https://leetcode-cn.com/problems/multiply-strings/solution/zhi-yao-ni-hui-shou-suan-cheng-fa-zhe-ti-ainl/)中等🤩🤩🤩🤩[58. 最后一个单词的长度](https://leetcode-cn.com/problems/length-of-last-word/)[LeetCode 题解链接](https://leetcode-cn.com/problems/length-of-last-word/solution/gong-shui-san-xie-jian-dan-zi-fu-chuan-m-tt6t/)中等🤩🤩🤩🤩[59. 螺旋矩阵 II](https://leetcode-cn.com/problems/spiral-matrix-ii/)[LeetCode 题解链接](https://leetcode-cn.com/problems/spiral-matrix-ii/solution/yi-ti-shuang-jie-xiang-jie-xing-zhuang-j-24x8/)中等🤩🤩🤩🤩[65. 有效数字](https://leetcode-cn.com/problems/valid-number/)[LeetCode 题解链接](https://leetcode-cn.com/problems/valid-number/solution/gong-shui-san-xie-zi-fu-chuan-mo-ni-by-a-7cgc/)困难🤩🤩🤩[66. 加一](https://leetcode-cn.com/problems/plus-one/)[LeetCode 题解链接](https://leetcode-cn.com/problems/plus-one/solution/gong-shui-san-xie-jian-dan-mo-ni-ti-by-a-5av1/)简单🤩🤩🤩🤩[68. 文本左右对齐](https://leetcode-cn.com/problems/text-justification/)[LeetCode 题解链接](https://leetcode-cn.com/problems/text-justification/solution/gong-shui-san-xie-zi-fu-chuan-mo-ni-by-a-s3v7/)困难🤩🤩🤩[73. 矩阵置零](https://leetcode-cn.com/problems/set-matrix-zeroes/)[LeetCode 题解链接](https://leetcode-cn.com/problems/set-matrix-zeroes/solution/xiang-jie-fen-san-bu-de-o1-kong-jian-jie-dbxd/)中等🤩🤩🤩🤩[165. 比较版本号](https://leetcode-cn.com/problems/compare-version-numbers/)[LeetCode 题解链接](https://leetcode-cn.com/problems/compare-version-numbers/solution/gong-shui-san-xie-jian-dan-zi-fu-chuan-m-xsod/)中等🤩🤩🤩🤩[166. 分数到小数](https://leetcode-cn.com/problems/fraction-to-recurring-decimal/)[LeetCode 题解链接](https://leetcode-cn.com/problems/fraction-to-recurring-decimal/solution/gong-shui-san-xie-mo-ni-shu-shi-ji-suan-kq8c4/)中等🤩🤩🤩🤩[168. Excel表列名称](https://leetcode-cn.com/problems/excel-sheet-column-title/)[LeetCode 题解链接](https://leetcode-cn.com/problems/excel-sheet-column-title/solution/gong-shui-san-xie-cong-1-kai-shi-de-26-j-g2ur/)简单🤩🤩🤩[171. Excel表列序号](https://leetcode-cn.com/problems/excel-sheet-column-number/)[LeetCode 题解链接](https://leetcode-cn.com/problems/excel-sheet-column-number/solution/gong-shui-san-xie-tong-yong-jin-zhi-zhua-y5fm/)简单🤩🤩🤩[190. 颠倒二进制位](https://leetcode-cn.com/problems/reverse-bits/)[LeetCode 题解链接](https://leetcode-cn.com/problems/reverse-bits/solution/yi-ti-san-jie-dui-cheng-wei-zhu-wei-fen-ub1hi/)简单🤩🤩🤩[233. 数字 1 的个数](https://leetcode-cn.com/problems/number-of-digit-one/)[LeetCode 题解链接](https://leetcode-cn.com/problems/number-of-digit-one/solution/gong-shui-san-xie-jiang-shu-wei-dp-wen-t-c9oi/)困难🤩🤩🤩🤩[237. 删除链表中的节点](https://leetcode-cn.com/problems/delete-node-in-a-linked-list/)[LeetCode 题解链接](https://leetcode-cn.com/problems/delete-node-in-a-linked-list/solution/gong-shui-san-xie-jian-dan-lian-biao-mo-rovcb/)简单🤩🤩🤩[260. 只出现一次的数字 III](https://leetcode-cn.com/problems/single-number-iii/)[LeetCode 题解链接](https://leetcode-cn.com/problems/single-number-iii/solution/gong-shui-san-xie-yi-ti-shuang-jie-ha-xi-zgi4/)中等🤩🤩🤩🤩[263. 丑数](https://leetcode-cn.com/problems/ugly-number/)[LeetCode 题解链接](https://leetcode-cn.com/problems/ugly-number/solution/gong-shui-san-xie-jian-dan-de-fen-qing-k-dlvg/)简单🤩🤩[268. 丢失的数字](https://leetcode-cn.com/problems/missing-number/)[LeetCode 题解链接](https://leetcode-cn.com/problems/missing-number/solution/gong-shui-san-xie-yi-ti-wu-jie-pai-xu-ji-te3s/)简单🤩🤩🤩🤩[273. 整数转换英文表示](https://leetcode-cn.com/problems/integer-to-english-words/)[LeetCode 题解链接](https://leetcode-cn.com/problems/integer-to-english-words/solution/gong-shui-san-xie-zi-fu-chuan-da-mo-ni-b-0my6/)困难🤩🤩🤩🤩[284. 顶端迭代器](https://leetcode-cn.com/problems/peeking-iterator/)[LeetCode 题解链接](https://leetcode-cn.com/problems/peeking-iterator/solution/gong-shui-san-xie-die-dai-qi-ji-ben-ren-b77lz/)中等🤩🤩🤩🤩[299. 猜数字游戏](https://leetcode-cn.com/problems/bulls-and-cows/)[LeetCode 题解链接](https://leetcode-cn.com/problems/bulls-and-cows/solution/gong-shui-san-xie-jian-dan-mo-ni-ti-by-a-tdhs/)中等🤩🤩🤩🤩[335. 路径交叉](https://leetcode-cn.com/problems/self-crossing/)[LeetCode 题解链接](https://leetcode-cn.com/problems/self-crossing/solution/gong-shui-san-xie-fen-qing-kuang-tao-lun-zdrb/)困难🤩🤩🤩🤩[345. 反转字符串中的元音字母](https://leetcode-cn.com/problems/reverse-vowels-of-a-string/)[LeetCode 题解链接](https://leetcode-cn.com/problems/reverse-vowels-of-a-string/solution/gong-shui-san-xie-note-bie-pian-shuang-z-c8ii/)简单🤩🤩🤩[405. 数字转换为十六进制数](https://leetcode-cn.com/problems/convert-a-number-to-hexadecimal/)[LeetCode 题解链接](https://leetcode-cn.com/problems/convert-a-number-to-hexadecimal/solution/gong-shui-san-xie-yi-ti-shuang-jie-jin-z-d93o/)简单🤩🤩🤩🤩[412. Fizz Buzz](https://leetcode-cn.com/problems/fizz-buzz/)[LeetCode 题解链接](https://leetcode-cn.com/problems/fizz-buzz/solution/gong-shui-san-xie-jian-dan-mo-ni-ti-by-a-jll0/)简单🤩🤩🤩🤩[413. 等差数列划分](https://leetcode-cn.com/problems/arithmetic-slices/)[LeetCode 题解链接](https://leetcode-cn.com/problems/arithmetic-slices/solution/gong-shui-san-xie-shuang-zhi-zhen-qiu-ji-ef1q/)中等🤩🤩🤩🤩[414. 第三大的数](https://leetcode-cn.com/problems/third-maximum-number/)[LeetCode 题解链接](https://leetcode-cn.com/problems/third-maximum-number/solution/gong-shui-san-xie-yi-ti-shuang-jie-pai-x-pmln/)中等🤩🤩🤩🤩[434. 字符串中的单词数](https://leetcode-cn.com/problems/number-of-segments-in-a-string/)[LeetCode 题解链接](https://leetcode-cn.com/problems/number-of-segments-in-a-string/solution/gong-shui-san-xie-jian-dan-zi-fu-mo-ni-t-0gx6/)简单🤩🤩🤩🤩[443. 压缩字符串](https://leetcode-cn.com/problems/string-compression/)[LeetCode 题解链接](https://leetcode-cn.com/problems/string-compression/solution/gong-shui-san-xie-shuang-zhi-zhen-yuan-d-bppu/)中等🤩🤩🤩🤩[451. 根据字符出现频率排序](https://leetcode-cn.com/problems/sort-characters-by-frequency/)[LeetCode 题解链接](https://leetcode-cn.com/problems/sort-characters-by-frequency/solution/gong-shui-san-xie-shu-ju-jie-gou-yun-yon-gst9/)中等🤩🤩🤩🤩[457. 环形数组是否存在循环](https://leetcode-cn.com/problems/circular-array-loop/)[LeetCode 题解链接](https://leetcode-cn.com/problems/circular-array-loop/solution/gong-shui-san-xie-yi-ti-shuang-jie-mo-ni-ag05/)中等🤩🤩🤩🤩[482. 密钥格式化](https://leetcode-cn.com/problems/license-key-formatting/)[LeetCode 题解链接](https://leetcode-cn.com/problems/license-key-formatting/solution/gong-shui-san-xie-jian-dan-zi-fu-chuan-m-piya/)简单🤩🤩🤩🤩[492. 构造矩形](https://leetcode-cn.com/problems/construct-the-rectangle/)[LeetCode 题解链接](https://leetcode-cn.com/problems/construct-the-rectangle/solution/gong-shui-san-xie-jian-dan-mo-ni-ti-by-a-7ser/)简单🤩🤩🤩🤩[495. 提莫攻击](https://leetcode-cn.com/problems/teemo-attacking/)[LeetCode 题解链接](https://leetcode-cn.com/problems/teemo-attacking/solution/gong-shui-san-xie-jian-dan-mo-ni-ti-by-a-gteh/)简单✔🤩🤩🤩🤩🤩[500. 键盘行](https://leetcode-cn.com/problems/keyboard-row/)[LeetCode 题解链接](https://leetcode-cn.com/problems/keyboard-row/solution/gong-shui-san-xie-jian-dan-zi-fu-chuan-m-zx6b/)简单🤩🤩🤩🤩[520. 检测大写字母](https://leetcode-cn.com/problems/detect-capital/)[LeetCode 题解链接](https://leetcode-cn.com/problems/detect-capital/solution/gong-shui-san-xie-jian-dan-zi-fu-chuan-m-rpor/)简单🤩🤩🤩🤩[528. 按权重随机选择](https://leetcode-cn.com/problems/random-pick-with-weight/)[LeetCode 题解链接](https://leetcode-cn.com/problems/random-pick-with-weight/solution/gong-shui-san-xie-yi-ti-shuang-jie-qian-8bx50/)中等🤩🤩🤩🤩[541. 反转字符串 II](https://leetcode-cn.com/problems/reverse-string-ii/)[LeetCode 题解链接](https://leetcode-cn.com/problems/reverse-string-ii/solution/gong-shui-san-xie-jian-dan-zi-fu-chuan-m-p88f/)简单✔❗🤩🤩🤩🤩🤩[551. 学生出勤记录 I](https://leetcode-cn.com/problems/student-attendance-record-i/)[LeetCode 题解链接](https://leetcode-cn.com/problems/student-attendance-record-i/solution/gong-shui-san-xie-jian-dan-mo-ni-ti-by-a-hui7/)简单🤩🤩🤩[566. 重塑矩阵](https://leetcode-cn.com/problems/reshape-the-matrix/)[LeetCode 题解链接](https://leetcode-cn.com/problems/reshape-the-matrix/solution/jian-dan-ti-zhong-quan-chu-ji-ke-yi-kan-79gv5/)简单🤩🤩🤩[598. 范围求和 II](https://leetcode-cn.com/problems/range-addition-ii/)[LeetCode 题解链接](https://leetcode-cn.com/problems/range-addition-ii/solution/gong-shui-san-xie-jian-dan-mo-ni-ti-by-a-006h/)简单🤩🤩🤩[645. 错误的集合](https://leetcode-cn.com/problems/set-mismatch/)[LeetCode 题解链接](https://leetcode-cn.com/problems/set-mismatch/solution/gong-shui-san-xie-yi-ti-san-jie-ji-shu-s-vnr9/)简单🤩🤩🤩[726. 原子的数量](https://leetcode-cn.com/problems/number-of-atoms/)[LeetCode 题解链接](https://leetcode-cn.com/problems/number-of-atoms/solution/gong-shui-san-xie-shi-yong-xiao-ji-qiao-l5ak4/)困难🤩🤩🤩🤩[766. 托普利茨矩阵](https://leetcode-cn.com/problems/toeplitz-matrix/)[LeetCode 题解链接](https://leetcode-cn.com/problems/toeplitz-matrix/solution/cong-ci-pan-du-qu-cheng-ben-fen-xi-liang-f20w/)简单🤩🤩🤩[867. 转置矩阵](https://leetcode-cn.com/problems/transpose-matrix/)[LeetCode 题解链接](https://leetcode-cn.com/problems/transpose-matrix/solution/yi-you-wei-jin-huo-xu-ni-neng-kan-kan-zh-m53m/)简单🤩🤩🤩🤩[896. 单调数列](https://leetcode-cn.com/problems/monotonic-array/)[LeetCode 题解链接](https://leetcode-cn.com/problems/monotonic-array/solution/wei-shi-yao-yi-ci-bian-li-yao-bi-liang-c-uglp/)简单🤩🤩🤩🤩[1047. 删除字符串中的所有相邻重复项](https://leetcode-cn.com/problems/remove-all-adjacent-duplicates-in-string/)[LeetCode 题解链接](https://leetcode-cn.com/problems/remove-all-adjacent-duplicates-in-string/solution/cong-30-dao-100wu-chong-shi-xian-jie-jue-vkah/)简单🤩🤩🤩🤩[1104. 二叉树寻路](https://leetcode-cn.com/problems/path-in-zigzag-labelled-binary-tree/)[LeetCode 题解链接](https://leetcode-cn.com/problems/path-in-zigzag-labelled-binary-tree/solution/gong-shui-san-xie-yi-ti-shuang-jie-mo-ni-rw2d/)中等🤩🤩🤩[1436. 旅行终点站](https://leetcode-cn.com/problems/destination-city/)[LeetCode 题解链接](https://leetcode-cn.com/problems/destination-city/solution/gong-shui-san-xie-jian-dan-fang-jia-mo-n-y47c/)简单✔❗🤩🤩🤩🤩🤩[1480. 一维数组的动态和](https://leetcode-cn.com/problems/running-sum-of-1d-array/)[LeetCode 题解链接](https://leetcode-cn.com/problems/running-sum-of-1d-array/solution/gong-shui-san-xie-yi-wei-qian-zhui-he-mo-g8hn/)简单✔🤩🤩🤩🤩🤩[1486. 数组异或操作](https://leetcode-cn.com/problems/xor-operation-in-an-array/)[LeetCode 题解链接](https://leetcode-cn.com/problems/xor-operation-in-an-array/solution/gong-shui-san-xie-yi-ti-shuang-jie-mo-ni-dggg/)简单🤩🤩🤩[1583. 统计不开心的朋友](https://leetcode-cn.com/problems/count-unhappy-friends/)[LeetCode 题解链接](https://leetcode-cn.com/problems/count-unhappy-friends/solution/gong-shui-san-xie-ha-xi-biao-mo-ni-ti-by-2qy0/)中等🤩🤩🤩🤩[1646. 获取生成数组中的最大值](https://leetcode-cn.com/problems/get-maximum-in-generated-array/)[LeetCode 题解链接](https://leetcode-cn.com/problems/get-maximum-in-generated-array/solution/gong-shui-san-xie-jian-dan-mo-ni-ti-by-a-sj53/)简单🤩🤩🤩🤩[1720. 解码异或后的数组](https://leetcode-cn.com/problems/decode-xored-array/)[LeetCode 题解链接](https://leetcode-cn.com/problems/decode-xored-array/solution/gong-shui-san-xie-li-yong-yi-huo-xing-zh-p1bi/)简单🤩🤩🤩[1736. 替换隐藏数字得到的最晚时间](https://leetcode-cn.com/problems/latest-time-by-replacing-hidden-digits/)[LeetCode 题解链接](https://leetcode-cn.com/problems/latest-time-by-replacing-hidden-digits/solution/gong-shui-san-xie-ti-huan-yin-cang-shu-z-2l1h/)简单🤩🤩🤩🤩[1743. 从相邻元素对还原数组](https://leetcode-cn.com/problems/restore-the-array-from-adjacent-pairs/)[LeetCode 题解链接](https://leetcode-cn.com/problems/restore-the-array-from-adjacent-pairs/solution/gong-shui-san-xie-yi-ti-shuang-jie-dan-x-elpx/)中等🤩🤩🤩🤩[1748. 唯一元素的和](https://leetcode-cn.com/problems/sum-of-unique-elements/)[LeetCode 题解链接](https://leetcode-cn.com/problems/sum-of-unique-elements/solution/mo-ni-ti-po-su-jie-fa-by-ac_oier-ff69/)简单🤩🤩[1763. 最长的美好子字符串](https://leetcode-cn.com/problems/longest-nice-substring/)[LeetCode 题解链接](https://leetcode-cn.com/problems/longest-nice-substring/solution/cong-shu-ju-fan-wei-xuan-ze-he-gua-suan-n3y2a/)简单🤩🤩🤩[1834. 单线程 CPU](https://leetcode-cn.com/problems/single-threaded-cpu/)[LeetCode 题解链接](https://leetcode-cn.com/problems/single-threaded-cpu/solution/gong-shui-san-xie-shu-ju-jie-gou-yun-yon-1qk0/)中等🤩🤩🤩🤩[1893. 检查是否区域内所有整数都被覆盖](https://leetcode-cn.com/problems/check-if-all-the-integers-in-a-range-are-covered/)[LeetCode 题解链接](https://leetcode-cn.com/problems/check-if-all-the-integers-in-a-range-are-covered/solution/gong-shui-san-xie-yi-ti-shuang-jie-mo-ni-j83x/)简单🤩🤩🤩🤩[1894. 找到需要补充粉笔的学生编号](https://leetcode-cn.com/problems/find-the-student-that-will-replace-the-chalk/)[LeetCode 题解链接](https://leetcode-cn.com/problems/find-the-student-that-will-replace-the-chalk/solution/gong-shui-san-xie-yi-ti-shuang-jie-qian-kpqsk/)中等🤩🤩🤩🤩[面试题 10.02. 变位词组](https://leetcode-cn.com/problems/group-anagrams-lcci/)[LeetCode 题解链接](https://leetcode-cn.com/problems/group-anagrams-lcci/solution/gong-shui-san-xie-tong-ji-bian-wei-ci-de-0iqe/)中等🤩🤩🤩🤩

#### 1.两数之和：i+j=target，哈希

> **遍历**i，看所过之处，有没有互补的

```C++
class Solution {
public:
    vector<int> twoSum(vector<int>& nums, int target) {
        unordered_map<int, int> heap;
        for (int i = 0; i < nums.size(); i ++ ) {
            int r = target - nums[i];
            if (heap.count(r)) return {heap[r], i};
            heap[nums[i]] = i;
        }

        return {};
    }
};
class Solution:
    def twoSum(self, nums: List[int], target: int) -> List[int]:
    
        # 解法一，常规双循环
        lenNums = len(nums)
        for i in range(lenNums):
            for j in range(i+1, lenNums):
                if nums[i] + nums[j] == target:
                    return i,j  # return [i,j] 这两个return效果是一样的?
        # 并不是，这里只是写了个函数，并不涉及输入输出之类

        # 解法二，用set类型
        setNums = set(nums)
        for i in range(len(nums)):
            if target - nums[i] in setNums:
                index = nums.index(target - nums[i])
                if index == i:
                    continue
                return i, index

        # 解法三，用hash表，但核心是不要预先构建hash表
        dicNums = {}
        for i in range(len(nums)):
            if nums[i] in dicNums:
                return dicNums[nums[i]], i
            dicNums[target - nums[i]] = i   # 核心是这句，一边查表，一边建表
```

#### 2.两数相加：基于链表 竖式相加

```C++
/**
 * Definition for singly-linked list.
 * struct ListNode {
 *     int val;
 *     ListNode *next;
 *     ListNode() : val(0), next(nullptr) {}
 *     ListNode(int x) : val(x), next(nullptr) {}
 *     ListNode(int x, ListNode *next) : val(x), next(next) {}
 * };
 */
class Solution {
public:
    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {
        ListNode* head = new ListNode(-1);
        ListNode* p = head;
        bool carry = false; //进位
        int sum = 0;
        while(l1 || l2){
            sum = 0; //⭐不要忘记写，每次sum要清空给下一次用
            if(l1){
                sum += l1->val;
                l1 = l1->next;
            }
            if(l2){
                sum += l2->val;
                l2 = l2->next;
            }
            if(carry)
                sum++;
            p->next = new ListNode(sum % 10);
            carry = sum >= 10 ? true : false; //⭐>=，不是大于
            p = p->next;
        }
        //当l1,l2都到最后为空，且有进位时
        if(carry)
            p->next = new ListNode(1); //p->next⭐
        
        return head->next;
    }
};
//不能用l1.next
//error: member reference type 'ListNode *' is a pointer; did you mean to use '->'?
//一个搞ACM的人写的代码，很干净简洁
    ListNode *addTwoNumbers(ListNode *l1, ListNode *l2) {
        ListNode* head = new ListNode();
        ListNode* currentPos = head;
        int v = 0;
        while(l1 || l2 || v) {
            int v1 = l1 ? l1->val : 0, v2 = l2 ? l2->val : 0; //不空为val，空位0
            int res = (v + v1 + v2) / 10;
            v = (v1 + v2 + v) % 10;
            currentPos->val = v;
            v = res;
            if (l1) l1 = l1->next;
            if (l2) l2 = l2->next;
            if (l1 || l2 || v) {
                currentPos->next = new ListNode();
                currentPos = currentPos->next;
            }
        }
        return head;
    }
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def addTwoNumbers(self, l1: ListNode, l2: ListNode) -> ListNode:
        result = ListNode(0)
        r=result
        carry=0
        while(l1 or l2):
            x= l1.val if l1 else 0
            y= l2.val if l2 else 0
            s = carry + x + y
            carry = s//10  # 返回商的整数部分
            r.next = ListNode( s % 10)
            r = r.next
            if(l1!=None):
                l1=l1.next
            if(l2!=None):
                l2=l2.next
        if(carry>0):
            r.next=ListNode(1)
        
        return result.next
```

#### 5.最长回文子串：中心扩展

官方题解：动态规划、中心扩展、manacher马拉车？

**中心扩展**

> 还是用中心扩展吧

```C++
//自己的
class Solution {
public:
    string longestPalindrome(string s) {
        string ans = "";
        for (int i = 0; i < s.length(); i++) {
            // 先看回文串为奇数个时，左一个右一个
            int l = i - 1, r = i + 1;
            string sub = getString(s, l, r);
            if (sub.length() > ans.length()) ans = sub;
            // 再看回文串为偶数个时，右一个
            //i=0时直接看右边的
            l = i, r = i + 1;
            sub = getString(s, l, r);
            if (sub.length() > ans.length()) ans = sub;
        }
        return ans;
    }
    string getString(string s, int l, int r) {
        //计算以left和right为中心的回文串
        int left = l, right = r;
        while (left >= 0 && right < s.length() && s[left] == s[right]) {
            left--;
            right++;
        } 
        //向左右扩，return right-left-1
        //计算真实值要先把r和l恢复，(right-1)-(left+1)+1=r-l-1
        return s.substr(left + 1, right-left-1); //注意，这个子串的方法不同于Java！⭐
    }
};
//Java中：s.charAt(i) 指的是取字符串中下标i的
//C++中，求子串s.substr(a,b) 从a开始的b个
# 一个抄来的
class Solution:
    def longestPalindrome(self, s: str) -> str:
        maxl, max_len = 0, 0
        n = len(s)
        for i in range(2*n-1):
            l = i//2
            r = i//2 + i%2
            while l >= 0 and r < n and s[l] == s[r]:
                if r-l+1 > max_len: 
                    maxl = l
                    max_len = r-l+1
                l-=1
                r+=1
        return s[maxl : maxl+max_len]
# 终于，把自己的代码写出来了
class Solution:
    def longestPalindrome(self, s: str) -> str:
        ans=""
        for i in range(len(s)):
            l = i - 1
            r = i + 1
            sub = self.getString(s, l, r)
            if len(sub) > len(ans):
                ans = sub
            
            l = i
            r = i + 1
            sub = self.getString(s, l, r)
            if len(sub) > len(ans):
                ans = sub
        return ans


    def getString(self, s, l, r):
        left = l
        right = r
        while left >= 0 and right <len(s) and s[left] == s[right]:
            left-=1
            right+=1
        return s[left + 1:right]
# 对并另一个简洁好看的
   def longestPalindrome(self, s: str) -> str:
        res = ''
        for i in range(len(s)):
            s1 = self.find(s, i, i)       # 以当前字符为中心的最长回文子串，（奇数个）
            s2 = self.find(s, i, i+1)     # 以当前字符和下一字符为中心的最长回文子串
            #如果最大长度有变化则更新res
            if max(len(s1), len(s2)) > len(res):
                res = s2 if len(s1) < len(s2) else s1
        return res

    def find(self, s, left, right):
        #找到当前中心的最大长度子串
        while left >= 0 and right < len(s) and s[left] == s[right]:
            left -= 1
            right += 1
        return s[left+1:right]
```

**动态规划**

```C++
//自己的一个版本，很尴尬，错了

//输入："cbbd"
//输出："c"
//预期结果："bb"
class Solution {
public:
    string longestPalindrome(string s){
        int n = s.size();
        int max = 1, begin = 0; //得在外面定义⭐
        if(n <= 2) return s;
        vector<vector<int>> dp(n,vector<int>(n));
        //根据边界条件，初始化！
        for(int i = 0; i < n; i++){
            dp[i][i] = true;
            if(s[i]==s[i+1] && i<n-1) dp[i][i+1] = true; 
        }

        for(int l = 3; l < n; l++){
            for(int i=0; i < n; i++){
                int j = l - i + 1;
                if(j >= n) break;
                if(s[i] != s[j]) dp[i][j] = false;
                //really??
                else{
                    dp[i][j] = true;
                    dp[i][j] = dp[i+1][j-1];
                }

                //output
                if(dp[i][j] && j-i+1 > max){
                    max = j-i+1;
                    begin = i;
                }
            }
        }
        return s.substr(begin, max);
    }
};
//官方题解
class Solution {
public:
    string longestPalindrome(string s) {
        int n = s.size();
        if (n < 2) {
            return s;
        }

        int maxLen = 1;
        int begin = 0;
        // dp[i][j] 表示 s[i..j] 是否是回文串
        vector<vector<int>> dp(n, vector<int>(n));
        // 初始化：所有长度为 1 的子串都是回文串
        for (int i = 0; i < n; i++) {
            dp[i][i] = true;
        }
        // 递推开始
        // 先枚举子串长度
        for (int L = 2; L <= n; L++) {
            // 枚举左边界，左边界的上限设置可以宽松一些
            for (int i = 0; i < n; i++) {
                // 由 L 和 i 可以确定右边界，即 j - i + 1 = L 得
                int j = L + i - 1;
                // 如果右边界越界，就可以退出当前循环
                if (j >= n) {
                    break;
                }

                if (s[i] != s[j]) {
                    dp[i][j] = false;
                } else {
                    if (j - i < 3) {
                        dp[i][j] = true;
                    } else {
                        dp[i][j] = dp[i + 1][j - 1];
                    }
                }

                // 只要 dp[i][L] == true 成立，就表示子串 s[i..L] 是回文，此时记录回文长度和起始位置
                if (dp[i][j] && j - i + 1 > maxLen) {
                    maxLen = j - i + 1;
                    begin = i;
                }
            }
        }
        return s.substr(begin, maxLen);
    }
};
```

**Manacher 算法**



#### [89. 格雷编码](https://leetcode-cn.com/problems/gray-code/)：对称生成的方法

![img](https://uestc.feishu.cn/space/api/box/stream/download/asynccode/?code=ZTAyZWEzNDhlNWMxNjcwNDBiMDkwMTIzZDA5MjgzZGRfZm9LNDNNUHF2b1NrS3dEMEZlN1BrbE5Gc3JNSlVwMzdfVG9rZW46Ym94Y250cjZEeko5elg4cmc4TmRSendxem9jXzE2NjI2NDE5MTE6MTY2MjY0NTUxMV9WNA)

**法1：对称生成？倒序拼接**

```C++
class Solution {
public:
    vector<int> grayCode(int n) {
        vector<int> ans;  // n>=1
        ans.push_back(0);
        ans.push_back(1);
        int add = 2;
        for(int i = 2; i <= n; i++){
            for(int j = add - 1; j >= 0; --j)
                ans.push_back(ans[j] + add);  // 倒着增加如ans向量
            add *= 2;
        }
        return ans;
    }
};
```





**法2：直接利用定义构造格雷编码**









#### [112. 路径总和](https://leetcode-cn.com/problems/path-sum/)：直接递归 / DFS / BFS ⭐面试题

![img](https://uestc.feishu.cn/space/api/box/stream/download/asynccode/?code=NDI3Yjk2MDFlMzhiZTE1ZWNhYTJkNGMxMGJjMThlNDhfeEpQekQzNzRRaU9IcmEzRlpqN1FkczFVQWVFUTRjU05fVG9rZW46Ym94Y25CVU5sOW10YzhEZDZqMkJnVmZGMlVVXzE2NjI2NDE5MTE6MTY2MjY0NTUxMV9WNA)

这道题面试的时候遇到了⭐

推荐题解：

- [C++DFS/BFS - 路径总和 - 力扣（LeetCode） (leetcode-cn.com)](https://leetcode-cn.com/problems/path-sum/solution/cdfsbfs-by-sscicada-vhh5/)
- [路径总和的四种解法：DFS、回溯、BFS、栈 - 路径总和 - 力扣（LeetCode） (leetcode-cn.com)](https://leetcode-cn.com/problems/path-sum/solution/lu-jing-zong-he-de-si-chong-jie-fa-dfs-hui-su-bfs-/)

**法1：递归（结合着DFS的思想）**

```Python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right

class Solution:
    def hasPathSum(self, root:TreeNode, sum: int) -> bool:
        if not root:
            return False
        if not root.left and not root.right:
            return sum == root.val
        return self.hasPathSum(root.left, sum-root.val) or self.hasPathSum(root.right, sum-root.val)
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */

class Solution {
public:
    bool hasPathSum(TreeNode* root, int sum) {
        if(root == nullptr) 
            return false;
        if(root->left == nullptr && root->right == nullptr)
            return sum == root->val;
        return hasPathSum(root->left, sum-root->val) || hasPathSum(root->right, sum-root->val);
    }
};
```

**法2：DFS用栈**

```Python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def hasPathSum(self, root: TreeNode, target: int) -> bool:
        if not root: 
            return False
        return self.dfs(root, target, [root.val])
    
    def dfs(self, root, target, path):
        if not root: 
            return False
        if sum(path) == target and not root.left and not root.right:
            return True
        lflag, rflag = False, False
        if root.left:
            lflag = self.dfs(root.left, target, path+[root.left.val])
        if root.right:
            rflag = self.dfs(root.right, target, path+[root.right.val])
        return lflag or rflag
```

其中，注意列表的拼接

![img](https://uestc.feishu.cn/space/api/box/stream/download/asynccode/?code=NGQyMThlZTQwMzU0ZDc1YjRmODc5M2ZiMzk3NDk5ZGNfeU45bGdqbkpQYlJ1VTlCQnVxa05RQTcxeTVveFlWekxfVG9rZW46Ym94Y25tM3lmS3lVMjhUNldPUWR4c1FVbUszXzE2NjI2NDE5MTE6MTY2MjY0NTUxMV9WNA)

如果使用C++，需要注意一个问题：

加上cur值后还需要减去它！！

以下的方法是有问题的

![img](https://uestc.feishu.cn/space/api/box/stream/download/asynccode/?code=YjAyY2I1M2YwNTg1MjA2MWZiYjM1NmFjZjM2MGUwMWFfeEhuaWFiMEJiQkVxYXB3RWo1QVAxYWV5b0x3TEt5QnNfVG9rZW46Ym94Y25TREFPTVo4NXRvM3k2Sm9uYUoxUWRoXzE2NjI2NDE5MTE6MTY2MjY0NTUxMV9WNA)

正解：

```C++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */

class Solution {
public:
    // vector<int> path;
    int cur = 0;
    bool hasPathSum(TreeNode* root, int sum) {
        if(root == nullptr) 
            return false;
        // path.push_back(root->val);
        return dfs(root, sum);
    }
    bool dfs(TreeNode* root, int sum){
        if(root == nullptr)
            return false;
        cur += root->val;
        if(cur == sum && root->left == nullptr && root->right == nullptr)
            return true;
        if(root->left){
            if(dfs(root->left, sum)) return true;
            cur -= root->left->val;
        }
        if(root->right){
            if(dfs(root->right, sum)) return true;
            cur -= root->right->val;
        }
        return false;
    }
};
```

![img](https://uestc.feishu.cn/space/api/box/stream/download/asynccode/?code=MGRjMTFiMWJiYWZhZWM1MGI5NDkyMDRlMjhmMTVhNjZfRnhEaWkxZEIwZjljNGtyVFdHYXplaWFhU2NKaGdtaXhfVG9rZW46Ym94Y25aZzBZVTJYVXZZbEs1RnhKNzFmNHhoXzE2NjI2NDE5MTE6MTY2MjY0NTUxMV9WNA)



**法3：BFS用队列**

```c++
class Solution:
    def hasPathSum(self, root: TreeNode, sum: int) -> bool:
        if not root:
            return False
        que = collections.deque()
        que.append((root, root.val))
        while que:
            node, cur = que.popleft()
            if not node.left and not node.right and cur == sum:
                return True
            if node.left:
                que.append((node.left, cur + node.left.val))
            if node.right:
                que.append((node.right, cur + node.right.val))
        return False
class Solution {
public:
// 维护两个队列，一个存放节点，一个存放根节点到该节点路径的和
// 一层一层遍历，遍历找到了没有左右孩子并且和等于 targetSum 的节点，就 return true
// 没有找到就 return false
    bool hasPathSum(TreeNode* root, int targetSum) {
        if (root == nullptr) return false;
        queue<TreeNode*> node_que;
        queue<int> cur;
        node_que.push(root);
        cur.push(root->val);
        while (!node_que.empty()) {
            int size = node_que.size();
            for (int i = 0; i < size; ++i) {
                TreeNode *t = node_que.front();
                node_que.pop();
                int temp = cur.front();
                cur.pop();
                if (!t->left && !t->right && temp == targetSum) {
                    return true;
                }
                if (t->left) {
                    node_que.push(t->left);
                    int m = temp + t->left->val;
                    cur.push(m);
                }
                if (t->right) {
                    node_que.push(t->right);
                    int m = temp + t->right->val;
                    cur.push(m);
                }
            }
        }
        return false;
    }
}; 
```

**法4：直接用栈**

![img](https://uestc.feishu.cn/space/api/box/stream/download/asynccode/?code=ZWMyZjc1OTQwNDJkYmNmYTE4YWIyZjZhYTUzYzM2MWJfdWhFZXZKT3oxSU1YZHZJeGl1TnhzTHZUSzFrU29rYTdfVG9rZW46Ym94Y243VUJzRnU4M1RpdWI2bXdwRWZoenNjXzE2NjI2NDE5MTE6MTY2MjY0NTUxMV9WNA)



#### [324. 摆动排序 II](https://leetcode.cn/problems/wiggle-sort-ii/)：不能想得太简单

```C++
这个就是想的太简单了：
    如果[1,5,1,1,6,4]，就会输出[1,1,1,5,4,6]，显然是错的
    void wiggleSort(vector<int>& nums) {
        int n = nums.size();
        if (n == 1) return;
        sort(nums.begin(), nums.end());
        for (int i = 1; i < n - 1; i += 2) {
            swap(nums[i], nums[i + 1]);
        }
```

可以看一下官方题解

```C++
class Solution {
public:
    void wiggleSort(vector<int>& nums) {
        int n = nums.size();
        vector<int> tmp = nums;
        sort(tmp.begin(), tmp.end());
        int mid = (n + 1) / 2;
        for (int i = 0, j = mid - 1, k = n - 1; i < n; i += 2, j--, k--) {
            nums[i] = tmp[j];
            if (i + 1 < n) nums[i + 1] = tmp[k];
        }
    }
};
```



#### [383. 赎金信](https://leetcode-cn.com/problems/ransom-note/)：统计词频，counter()函数 相减

![img](https://uestc.feishu.cn/space/api/box/stream/download/asynccode/?code=MDg3MmU3NzBiMmU3MTk0ZGQyNzJjMWJmYmRkNDE5ODBfNDJ6UERxS1VmVjE5QllZY1JrQUx6VzNxVFowbWZucUVfVG9rZW46Ym94Y25zc3dYdm1pd1lZclFWSXZyUWp1YWxnXzE2NjI2NDE5MTE6MTY2MjY0NTUxMV9WNA)![img](https://uestc.feishu.cn/space/api/box/stream/download/asynccode/?code=NjAyYzUyODJkMWFmNmJhNTQ4YjNmODk3NzgzMDU5M2JfUjJXWVFEWmt5QWs2a2hPZkVrRDhwdUNFTUJnYTN2aGpfVG9rZW46Ym94Y25vNnhtaDBLbzdWU1VYaDdzSFkzc01lXzE2NjI2NDE5MTE6MTY2MjY0NTUxMV9WNA)

思路就是直接统计词频，

```C++
class Solution {
public:
    // 统计词频
    bool canConstruct(string ransomNote, string magazine) {
        vector<int> cnt(26);
        for(char c: magazine) 
            cnt[c-'a']++;
        for(char c: ransomNote) 
            if(--cnt[c-'a'] < 0)
                return false;
        return true;
    }
};
```

python一行代码解决问题：

```Python
class Solution:
    def canConstruct(self, ransomNote: str, magazine: str) -> bool:
        return not collections.Counter(ransomNote)-collections.Counter(magazine)
```

![img](https://uestc.feishu.cn/space/api/box/stream/download/asynccode/?code=MjNlMTJmNDc0YmNlNDRlMmEzYWEyZjEyMjBlOWM2N2FfVDh3djZmM2xiYk92V1M4MmFxSzVCRlMxeWtiSlhPTVZfVG9rZW46Ym94Y242U0ZKanJmNnJpYU50aVlEQWd0WG9jXzE2NjI2NDE5MTE6MTY2MjY0NTUxMV9WNA)



#### [468. 验证IP地址](https://leetcode.cn/problems/validate-ip-address/)：字符串模拟











#### 495.提莫攻击：简单的模拟

#### 506.相对名次：pair 哈希 python写法？

```C++
// 易懂的版本
class Solution {
public:
    vector<string> findRelativeRanks(vector<int>& nums) {
        vector<int> org = nums;
        sort(nums.rbegin(), nums.rend());
        unordered_map<int, string> order;
        for (int i = 0; i < nums.size(); i++) {
            if (i >= 3) order[nums[i]] = to_string(i+1);
            if (i == 0) order[nums[i]] = "Gold Medal";
            if (i == 1) order[nums[i]] = "Silver Medal";
            if (i == 2) order[nums[i]] = "Bronze Medal";
        }

        vector<string> res(nums.size());
        for (int i = 0; i < res.size(); i++) {
            res[i] = order[org[i]];
        }

        return res;
    }
};
// 官方题解
class Solution {
public:
    vector<string> findRelativeRanks(vector<int>& score) {
        int n = score.size();
        string str_ans[3] = {"Gold Medal", "Silver Medal", "Bronze Medal"};
        vector<pair<int, int>> mypair;

        //存入哈希表(这里vector)
        for (int i = 0; i < n; ++i) {
            mypair.emplace_back(make_pair(-score[i], i));
            // emplace_back会在插入数据后直接构造数据。相比push,emplace底层实现更简洁，效率高，当然可以push_back()
        }
        sort(mypair.begin(), mypair.end());
        
        //输出结果
        vector<string> ans(n);
        for (int i = 0; i < n; ++i) {
            if (i >= 3) {
                ans[mypair[i].second] = to_string(i + 1);
            } else {
                ans[mypair[i].second] = str_ans[i];
            }
        }
        return ans;

    }
};
// 自己写的
class Solution {
public:
    vector<string> findRelativeRanks(vector<int>& score) {
        int n = score.size();
        string str_ans[3] = {"Gold Medal", "Silver Medal", "Bronze Medal"};
        unordered_map<int, int> mypair;  //sorted分数->排名
        vector<int> sorted = score;
        sort(sorted.begin(), sorted.end());
        //存入哈希表
        for (int i = n-1; i >= 0; --i) {
            mypair.insert(pair(sorted[i], n-1-i));
        }       
        //输出结果
        vector<string> ans(n);
        for (int i = 0; i < n; ++i) {
            int rank = mypair[score[i]];
            ans[i] = rank < 3 ? str_ans[rank] : to_string(rank + 1);
        }
        return ans;
    }
};
class Solution:
    desc = ("Gold Medal", "Silver Medal", "Bronze Medal")

    def findRelativeRanks(self, score: List[int]) -> List[str]:
        ans = [""] * len(score)   #不能写成[]*len()
        arr = sorted(enumerate(score), key=lambda x: -x[1])
        for i, (idx, _) in enumerate(arr):
            ans[idx] = self.desc[i] if i < 3 else str(i + 1)
        return ans
```



#### [532. 数组中的 k-diff 数对](https://leetcode.cn/problems/k-diff-pairs-in-an-array/)：哈希+set

思路比较好想到：

**法1：哈希表 or set**

> unordered_set会比set快上不少！

```C++
class Solution {
public:
    int findPairs(vector<int>& nums, int k) {
        unordered_set<int> ans;  // 记录较小的
        unordered_set<int> isHave;
        for (int n : nums) {
            if (isHave.count(n + k)) ans.insert(n);
            if (isHave.count(n - k)) ans.insert(n - k);
            isHave.insert(n);
        }
        return ans.size();
    }
};
```

**法2：排序后二分**

```C++
class Solution {
public:
    int findPairs(vector<int>& nums, int k) {
        sort(nums.begin(), nums.end());
        int n = nums.size(), ans = 0;
        for (int i = 0; i < n - 1; i++) {
            if (i > 0 && nums[i] == nums[i - 1]) continue;
            int l = i + 1, r = n - 1;
            while (l <= r) {
                int mid = l + (r - l) / 2;
                if (nums[mid] == nums[i] + k) {
                    ans++;
                    break;
                }
                else if (nums[mid] > nums[i] + k) r = mid - 1;
                else l = mid + 1;
            }
        }
        return ans;
    }
};
```

**法3：双指针**

```C++
class Solution {
public:
    int findPairs(vector<int>& nums, int k) {
        sort(nums.begin(), nums.end());
        int n = nums.size(), ans = 0;
        for (int i = 0; i < n; i++) {
            if (i > 0 && nums[i] == nums[i - 1]) continue;
            for (int j = i + 1; j < n; j++) {
                if (nums[j] == nums[i] + k) {
                    ans++;
                    break;
                }
            }
        }
        return ans;
    }
};
    
    换一种写法
    int findPairs(vector<int>& nums, int k) {
        sort(nums.begin(), nums.end());
        int size = nums.size(), ret = 0;
        int last = 1e7 + 1; //保存上一个数对中的x
        vector<int>::iterator it;
        for (int i = 0; i < size; i++) {
            if (nums[i] == last) continue; //如果x相同的话就跳过
            it = lower_bound(nums.begin() + i + 1, nums.end(), k + nums[i]);
            if (it != nums.end() && *it == (k + nums[i])) {
                ret++;
                last = nums[i];
            }
        }
        return ret;
    }
```



#### [535. TinyURL 的加密与解密](https://leetcode.cn/problems/encode-and-decode-tinyurl/)：伪加解密

> 直接用哈希表来存url就行

```C++
class Solution {
private:
    unordered_map<int, string> umap;
    int id = 0;
    string tiny = "http://tinyurl.com/";
public:
    // Encodes a URL to a shortened URL.
    string encode(string longUrl) {
        umap[++id] = longUrl;
        return tiny + to_string(id);
    }

    // Decodes a shortened URL to its original URL.
    string decode(string shortUrl) {
        int p = shortUrl.rfind('/') + 1;
        int key = stoi(shortUrl.substr(p, int(shortUrl.size()) - p));
        return umap[key];
    }
};
```





#### [537. 复数乘法](https://leetcode-cn.com/problems/complex-number-multiplication/)：

![img](https://uestc.feishu.cn/space/api/box/stream/download/asynccode/?code=YzViOTU4NzkwNzU0MjA2Yjk4Y2QwMzQ2ODA3NDVmZGRfOVUwTllTMjFlWlk4OEY4MU1DOGF4S1dDcGtEWFVFSkFfVG9rZW46Ym94Y25TUjhkUUdVZFdqblhsaVRVb0p0N2plXzE2NjI2NDE5MTE6MTY2MjY0NTUxMV9WNA)

```C++
class Solution {
public:
    string complexNumberMultiply(string num1, string num2) {
        // num1 = a1+b1*i
        // num2 = a2+b2*i
        int a1 = stoi(num1.substr(0, num1.find("+")));
        int b1 = stoi(num1.substr(num1.find("+") + 1, num1.size()-1));
        int a2 = stoi(num2.substr(0, num2.find("+")));
        int b2 = stoi(num2.substr(num2.find("+") + 1, num2.size()-1));
        int a = a1*a2 - b1*b2, b = a1*b2 + a2*b1;
        return to_string(a) + "+" + to_string(b) + "i";
    }
};
```

**注意：**

- stoi函数将字符串转换为整数
- to_string函数将整数转换为字符串





#### [541. 反转字符串 II](https://leetcode-cn.com/problems/reverse-string-ii/)：注意两种语言的reverse函数

![img](https://uestc.feishu.cn/space/api/box/stream/download/asynccode/?code=ODBiY2M4MjBiZWVjYTc3YTAxNjBiYTFiMDk2M2Q5M2RfQ0lLZlhYNlU3VnlNNUQ5Y2VoaU9Sbm1LRDRsc3E0aTlfVG9rZW46Ym94Y25tNnpXZlphVm9oZldkd3M2QlJCYXJlXzE2NjI2NDE5MTE6MTY2MjY0NTUxMV9WNA)

```C++
class Solution {
public:
    string reverseStr(string s, int k) {
        int n = s.length();
        for(int i = 0; i < n; i += 2*k){
            // reverse(s[i], s[i+k]);❌
            reverse(s.begin() + i, s.begin() + min(i + k, n)); //官方题解
        }
        return s;
    }
};

/*
c.begin() 返回一个迭代器，它指向容器c的第一个元素
c.end() 返回一个迭代器，它指向容器c的最后一个元素的下一个位置
c.rbegin() 返回一个逆序迭代器，它指向容器c的最后一个元素
c.rend() 返回一个逆序迭代器，它指向容器c的第一个元素前面的位置
*/
class Solution:
    def reverseStr(self, s: str, k: int) -> str:
        t = list(s) #按照列表来操作了
        for i in range(0, len(t), 2 * k):
            # t[i: i + k] = list(reversed(t[i: i + k])) # python的逆序⭐
            t[i: i + k] = reversed(t[i: i + k])
            # print(t[i:i+k])
        return "".join(t)

# return t
# 输出 ["b","a","c","d","f","e","g"]
# 预期结果 "bacdfeg"
# 要将列表转换为字符串！
```



#### [522. 最长特殊序列 II](https://leetcode.cn/problems/longest-uncommon-subsequence-ii/)：遍历字符串来比较

> `strs[i].size()`不能直接当作int来使用？

```C++
class Solution {
public:
    bool isSubseq(string a, string b) {  // a是否是b的子序列
        int i = 0, j = 0;
        while (i < a.size() && j < b.size()) {
            if (a[i] == b[j]) i++;
            j++;
        }
        return i == a.size();
    }
    int findLUSlength(vector<string>& strs) {
        int n = strs.size();
        int ans = -1;
        for (int i = 0; i < n; i++) {
            bool check = true;
            for (int j = 0; j < n; j++) {
                if (i != j && isSubseq(strs[i], strs[j])) {
                    check = false;
                    break;
                }
            }
            if (check) {
                ans = max(ans, (int)strs[i].size());
            }
        }
        return ans;
    }
};
```



#### [556. 下一个更大元素 III](https://leetcode.cn/problems/next-greater-element-iii/)

```C++
class Solution {
public:
    int nextGreaterElement(int n) {
        auto tmp = to_string(n);  // 是正向的string
        int i = tmp.size() - 1;
        while (i > 0 && tmp[i] <= tmp[i - 1]) i--;  // 从i开始递减
        if (i > 0) {
            int j = tmp.size() - 1;
            while (tmp[j] <= tmp[i - 1]) j--;  // 找出需要与i-1交换的
            swap(tmp[i - 1], tmp[j]);
            reverse(tmp.begin() + i, tmp.end());  // 要是最小的那个！
        }
        else return -1;
        auto ans = stol(tmp);
        return ans > INT_MAX ? -1 : ans;
    }
};
交换元素后，需要从
#include <algorithm>  // 对于reverse函数是必须的！！
有问题的写法：
    int nextGreaterElement(int x) {
        vector<int> nums;  // nums是倒着的x
        while (x != 0) {
            nums.push_back(x % 10);
            x /= 10;
        }
        int n = nums.size();
        int i = 0;
        while (i < n - 1 && nums[i] >= nums[i + 1]) i++;  // i->0递减，不能交换
        if (i >= n - 1) return -1;
        int j = 0;
        while (nums[j] >= nums[i + 1]) j++;  // i+1是要交换的，找到第一个比它大的
        swap(nums[j], nums[i + 1]);
        reverse(nums.begin(), nums.begin() + i);

        int ans = 0;
        for (int i = n - 1; i >= 0; i--) ans = ans * 10 + nums[i];
        // return ans > INT_MAX ? -1 : ans;
        return ans;
    }
```



#### [565. 数组嵌套](https://leetcode.cn/problems/array-nesting/)

```C++
class Solution {
public:
    int arrayNesting(vector<int>& nums) {
        int n = nums.size();
        int ans = 0;
        for (int i = 0; i < n; i++) {
            int cur = i, cnt = 0;
            // 访问过的可以跳过，因为是看构成回路
            while (nums[cur] != -1) {
                cnt++;
                int t = cur;
                cur = nums[cur];
                nums[t] = -1;
            }
            ans = max(ans, cnt);
        }
        return ans;
    }
};
```



#### [591. 标签验证器](https://leetcode-cn.com/problems/tag-validator/)：字符串模拟+栈？

> 困难题：

自己写的：但是有点问题。。

```C++
class Solution {
public:
    bool isValid(string code) {
        int n = code.size();
        stack<string> s;
        int i = 0;
        while (i < n) {
            if (code[i] == '<') {
                // if (i == n - 1) return false;
                if (code[i + 1] == '/') {
                    int j = code.find('>', i);
                    if (j == string::npos) return false;
                    string tagName = code.substr(i + 2, j - (i + 2));
                    if (s.empty() || s.top() != tagName) return false;
                    s.pop();
                    i = j + 1;
                    // if (s.empty() && i != n) return false;  // ⭐
                }
                else if (code.substr(i + 1, 8) == "![CDATA[") {
                    int j = code.find("]]>", i);    // 从i之后再找
                    if (j == string::npos) return false;
                    i = j + 3;
                }
                else {
                    int j = code.find('>', i);
                    if (j == string::npos) return false;
                    string tagName = code.substr(i + 2, j - (i + 2));
                    if (tagName.size() < 1 || tagName.size() > 9) return false;
                    for (auto s : tagName) {
                        if (!isupper(s)) return false;
                    }
                    s.push(tagName);
                    i = j + 1;
                }
            }
            else {
                if (s.empty()) return false;
                i++;
            }
        }
        return s.empty();
    }
};
```

评论里面抄来一个：

```C++
bool isValid(string code)
{
    int idx = 0;
    stack<string> tagname;
    while (idx < code.size())
    {
        if (code[idx] == '<')
        {
            idx++;                //跳过<
            if (code[idx] == '/') //结束符
            {
                int start = ++idx; //跳过/
                while (idx < code.size() && code[idx] != '>')
                    idx++;
                if (tagname.empty() || idx == code.size() || code.substr(start, idx - start) != tagname.top()) //没有匹配的开始符或没有>返回false
                    return false;
                tagname.pop();
                idx++; //跳过>
            }
            else if (code[idx] != '!') //开始符
            {
                int start = idx;
                while (idx < code.size() && code[idx] != '>')
                {
                    if (!isupper(code[idx])) //不是大写返回false
                        return false;
                    idx++;
                }
                int len = idx - start;
                if ((start > 1 && tagname.empty()) || idx == code.size() || len > 9 || len == 0) //长度大于9或等于0或没有结束符或当前标签不是第一个且不在任何标签范围内返回false
                    return false;
                tagname.push(code.substr(start, len));
                idx++; //跳过>
            }
            else // cdata
            {
                idx++; //跳过！
                if (tagname.empty() || code.substr(idx, 7) != "[CDATA[")
                    return false;
                idx += 7; //位于[后面一个字符
                while (idx < code.size())
                {
                    if (code.substr(idx, 3) == "]]>")
                        break;
                    idx++;
                }
                if (idx == code.size())
                    return false;
                idx += 3; //跳]]>
            }
        }
        else
        {
            if (tagname.empty()) //当前文字不在标签范围内
                return false;
            idx++;
        }
    }
    return tagname.empty(); //有无未闭合标签
}
```



#### [593. 有效的正方形](https://leetcode.cn/problems/valid-square/)

```C++
class Solution {
public:
    bool isRtTriangle(vector<int>& p1, vector<int>& p2, vector<int>& p3) {
        int d1 = pow(p1[0] - p2[0], 2) + pow(p1[1] - p2[1], 2);
        int d2 = pow(p1[0] - p3[0], 2) + pow(p1[1] - p3[1], 2);
        int d3 = pow(p3[0] - p2[0], 2) + pow(p3[1] - p2[1], 2);
        if ((d3 > d1 && d1 == d2 && d1 + d2 == d3) || (d2 > d1 && d1 == d3 && d1 + d3 == d2) || (d1 > d2 && d2 == d3 && d2 + d3 == d1)) return true;
        return false;

    }
    bool validSquare(vector<int>& p1, vector<int>& p2, vector<int>& p3, vector<int>& p4) {
        return isRtTriangle(p1, p2, p3) && isRtTriangle(p1, p2, p4) && isRtTriangle(p1, p3, p4) && isRtTriangle(p2, p3, p4);
    }
};
```



#### [622. 设计循环队列](https://leetcode.cn/problems/design-circular-queue/)：模拟循环队列

**法1：使用数组直接模拟--****巧妙使用k+1的长度**

```C++
class MyCircularQueue {
private:
    vector<int> cq;
    int g_len;
    int front;
    int end;
public:
    MyCircularQueue(int k) {
        this->g_len = k + 1;
        this->cq = vector<int>(g_len);
        front = 0, end = 0;
    }
    
    bool isEmpty() {
        return front == end;
    }
    
    bool isFull() {
        return ((end + 1) % g_len) == front;
    }
    
    bool enQueue(int value) {
        if (isFull()) return false;
        cq[end] = value;
        end = (end + 1) % g_len;
        return true;
    }
    
    bool deQueue() {
        if (isEmpty()) return false;
        front = (front + 1) % g_len;
        return true;
    }
    
    int Front() {
        if (isEmpty()) return -1;
        return cq[front];
    }
    
    int Rear() {
        if (isEmpty()) return -1;
        // end指向了下一个，所以再绕一圈
        return cq[(end + g_len - 1) % g_len];
    }
};
```

**法2：链表**

```C++
class MyCircularQueue {
private:
    ListNode *head;
    ListNode *tail;
    int capacity;
    int size;

public:
    MyCircularQueue(int k) {
        this->capacity = k;
        this->size = 0;
        this->head = this->tail = nullptr;
    }

    bool enQueue(int value) {
        if (isFull()) return false;
        
        ListNode *node = new ListNode(value);
        if (!head) {
            head = tail = node;
        } else {
            tail->next = node;
            tail = node;
        }
        size++;
        return true;
    }

    bool deQueue() {
        if (isEmpty()) return false;
        ListNode *node = head;
        head = head->next;  
        size--;
        delete node;
        return true;
    }

    int Front() {
        if (isEmpty()) return -1;
        return head->val;
    }

    int Rear() {
        if (isEmpty()) return -1;
        return tail->val;
    }

    bool isEmpty() {
        return size == 0;
    }

    bool isFull() {
        return size == capacity;
    }
};

/**
 * Your MyCircularQueue struct will be instantiated and called as such:
 * MyCircularQueue* obj = myCircularQueueCreate(k);
 * bool param_1 = myCircularQueueEnQueue(obj, value);
 
 * bool param_2 = myCircularQueueDeQueue(obj);
 
 * int param_3 = myCircularQueueFront(obj);
 
 * int param_4 = myCircularQueueRear(obj);
 
 * bool param_5 = myCircularQueueIsEmpty(obj);
 
 * bool param_6 = myCircularQueueIsFull(obj);
 
 * myCircularQueueFree(obj);
*/
typedef struct {
    struct ListNode *head;
    struct ListNode *tail;
    int capacity;
    int size;
} CirQue;


CirQue* cqCreate(int k) {
    CirQue *obj = (CirQue *)malloc(sizeof(CirQue));
    obj->capacity = k;
    obj->size = 0;
    obj->head = obj->tail = NULL;
    return obj;
}

bool cqEnQueue(CirQue* obj, int value) {
    if (obj->size >= obj->capacity) {
        return false;
    }
    struct ListNode *node = (struct ListNode *)malloc(sizeof(struct ListNode));
    node->val = value;
    node->next = NULL;
    if (!obj->head) {
        obj->head = obj->tail = node;
    } else {
        obj->tail->next = node;
        obj->tail = node;
    }
    obj->size++;
    return true;
}

bool cqDeQueue(CirQue* obj) {
    if (obj->size == 0) {
        return false;
    }
    struct ListNode *node = obj->head;
    obj->head = obj->head->next;  
    obj->size--;
    free(node);
    return true;
}

int cqFront(CirQue* obj) {
    if (obj->size == 0) {
        return -1;
    }
    return obj->head->val;
}

int cqRear(CirQue* obj) {
    if (obj->size == 0) {
        return -1;
    }
    return obj->tail->val;
}

bool cqIsEmpty(CirQue* obj) {
    return obj->size == 0;
}

bool cqIsFull(CirQue* obj) {
    return obj->size == obj->capacity;
}

void cqFree(CirQue* obj) {
    for (struct ListNode *curr = obj->head; curr;) {
        struct ListNode *node = curr;
        curr = curr->next;
        free(node);
    }
    free(obj);
}
```



#### [640. 求解方程](https://leetcode.cn/problems/solve-the-equation/)：移项解方程

```C++
class Solution {
public:
    // k * x + a = 0
    string solveEquation(string eq) {
        int k = 0, a = 0;
        int n = eq.size();
        for (int i = 0, op = 1; i < n;) {
            if (eq[i] == '+') {
                op = 1; i++;
            } else if (eq[i] == '-') {
                op = -1; i++;
            } else if (eq[i] == '=') {
                k *= -1; a *= -1;
                op = 1; i++;
            } else {
                int j = i;
                while (j < n && isdigit(eq[j])) j++;
                if (eq[j] == 'x') {
                    // kx
                    if (j == i) k += 1 * op;
                    else k += stoi(eq.substr(i, j - i)) * op;
                    i = j + 1;
                } else {
                    // a
                    a += stoi(eq.substr(i, j - i)) * op;
                    i = j;
                }
            }
        }

        if (k == 0) return a == 0 ? "Infinite solutions" : "No solution";
        else return "x=" + to_string(-a / k);
    }
};
```



#### [699. 掉落的方块](https://leetcode.cn/problems/falling-squares/)：暴力求解俄罗斯方块

> 思路是怎么想到的？

> 一个格子落到其他格子上面以后，后来的格子就只能继续向上堆。所以我们可以把已经落稳了的格子，变成长方形，且把与其有交集格子中重叠的部分覆盖了：如图

> ![img](https://uestc.feishu.cn/space/api/box/stream/download/asynccode/?code=NWQ2MWUxNmQ5ZWNkMGZkZWViNzk1OTVhNjgwODFkMGVfaTRPQ0lTUGpJT0Jic05lT2wxWlJwaWViREJtWkR4cnZfVG9rZW46Ym94Y25hZ1lkUXFuc20zQjN6S21xd01wTHdnXzE2NjI2NDE5MTE6MTY2MjY0NTUxMV9WNA)

```C++
class Solution {
public:
    struct Margin {
        int left;
        int right;
        int height;
        Margin(int l, int r, int h): left(l), right(r), height(h) {}
    };
    vector<int> fallingSquares(vector<vector<int>>& pos) {
        int n = pos.size();
        int maxHeight = 0;
        vector<Margin> margs;
        vector<int> ans;

        for (int i = 0; i < n; i++) {  // 遍历每个正方形
            int l = pos[i][0], h = pos[i][1], r = l + h;
            int curMaxh = 0;
            for (Margin m : margs) {
                if (m.left >= r || m.right <= l) continue;  // 正好错开
                curMaxh = max(curMaxh, m.height);  // 需要垒，那就求出当前最高
            }
            int curHeight = curMaxh + h;
            margs.push_back(Margin(l, r, curHeight));  // 存的是矩形投影区域
            maxHeight = max(maxHeight, curHeight);
            ans.push_back(maxHeight);
        }
        return ans;
    }
};
```

**注意定义一个struct后怎么初始化之类的！！**



#### [748. 最短补全词](https://leetcode-cn.com/problems/shortest-completing-word/)：if not counter()相减

```C++
class Solution {
public:
    // 官方题解
    string shortestCompletingWord(string licensePlate, vector<string> &words) {
        array<int, 26> cnt{};
        for (char ch : licensePlate) {
            if (isalpha(ch)) {
                ++cnt[tolower(ch) - 'a'];
            }
        }
        int idx = -1;
        for (int i = 0; i < words.size(); ++i) {
            array<int, 26> word_cnt{};
            for (char ch : words[i])
                ++word_cnt[ch - 'a'];

            bool isComplete = true;
            for (int j = 0; j < 26; ++j) {
                if (word_cnt[j] < cnt[j]) {
                    isComplete = false;
                    break;
                }
            }
            if (isComplete && (idx ==-1 || words[i].size() < words[idx].size()))
            // 注意这里idx的判断和size判断的顺序不能写反！！⭐
                idx = i;
        }
        return words[idx];
    }
};
class Solution:
    # python官方解答极度简洁
    def shortestCompletingWord(self, licensePlate: str, words: List[str]) -> str:
        cnt = Counter(ch.lower() for ch in licensePlate if ch.isalpha())
        return min((word for word in words if not cnt-Counter(word)),key=len)
```



#### [794. 有效的井字游戏](https://leetcode-cn.com/problems/valid-tic-tac-toe-state/)：井字模拟

```C++
class Solution {
public:
    bool validTicTacToe(vector<string>& board) {
        int numX = 0, numO = 0;
        for(auto row : board){
            for(auto i : row){
                if(i == 'X') numX++;
                if(i == 'O') numO++;
            }
        }

        if(numX != numO && numX != numO + 1) return false;
        if(checkWin(board, 'X') && numX != numO + 1) return false;
        if(checkWin(board, 'O') && numX != numO) return false;
        else
            return true;
    }

    bool checkWin(vector<string>& board, char p) {
        for(int i = 0; i < 3; ++i){
            if(board[i][0] == p && board[i][1] == p && board[i][2] == p)
                return true;
            if(board[0][i] == p && board[1][i] == p && board[2][i] == p)
                return true;
        }
        if(board[0][0] == p && board[1][1] == p && board[2][2] == p)
            return true;
        if(board[0][2] == p && board[1][1] == p && board[2][0] == p)
            return true;
        else
            return false;
    }
};
```



#### [812. 最大三角形面积](https://leetcode.cn/problems/largest-triangle-area/)：用坐标求三角形面积

**法1：海伦公式**

![img](https://uestc.feishu.cn/space/api/box/stream/download/asynccode/?code=ZDkzOTJkMzM4MzQ0NDhkNGI4NzNkMjA1YWMzMWZmMGJfYXdyWGxKc1luMkRuVXloc0NxYXdUdnd1UzQ0MXpaSGJfVG9rZW46Ym94Y25adktHd2lXUGM1SHFJaUdoN29PT2tmXzE2NjI2NDE5MTE6MTY2MjY0NTUxMV9WNA)

```C++
class Solution {
public:
    double getLen(vector<int>& a, vector<int>& b) {
        return sqrt(pow(a[0] - b[0], 2) + pow(a[1] - b[1], 2));
    }
    double getArea(double a, double b, double c) {
        double p = (a + b + c) / 2;
        return sqrt(p * (p - a) * (p - b) * (p - c));
    }
    double largestTriangleArea(vector<vector<int>>& points) {
        double ans = 0.0;
        for (auto &A : points) {
            for (auto &B : points) {
                for (auto &C : points) {
                    double a = getLen(B, C), b = getLen(A, C), c = getLen(A, B); 
                    ans = max(ans, getArea(a, b, c));
                }
            }
        }
        return ans;
    }
};
```

**法2：向量叉乘**

![img](https://uestc.feishu.cn/space/api/box/stream/download/asynccode/?code=MjJkOWE3NTNmYTE1Mjk2ZTYxMDVkYTk5Y2FjMmFlZGNfaURLWWh1UmRrYmRYOVF6Skx6R0RNNUFualZaNjlMSUZfVG9rZW46Ym94Y25uQlM0ejNLYVhSNEZwOTJreWFBZU10XzE2NjI2NDE5MTE6MTY2MjY0NTUxMV9WNA)

**法3：S=1/2 \* a \* b \* sinC**



#### [828. 统计子串中的唯一字符](https://leetcode.cn/problems/count-unique-characters-of-all-substrings-of-a-given-string/)：模拟+乘法原理

**困难题：**原问题为求**所有子串的唯一字符数量和**，其可等价为**求每个s[i]对答案的贡献**，**即每个s[i]可作为多少个子数组的唯一元素。**

- > "ABC"-----1 + 1 + 1 + 2 + 2 + 3 = 10（1*3+2*2+3*1）

- > "ABA"-----8（1*2+2*2+2*1）

假定我们能预处理出两数组 l 和 r 分别代表s[i]作为子数组唯一字符时，其所能到达的最远两端：

- l[i] = a 代表a为s[i]能够作为子数组唯一字符时的**最远左边界下标**，即为s[i]左边第一个与s[i]值相同的位置（若不存在，则为a=-1）
- r[i] = b 代表b为s[i]能够作为子数组唯一字符时的**最远右边界下标**，即为s[i]右边第一个与s[i]值相同的位置（若不存在，则为 b=n）

子数组左端点个数为(i-a)个，右端点个数为(b-i)个，根据乘法原理可知，子数组个数为两者乘积。

> 左：A_，中连B，右：_C，相乘2*2

> 左：A_，中连B，右：_，相乘2*1

**预处理 l 和 r 只需要使用遍历计数即可。（很关键！！）**

```Java
class Solution {
public:
    int uniqueLetterString(string s) {
        int n = s.size();
        // l[i]：s[i]左边第一个与s[i]值相同的下标
        // r[i]：s[i]右边第一个与s[i]值相同的下标
        vector<int> l(n), r(n);
        vector<int> cnt(26, -1);    // 记录字母最新一次出现的下标
        for (int i = 0; i < n; i++) {
            l[i] = cnt[s[i] - 'A'];
            cnt[s[i] - 'A'] = i;
        }
        cnt = vector<int>(26, n);
        for (int i = n - 1; i >= 0; i--) {
            r[i] = cnt[s[i] - 'A'];
            cnt[s[i] - 'A'] = i;
        }

        int ans = 0;
        for (int i = 0; i < n; i++) {
            ans += (i - l[i]) * (r[i] - i);
        }
        return ans;
    }
};
```



#### [846. 一手顺子](https://leetcode-cn.com/problems/hand-of-straights/)：优先队列(堆)+哈希

注意取牌，检查能否组成顺子时的思路⭐

```C++
class Solution {
public:
    bool isNStraightHand(vector<int>& hand, int groupSize) {
        unordered_map<int, int> cnt;  // 某数值和数量的对应关系
        priority_queue<int, vector<int>, greater<int>> q;  // 升序队列
        for (auto c: hand) {  // 存进去
            cnt[c]++;
            q.push(c);
        }

        while(!q.empty()) {
            int c = q.top();
            q.pop();
            // 牌已经被取出
            // 我们只需要每次从堆中取出一张牌
            // 检查相邻的groupsize张是否存在，如果存在就将对应该数值的计数器减1即可
            if (cnt[c] != 0) {
                for (int x = 0; x < groupSize; x++) {  // 检查能否顺子
                    if (cnt[c+x] == 0) return false;
                    cnt[c+x]--;  // 计数器减1，等价于取出牌
                }
            }
        }
        return true;
    }
};
```



#### [868. 二进制间距](https://leetcode-cn.com/problems/binary-gap/)：直接遍历，简单模拟

![img](https://uestc.feishu.cn/space/api/box/stream/download/asynccode/?code=NGU5ZTAwNTg3NWViNmZjM2FkZjFhNTY2ZTdjZWI5NDVfWjZwRm1KbXVQcW9TajFvTVFQSkxYNkE2MHV3Y3ZsOG1fVG9rZW46Ym94Y25DVWl1S3ZuZmpaczZ1Yll2a09FVU9jXzE2NjI2NDE5MTE6MTY2MjY0NTUxMV9WNA)

```C++
class Solution {
public:
    // 直接遍历：遍历n的二进制中的每一位i，同时记录上一位1的位置j
    int binaryGap(int n) {
        int ans = 0;
        for (int i = 31, j = -1; i >= 0; i--) {
            if (((n >> i) & 1) == 1) {
                if (j != -1) ans = max(ans, j - i);
                j = i;
            }
        }
        return ans;
    }
};
#include <cmath>    // 如果加上一个没有太大必要的操作
int binaryGap(int n) {
    ...
    for (int i = (int)(log(n) / log(2)), j = -1; i >= 0; i--) {...}
}
```



#### [883. 三维形体投影面积](https://leetcode-cn.com/problems/projection-area-of-3d-shapes/)：投影

![img](https://uestc.feishu.cn/space/api/box/stream/download/asynccode/?code=NmI3NjJiMzNjMDQ1MjQzYmE3MjFkNGM4ZDFiZmI2YzNfeTJLNnIxQUt6SFo4ZXVyYnlPVHc3NTd6Rkd5WTcyelJfVG9rZW46Ym94Y25YcnNyNDBCc3NDT1E1V3ZJdnh6Q0hnXzE2NjI2NDE5MTE6MTY2MjY0NTUxMV9WNA)

> 输入的是某坐标的v值，直接遍历输入的列表即可；

> 侥幸地，因为行列数量一样可以这么操作。。。

使用三个变量分别统计三视图的阴影面积：

- ans1：统计俯视图的面积，共有n∗n 个位置需要被统计，当任意格子g[i][j]>0，面积+1；
- ans2：统计左视图的面积，共有n行需要被统计，每一行对 ans2 的贡献为该行的最大高度；
- ans3：统计主视图的面积，共有n列需要被统计，每一列对 ans3 的贡献为该列的最大高度。

```C++
class Solution {
public:
    int projectionArea(vector<vector<int>>& grid) {
        int s1 = 0, s2 = 0, s3 = 0;
        int n = grid.size();
        for (int i = 0; i < n; ++i) {
            int a = 0, b = 0;
            for (int j = 0; j < n; ++j) {
                if (grid[i][j] > 0) s1++;
                a = max(a, grid[i][j]);
                b = max(b, grid[j][i]);
            }
            s2 += a;
            s3 += b;
        }
        return s1 + s2 + s3;
    }
};
```



#### [890. 查找和替换模式](https://leetcode.cn/problems/find-and-replace-pattern/)：映射

> 根据题意，我们需要构造从字母到字母的双射，

```C++
class Solution {
public:
    bool isMatch(string word, string pattern) {
        unordered_map<int, int> map;
        int m = word.size();
        for (int i = 0; i < m; i++) {
            if (map.find(word[i] - 'a') == map.end()) {
                map[word[i] - 'a'] = pattern[i] - 'a';
            }
            else {
                if (map[word[i] - 'a'] != pattern[i] - 'a')
                    return false;
            }
        }
        return true;
    }
    vector<string> findAndReplacePattern(vector<string>& words, string pattern) {
        vector<string> res;
        for (auto word : words) {
            if (isMatch(word, pattern) && isMatch(pattern, word))
                res.push_back(word);
        }
        return res;
    }
};
```



#### [905. 按奇偶排序数组](https://leetcode-cn.com/problems/sort-array-by-parity/)：

```C++
class Solution {
public:
    // 遍历一趟，双指针
    vector<int> sortArrayByParity(vector<int>& nums) {
        int n = nums.size();
        for (int i = 0, j = n - 1; i < j; ++i) {
            if (nums[i] % 2 == 1) {
                int t = nums[i];
                nums[i--] = nums[j];
                nums[j--] = t;
            }
        }
        return nums;
    }
};
```



#### [929. 独特的电子邮件地址](https://leetcode.cn/problems/unique-email-addresses/)：字符串模拟

```C++
class Solution {
public:
    int numUniqueEmails(vector<string>& emails) {
        set<string> getMail;
        for (auto e : emails) {
            string mail;
            int n = e.size(), i = 0;
            bool flag = false;
            while (i < n) {
                if (e[i] == '@') break;  // @之后直接substr
                if (e[i] == '.' && ++i > 0) continue;
                if (e[i] == '+') flag = true;
                if (!flag) mail += e[i];
                i++;
            }
            // mail.append(e.substr(i));
            getMail.insert(mail + e.substr(i));
        }
        return getMail.size();
    }
};
```





#### [944. 删列造序](https://leetcode.cn/problems/delete-columns-to-make-sorted/)：直接按列遍历

```C++
class Solution {
public:
    int minDeletionSize(vector<string>& strs) {
        int m = strs.size(), n = strs[0].size();  // m行n列
        int ans = 0;
        for (int j = 0; j < n; j++) {
            for (int i = 0; i < m - 1; i++) {
                if (strs[i][j] > strs[i + 1][j]) {
                    ans++;
                    break;
                }
            }
        }
        return ans;
    }
};
```



#### [953. 验证外星语词典](https://leetcode.cn/problems/verifying-an-alien-dictionary/)：

> 题意很是有问题！！不多纠结了

> 根据字典序，逐位进行比较？都不是：相当于查字典？

```C++
class Solution {
public:
    bool isAlienSorted(vector<string>& words, string order) {
        unordered_map<char, int> mp;  // 直接上哈希表
        int n = words.size();
        for (int i = 0; i < 26; i++) {
            mp[order[i]] = i;
        }
        for (int i = 0; i < n - 1; i++) {
            string w0 = words[i], w1 = words[i + 1];
            int l0 = w0.size(), l1 = w1.size();
            bool flag = false;
            for (int j = 0; j < l0 && j < l1; j++) {
                if (mp[w0[j]] < mp[w1[j]]) {
                    flag = true;
                    break;
                }
                else if (mp[w0[j]] > mp[w1[j]])
                    return false;
            }
            if (flag == false && l0 > l1) return false;
        }
        return true;
    }
};
```

补充一种写法：自定义排序。。。

```C++
class Solution {
public:
    unordered_map<char, int> ord;
    int check(string a, string b) {
        int m = a.size(), n = b.size();
        int i = 0, j = 0;
        while (i < m && j < n) {
            if (a[i] != b[j]) return ord[a[i]] - ord[b[j]];
            i++, j++;
        }
        if (i < m) return 1;
        if (j < n) return -1;
        return 0;
    }
    bool isAlienSorted(vector<string>& words, string order) {
        int n = words.size();
        for (int i = 0; i < 26; i++) {
            ord[order[i]] = i;
        }
        for (int i = 0; i < n - 1; i++) {
            if (check(words[i], words[i + 1]) > 0) return false;
        }
        return true;
    }
};
```



#### [961. 在长度 2N 的数组中找出重复 N 次的元素](https://leetcode.cn/problems/n-repeated-element-in-size-2n-array/)

> 似乎过分简单了：2n = (n + 1) + (n - 1)

- > 不重复的那个一定是只出现了一次！

```C++
int repeatedNTimes(vector<int>& nums) {
    int cnt[10001] = {0};  //数据范围<=10^4
    for (int n : nums) {
        if (++cnt[n] > 1) return n;
    }
    return -1;
}
```



#### [997. 找到小镇的法官](https://leetcode-cn.com/problems/find-the-town-judge/)：入度出度

python的解法看起来更方便

```Python
class Solution:
    def findJudge(self, n: int, trust: List[List[int]]) -> int:
        inDg = Counter(y for _,y in trust)
        outDg = Counter(x for x,_ in trust)
        for i in range(1, n + 1):
            if inDg[i] == n - 1 and outDg[i] == 0:
                return i
        return -1
```



#### [1051. 高度检查器](https://leetcode.cn/problems/height-checker/)：简单排序模拟



#### [1078. Bigram 分词](https://leetcode-cn.com/problems/occurrences-after-bigram/)：自己写一个C++分词吧

如果用C++实现本题，问题在于如何将text分词成为一个动态数组words？

```C++
class Solution {
public:
    // 可惜C++没有分割字符串的方法？
    vector<string> findOcurrences(string text, string first, string second) {
        vector<string> words;
        int start = 0;
        int len = text.size();
        for(int i = 0; i < len; ++i) {
            if(text[i] == ' ') {
                words.push_back(text.substr(start, i - start));
                start = i + 1;
            }
        }
        words.push_back(text.substr(start, len - start));

        vector<string> ans;
        int n = words.size();
        for (int i = 2; i < n; i++) {
            if (words[i - 2] == first && words[i - 1] == second)
                ans.push_back(words[i]);
        }
        return ans;
    }
};
```

python解法注意**enumerate**的用法

```Python
class Solution:
    def findOcurrences(self, text: str, first: str, second: str) -> List[str]:
        ans = []
        words = text.split(" ")
        for i,_ in enumerate(words):
            if i < len(words)-2 and words[i] == first and words[i+1] == second:
                ans.append(words[i+2])
        return ans

# class Solution:
#     def findOcurrences(self, text: str, first: str, second: str) -> List[str]:
#         words = text.split()
#         return [words[i] for i in range(2, len(words)) if words[i - 2] == first and words[i - 1] == second]
```

![img](https://uestc.feishu.cn/space/api/box/stream/download/asynccode/?code=YWU3MDMzYTkwZDUxZTUzMDk1ZTNlNDBlMzYxYTM5ZDhfd0ZPaXlDZTlEaVlUSU9kMVZwQkl1UjRTMzBBV0RWTGtfVG9rZW46Ym94Y25aWmdncXpPNTRZTHhkbFQ2Z2tHa21jXzE2NjI2NDE5MTE6MTY2MjY0NTUxMV9WNA)



#### [1154. 一年中的第几天](https://leetcode-cn.com/problems/day-of-the-year/)：4年一闰，百年不闰

```C++
class Solution {
public:
    int dayOfYear(string date) {
        int days[12] = {31,28,31,30,31,30,31,31,30,31,30,31};       
        string yy = date.substr(0, 4);
        string mm = date.substr(5, 2);
        string dd = date.substr(8, 2);
        int y = stoi(yy), m = stoi(mm), d = stoi(dd);
        int ans = 0;
        if (((y%4==0)&&(y%100!=0))||(y%400==0)) days[1]++;
        for (int i = 0; i < m - 1; i++) ans += days[i];
        ans += d;
        return ans;
    }
};
class Solution:
    def dayOfYear(self, date: str) -> int:
        year, month, day = [int(_) for _ in date.split("-")]
        amount = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31]
        if year % 400 == 0 or (year % 4 == 0 and year % 100 != 0):
            amount[1] += 1
        ans = sum(amount[:month - 1])
        return ans + day
```



#### [1108. IP 地址无效化](https://leetcode.cn/problems/defanging-an-ip-address/)：字符串模拟

> 字符串添加字符！

```C++
class Solution {
public:
    string defangIPaddr(string address) {
        string ans;
        for (auto a : address) {
            if (a == '.') ans.append("[.]");
            else ans.push_back(a);
        }
        return ans;
    }
};
```



#### [1175. 质数排列](https://leetcode.cn/problems/prime-arrangements/)：找质数+阶乘

```C++
const int MOD = 1e9 + 7;

class Solution {
public:
    // 质数在质数的位置上-->全排列
    long getFactorial(int n) {
        long res = 1;
        for (int i = 1; i <= n; i++) {
            res *= i;
            res %= MOD;
        }
        return res;
    }
    bool isPrime(int n) {
        if (n == 1) return false;
        for (int i = 2; i <= sqrt(n); i++) {
            if (n % i == 0) return false;
        }
        return true;
    }
    int numPrimeArrangements(int n) {
        int primeCnt = 0;
        for (int i = 1; i <= n; i++) {
            if (isPrime(i)) primeCnt++;
        }
        int ans = (int)(getFactorial(primeCnt) * getFactorial(n - primeCnt) % MOD);
        return ans;
    }
};
```



#### [1184. 公交站间的距离](https://leetcode.cn/problems/distance-between-bus-stops/)

> 直接双指针，前后方向进行遍历

```C++
class Solution {
public:
    int distanceBetweenBusStops(vector<int>& distance, int start, int destination) {
        int n = distance.size();
        int i = start, j = start;
        int ans1 = 0, ans2 = 0;
        while (i != destination) {
            ans1 += distance[i];
            if (++i == n) i = 0;
        }
        while (j != destination) {
            if (--j < 0) j = n - 1;
            ans2 += distance[j];
        }
        return min(ans1, ans2);
    }
};
```







#### [1189. “气球” 的最大数量](https://leetcode-cn.com/problems/maximum-number-of-balloons/)：统计词频计数

![img](https://uestc.feishu.cn/space/api/box/stream/download/asynccode/?code=MDI2NDNmNmFkYzZhMjBiM2ZkNmZhMWIxYjljNjQxMjhfRHR4VEdjZUF1d3pZWnlGeU00dENBNlFBSHpYWW9IRURfVG9rZW46Ym94Y256YXRrMEVnZ1pnb2ZlWVZ0bjEyVEJiXzE2NjI2NDE5MTE6MTY2MjY0NTUxMV9WNA)

```C++
class Solution {
public:
    // 就是统计词频，balloon: a:1, b:1, l:2, n:1, o:2
    int maxNumberOfBalloons(string text) {
        int cnt[5] = {0};
        for (auto c : text) {
            if (c == 'b') cnt[0]++;
            else if (c == 'a') cnt[1]++;
            else if (c == 'l') cnt[2]++;
            else if (c == 'o') cnt[3]++;
            else if (c == 'n') cnt[4]++;
        }
        cnt[2] /= 2, cnt[3] /= 2;
        int ans = cnt[0];
        for (int i = 0; i < 5; i++)
            ans = min(ans, cnt[i]);
        return ans;
    }
};
class Solution:
    def maxNumberOfBalloons(self, text: str) -> int:
        cnt = Counter(ch for ch in text if ch in "balon")
        cnt['l'] //= 2
        cnt['o'] //= 2
        return min(cnt.values()) if len(cnt) == 5 else 0
```



#### [1200. 最小绝对差](https://leetcode.cn/problems/minimum-absolute-difference/)

```C++
#include <limits.h>
class Solution {
public:
    vector<vector<int>> minimumAbsDifference(vector<int>& arr) {
        int n = arr.size();
        sort(arr.begin(), arr.end());

        int abs = INT_MAX;
        vector<vector<int>> ans;
        for (int i = 0; i < n - 1; i++) {
            int cur = arr[i + 1] - arr[i];
            vector<int> tmp = vector<int>{arr[i], arr[i + 1]};
            if (cur < abs) {
                abs = cur;
                // ans = {{arr[i], arr[i + 1]}};
                ans.clear();
                ans.push_back(tmp);
            }
            else if (cur == abs) {
                // ans.emplace_back(arr[i], arr[i + 1]);
                ans.push_back(tmp);
            }
        }
        return ans;
    }
};
class Solution {
public:
    vector<vector<int>> minimumAbsDifference(vector<int>& arr) {
        sort(arr.begin(), arr.end());
        int n = arr.size();
        int minDiff = INT_MAX;
        vector<vector<int>> ans;
        for (int i = 0; i < n - 1; ++i) {
            int diff = arr[i + 1] - arr[i];
            // 如果差值小于最小差值，ans中的都不满足直接clear，如果等于最小差值，则将该数对加入
            if (diff <= minDiff) {
                if (diff < minDiff) {
                    minDiff = diff;
                    ans.clear();
                }
                ans.push_back({arr[i], arr[i + 1]});
            }
        }
        return ans;
    }
};
这是另一种看起来更好的写法，几乎完全一样
```



#### [1224. 最大相等频率](https://leetcode.cn/problems/maximum-equal-frequency/)：直接计数模拟 or 哈希

**困难题：【三叶の题解】**

我们**使用 cnt 数组记录每个数的出现次数**（即 cnt[i] = x 含义为数值 i 的出现次数为 x 次），以及**使用 sum 来记录出现次数为某个值的数有多少个**（即 sum[i] = x 含义为出现次数为 i 的数值共有 x 个），同时**使用 max 来记录最大出现次数** **cnt[i]**。

从前往后处理 nums，假设当前处理到的数值为 t=nums[i]（前缀所含数量为 len=i+1），有如下几种情况，我们可以**更新最大长度 ans**：

- `max=1`：说明当前处理到的所有 nums[i] 均只出现了一次，此时任意删除一个均满足要求；
- `max*sum[max]+1=len`：说明有一个数值单独出现了一次（其余出现次数为 max 的数值 + 被删除的一个数 = 总数量 len），删除后即满足要求；
- `(max−1)*(sum[max−1]+1)+1=len`：说明出现次数为 max 的数值只有一个，其余出现次数均为 max - 1，对其删除一次后即满足要求（删除该出现次数为 max 的数值后，会导致出现次数为 max - 1 的数值多一个，此时有「出现次数为 max - 1 的数值 + 被删除的一个数 = 总数量 len」）。

```C++
class Solution {
public:
    int maxEqualFreq(vector<int>& nums) {
        int cnt[100010] = {0};
        int sum[100010] = {0};
        int n = nums.size();
        int maxcnt = 0, ans = 0;

        for (int i = 0; i < n; i++) {
            int t = nums[i];        // 当前数字是t
            int cur = ++ cnt[t];    // 数字t出现次数cur
            int len = i + 1;        // 当前前缀长度
            sum[cur]++; sum[cur - 1]--;     // 出现cur和cur-1次的数有几个都要变
            maxcnt = max(maxcnt, cur);      // 出现最多的次数是maxcnt

            if (maxcnt == 1) ans = len;
            if (maxcnt * sum[maxcnt] + 1 == len) ans = len;
            if ((maxcnt - 1) * (sum[maxcnt - 1] + 1) + 1 == len) ans = len;
        }
        return ans;
    }
};
```





#### [1260. 二维网格迁移](https://leetcode.cn/problems/shift-2d-grid/)：二维数组一维展开

> 将二维数组元素依次向后迁移k步

```C++
class Solution {
public:
    vector<vector<int>> shiftGrid(vector<vector<int>>& grid, int k) {
        int m = grid.size(), n = grid[0].size();
        vector<vector<int>> ans(m, vector<int>(n));
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                int idx = (i * n + j + k) % (m * n);
                ans[idx / n][idx % n] = grid[i][j];
            }
        }
        return ans;
    }
};
```





#### [1342. 将数字变成 0 的操作次数](https://leetcode-cn.com/problems/number-of-steps-to-reduce-a-number-to-zero/)：简单数学计算，是奇是偶

```Dart
class Solution {
public:
    int numberOfSteps(int num) {
        int ans = 0;
        while(num != 0) {
            num = num % 2 == 0 ? num / 2 : num - 1;
            ans++;
        }
        return ans;
    }
};
```



#### [1380. 矩阵中的幸运数](https://leetcode-cn.com/problems/lucky-numbers-in-a-matrix/)：联想到807.城市天际线

![img](https://uestc.feishu.cn/space/api/box/stream/download/asynccode/?code=YjIwOTBkM2IxMmVmMjQ1ZDQxYjY2MmNkZDcxNzdiMDVfQXlHR2gyVGlYVUpQb3NpRU1BNHlCeU96enl4SXY1d01fVG9rZW46Ym94Y25yVEZUS3VIOFRJT3l1eGxXNVZCRFJnXzE2NjI2NDE5MTE6MTY2MjY0NTUxMV9WNA)

**注意C++和Python中无穷大、无穷小的写法**

```C++
class Solution {
public:
    vector<int> luckyNumbers (vector<vector<int>>& matrix) {
        int m = matrix.size(), n = matrix[0].size();  // m行n列
        vector<int> rowMin(m, INT_MAX);
        vector<int> colMax(n, INT_MIN);
        for (int i = 0; i < m; ++i) {
            for (int j = 0; j < n; ++j) {
                rowMin[i] = min(rowMin[i], matrix[i][j]);
                colMax[j] = max(colMax[j], matrix[i][j]);
            }
        }
        vector<int> ans;
        for (int i = 0; i < m; ++i) {
            for (int j = 0; j < n; ++j) {
                if (matrix[i][j] == rowMin[i] && matrix[i][j] == colMax[j])
                    ans.push_back(matrix[i][j]);
            }
        }
        return ans;
    }
};
class Solution:
    def luckyNumbers (self, matrix: List[List[int]]) -> List[int]:
        m, n = len(matrix), len(matrix[0])
        rowMin = [float('inf') for _ in range(m)]
        colMax = [float('-inf') for _ in range(n)]
        for i in range(m):
            for j in range(n):
                rowMin[i] = min(rowMin[i], matrix[i][j])
                colMax[j] = max(colMax[j], matrix[i][j])
        ans = []
        for i in range(m):
            for j in range(n):
                if matrix[i][j] == rowMin[i] and matrix[i][j] == colMax[j]:
                    ans.append(matrix[i][j])
        return ans
```



#### [1374. 生成每种字符都是奇数个的字符串](https://leetcode.cn/problems/generate-a-string-with-characters-that-have-odd-counts/)

```C++
class Solution {
public:
    string generateTheString(int n) {
        if (n % 2 == 1) return string(n, 'a');
        else return string(n - 1, 'a') + 'b';
    }
};
```



#### [1408. 数组中的字符串匹配](https://leetcode.cn/problems/string-matching-in-an-array/)

> 判断是否包含子串：直接遍历，`words[j].find(words[i]) != string::npos`

```C++
class Solution {
public:
    vector<string> stringMatching(vector<string>& words) {
        vector<string> ans;
        int n = words.size();
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                if (i == j) continue;
                if (words[j].find(words[i]) != string::npos) {
                    ans.push_back(words[i]);
                    break;
                }
            }
        }
        return ans;
    }
};
```



#### [1413. 逐步求和得到正数的最小值](https://leetcode.cn/problems/minimum-value-to-get-positive-step-by-step-sum/)

> 巧妙利用，每次求最小的累计和

```C++
class Solution {
public:
    int minStartValue(vector<int>& nums) {
        int n = nums.size();
        int ans = INT_MAX;
        for (int i = 0, j = 1; i < n; i++) {
            j = j + nums[i];
            ans = min(ans, j);
        }
        return ans < 1 ? 2 - ans : 1;
    }
};
```



#### [1417. 重新格式化字符串](https://leetcode.cn/problems/reformat-the-string/)

```TypeScript
class Solution {
public:
    string reformat(string s) {
        string digit;
        string chara;
        for (auto c : s) {
            if (c >= 'a' && c <= 'z') chara += c;
            else digit += c;
        }
        if (digit.size() < chara.size()) swap(digit, chara);
        int m = digit.size(), n = chara.size();
        int len = m + n;
        if (m - n > 1) return "";

        string ans;
        for (int i = 0; i < len; i++) {
            if (i % 2 == 0) ans += digit[--m];
            else ans += chara[--n];
        }
        return ans;
    }
};
```



#### [1422. 分割字符串的最大得分](https://leetcode.cn/problems/maximum-score-after-splitting-a-string/)：前缀和 or 直接模拟

**法1：前缀和**

构建前缀和数组来记录每个前缀中1的个数，复杂度为O(n)，枚举每个分割点，搭配前缀和数组计算左串中0的数量和右串中1的数量，取所有得分的最大值即是答案。

```C++
class Solution {
public:
    int maxScore(string s) {
        int n = s.size();
        vector<int> sum(n + 1);     // 前缀和 sum[i]是第i个前1的个数
        int ans = 0;
        for (int i = 1; i <= n; i++) sum[i] = sum[i - 1] + (s[i - 1] - '0');
        for (int i = 1; i <= n - 1; i++) {
            int a = i - sum[i];
            int b = sum[n] - sum[i];
            ans = max(ans, a + b);
        }
        return ans;
    }
};
```

**法2：直接模拟**

```C++
class Solution {
public:
    int maxScore(string s) {
        int n = s.size();
        int cur = (s[0] == '0');
        for (int i = 1; i < n; i++) cur += (s[i] == '1');
        int ans = cur;      // 初始，从第一个划分
        for (int i = 1; i < n - 1; i++) {
            cur += (s[i] == '0' ? 1 : -1);      // 有一个1从右串中移到了左串？
            ans = max(ans, cur);
        }
        return ans;
    }
};
```





#### 1436.旅行终点站：哈希表，for(auto i : v)

```C++
// 官方题解，建议看原题记录
class Solution {
public:
    string destCity(vector<vector<string>>& paths) {
        unordered_set<string> citiesA;
        for (auto &path : paths) { //for (auto path : paths)看起来也行
            citiesA.insert(path[0]);
        }
        for (auto &path : paths) {
            if (!citiesA.count(path[1])) {
                return path[1];
            }
        }
        return "";
    }
};
class Solution {
public:
    string destCity(vector<vector<string>>& paths) {
        unordered_map<string, int> out; //out 记录出度
        for (auto &p : paths) {
            out[p[0]]++; //out[p[1]]不变，见演草本的例子
        }
        // for (auto [a,b] : out) 这是错误的
        for (auto p : paths) {
            if (out[p[1]] == 0) {
                // return out[a];❌
                return p[1]; //注意，是把对应的城市名返回，类型string
            }
        }
        return "";
    }
};
```



#### [1450. 在既定时间做作业的学生人数](https://leetcode.cn/problems/number-of-students-doing-homework-at-a-given-time/)

```C++
class Solution {
public:
    int busyStudent(vector<int>& startTime, vector<int>& endTime, int queryTime) {
        int ans = 0;
        int n = startTime.size();
        for (int i = 0; i < n; i++) {
            if (queryTime >= startTime[i] && queryTime <= endTime[i]) ans++;
        }
        return ans;
    }
};
```

 

#### [1455. 检查单词是否为句中其他单词的前缀](https://leetcode.cn/problems/check-if-a-word-occurs-as-a-prefix-of-any-word-in-a-sentence/)：类似于手动分词

> 这一题不能直接找是否包含searchword，因为是判断是否是前缀！

> 不如硬做：直接条件判断

```C++
class Solution {
public:
    int isPrefixOfWord(string sentence, string searchWord) {
        int idx = 1;
        int n = sentence.size(), m = searchWord.size();
        for (int i = 0; i < n; i++) {
            if (sentence[i] == ' ') idx++;
            if (i == 0 && sentence.substr(i, m) == searchWord) return idx;
            if (i > 0 && sentence[i - 1] == ' ' && sentence.substr(i, m) == searchWord) return idx;
        }
        return -1;
    }
};
```



#### [1460. 通过翻转子数组使两个数组相等](https://leetcode.cn/problems/make-two-arrays-equal-by-reversing-sub-arrays/)：统计词频

```C++
class Solution {
public:
    bool canBeEqual(vector<int>& target, vector<int>& arr) {
        int n = arr.size();
        int diff = 0;
        vector<int> cnt(1010);
        for (int i = 0; i < n; i++) {
            if (++cnt[target[i]] == 1) diff++;
            if (--cnt[arr[i]] == 0) diff--;
        }
        return diff == 0;
    }
};
```



#### [1464. 数组中两元素的最大乘积](https://leetcode.cn/problems/maximum-product-of-two-elements-in-an-array/)：简单模拟

```C++
class Solution {
public:
    int maxProduct(vector<int>& nums) {
        int a = -1, b = -1;     // a是较大者，b是较小者
        for (int x : nums ) {
            if (x > a) {
                b = a; a = x;
            } else if (x > b) {
                b = x;
            }
        }
        return (a - 1) * (b - 1);
    }
};
```



#### [1470. 重新排列数组](https://leetcode.cn/problems/shuffle-the-array/)：简单模拟

```C++
class Solution {
public:
    vector<int> shuffle(vector<int>& nums, int n) {
        vector<int> ans(2 * n);
        for (int i = 0, j = n, k = 0; k < 2 * n; k++) {
            ans[k] = k % 2 == 0 ? nums[i++] : nums[j++];
        }
        return ans;
    }
};
```



#### [1475. 商品折扣后的最终价格](https://leetcode.cn/problems/final-prices-with-a-special-discount-in-a-shop/)：模拟 or 单调栈

**法1：直接模拟**

```C++
class Solution {
public:
    vector<int> finalPrices(vector<int>& prices) {
        int n = prices.size();
        vector<int> ans(n);
        for (int i = 0; i < n; i++) {
            int k = 0;
            for (int j = i + 1; j < n && k == 0; j++) {
                if (prices[j] <= prices[i]) k = prices[j];
            }
            ans[i] = prices[i] - k;
        }
        return ans;
    }
};
```

**法2：****单调栈****（思路很巧妙）**

根据题意，我们知道若 nums[i] 存在折扣，必然是被其右边最近一个满足「nums[j] <= nums[i]」的 nums[j] 所更新。反过来说，给定一个 nums[j]，其所能更新的是其左边最近一个满足「nums[i] >= nums[j]」的 nums[i]。

因此我们可以使用「单调栈」来进行求解。

当然，我们也能不依靠经验，而从问题的本身出发，逐步分析出该做法。



具体的，我们可以从前往后处理所有的 nums[i]，使用某类容器**装载我们所有的「待打折」的商品下标**。假设当前处理到的是 nums[i]：

- 若其比容器内的任意商品价格要高，其必然不能更新任何一个待打折商品的价格，将其也加入容器尾部（此时我们发现，若有一个新的商品加入容器，其必然是当前所有待打折商品中的价格最高的，即**容器内的商品价格单调递增**）；
- 若其价格不高于容器内的商品价格，其能够更新容器内待打折的商品价格，并且由于我们容器满足单调递增特性，我们必然能够从尾部开始取出待打折商品来进行更新，直到处理完成或遇到第一个无法更新价格的商品。

**由于我们需要往尾部添加和取出元素，因此容器可使用「栈」**。

```C++
class Solution {
public:
    vector<int> finalPrices(vector<int>& prices) {
        int n = prices.size();
        vector<int> ans = prices;
        stack<int> st;
        for (int i = 0; i < n; i++) {
            while (!st.empty() && prices[i] <= prices[st.top()]) {
                int idx = st.top();
                st.pop();
                ans[idx] = prices[idx] - prices[i];
            }
            st.push(i);
        }
        return ans;
    }
};
```

至此，我们分析了单调栈做法的两大重点：为何单调 & 为何用栈。若对「单调栈」仍不了解的同学，可以看前置 🧀 : **[关于 RMQ 的若干解法](https://mp.weixin.qq.com/s?__biz=MzU4NDE3MTEyMA==&mid=2247493262&idx=1&sn=2d8e192a5767b49b9a13a6192ab3b833)** 中的第四种解法 🎉🎉🎉。







#### 1480.一维数组的动态和：动规 普普通通

#### [1576. 替换所有的问号](https://leetcode-cn.com/problems/replace-all-s-to-avoid-consecutive-repeating-characters/)：字符的替换 简单题

![img](https://uestc.feishu.cn/space/api/box/stream/download/asynccode/?code=NGQ5NGY0NGUyY2IzZjhhMDU3NGU2MjVhMzA4N2NiMWFfbUlTcExweHlBa1RjWXhMUmxxS0tnMDlvTHFJN2xwSE5fVG9rZW46Ym94Y25qTVZOQWJOWEZwVVFtWG5GRlhyNnZlXzE2NjI2NDE5MTE6MTY2MjY0NTUxMV9WNA)

```Python
class Solution:
    def modifyString(self, s: str) -> str:
        ls = list(s)
        n = len(s)
        for i in range(n):
            if ls[i] == '?':
                for p in "abc":
                    if (i >= 1 and ls[i-1] == p) or (i < n-1 and ls[i+1] == p):
                        continue
                    ls[i] = p
                    break
        return "".join(ls)
```



#### [1582. 二进制矩阵中的特殊位置](https://leetcode.cn/problems/special-positions-in-a-binary-matrix/)：矩阵操作

对于矩阵操作如何减少时间复杂度：本题是分别按行按列统计

```C++
class Solution {
public:
    int numSpecial(vector<vector<int>>& mat) {
        int m = mat.size(), n = mat[0].size();  // m*n
        int ans = 0;

        vector<int> row_sum(m);
        vector<int> col_sum(n);
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                row_sum[i] += mat[i][j];
                col_sum[j] += mat[i][j];
            }
        }

        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                if (mat[i][j] == 1 && row_sum[i] == 1 && col_sum[j] == 1) {
                    ans++;
                }
            }
        }
        return ans;
    }
};
```



#### [1592. 重新排列单词间的空格](https://leetcode.cn/problems/rearrange-spaces-between-words/)：双指针+分词

> 这里使用了一种可以给字符串赋值的方法

```C++
class Solution {
public:
    string reorderSpaces(string text) {
        int n = text.size();
        int cnt = 0;
        vector<string> words;
        for (int i = 0; i < n; ) {
            if (text[i] == ' ') {
                i++; cnt++;
                continue;
            }
            int j = i;
            while (j < n && text[j] != ' ') j++;
            words.push_back(text.substr(i, j - i));
            i = j;
        }
        string ans;
        int m = words.size(), blank = cnt / max(m - 1, 1);
        for (int i = 0; i < m; i++) {
            ans += words[i];
            if (i != m - 1) ans.append(string(blank, ' '));
        }
        if (ans.size() != n) ans.append(string(cnt - (m - 1) * blank, ' '));
        return ans;
    }
};
```





#### [1614. 括号的最大嵌套深度](https://leetcode-cn.com/problems/maximum-nesting-depth-of-the-parentheses/)：简单地‘(’累加计数

```C++
class Solution {
public:
    int maxDepth(string s) {
        int n = s.size();
        int ans = 0;
        for(int i = 0, cnt = 0; i < n; ++i){
            if(s[i] == '(') cnt++;
            else if(s[i] == ')') cnt--;
            ans = max(ans, cnt);
        }
    return ans;
    }
};
```



#### [1629. 按键持续时间最长的键](https://leetcode-cn.com/problems/slowest-key/)：一次遍历找最大

注意直接比较字节序

```C++
class Solution {
public:
    // 只看每次的最长持续时间
    char slowestKey(vector<int>& releaseTimes, string keysPressed) {
        int n = releaseTimes.size();
        int p = 0, max = releaseTimes[0];
        for(int i = 1; i < n; i++){
            int cur = releaseTimes[i] - releaseTimes[i-1];
            if(cur > max){
                p = i;
                max = cur;
            }
            else if(cur == max && keysPressed[i] > keysPressed[p]){
                p = i;
            }
        }
        return keysPressed[p];
    }
};
```



#### [1656. 设计有序流](https://leetcode.cn/problems/design-an-ordered-stream/)

> 判断数组中元素为空，`**stream[idx].empty()**`

```C++
class OrderedStream {
public:
    vector<string> stream;
    int idx;

    OrderedStream(int n) {
        stream = vector<string>(n + 1);
        idx = 1;
    }
    
    vector<string> insert(int idKey, string value) {
        stream[idKey] = value;
        vector<string> ans;
        int n = stream.size();
        while (idx < n && !stream[idx].empty()) {
            ans.push_back(stream[idx++]);
        }
        return ans;
    }
};

/**
 * Your OrderedStream object will be instantiated and called as such:
 * OrderedStream* obj = new OrderedStream(n);
 * vector<string> param_1 = obj->insert(idKey,value);
 */
```





#### [1706. 球会落何处](https://leetcode-cn.com/problems/where-will-the-ball-fall/)：

![img](https://uestc.feishu.cn/space/api/box/stream/download/asynccode/?code=ODZlODliMTYwNTY0NGYyNWRhYzM4ODUzZDdiNzZmN2ZfczhqSkZiTFZabUxGcnpQVlVNSjVUc2xkdTgxRVRnVThfVG9rZW46Ym94Y25tUmUzWGpsMlhMNnVYMkxwbW5WTGloXzE2NjI2NDE5MTE6MTY2MjY0NTUxMV9WNA)

**写法1：**进行一个动态规划

![img](https://uestc.feishu.cn/space/api/box/stream/download/asynccode/?code=ZjU1M2M2YmQwOGNmZjgyNDlkYTE2MTBhMzI0YmRkMGFfZUVta0wwdlV4emtFYVltb1dRVUV1NjVOVlhxdW5EQkNfVG9rZW46Ym94Y25RUVJIMjU2RHlxdXdvOURUa0JlM0VlXzE2NjI2NDE5MTE6MTY2MjY0NTUxMV9WNA)

```Python
class Solution:
    def findBall(self, grid: List[List[int]]) -> List[int]:
        m, n = len(grid), len(grid[0])  # m行n列
        dp = {i : i for i in range(n)}
        for i in range(m):  # 遍历每一行
            for j in list(dp.keys()):  # 看每一列的值
                if grid[i][dp[j]] == 1:
                    if dp[j] == n-1 or grid[i][dp[j]+1] == -1: dp.pop(j)
                    else: dp[j] += 1
                elif grid[i][dp[j]] == -1:
                    if dp[j] == 0 or grid[i][dp[j]-1] == 1: dp.pop(j)
                    else: dp[j] -= 1
        return [dp[_] if _ in dp else -1 for _ in range(n)]
```

注意：这样写会越界！！

![img](https://uestc.feishu.cn/space/api/box/stream/download/asynccode/?code=NGJmYjkzYzRlMWRiMWI3Nzk0NWU2ZDQyZGU0OTY3Nzhfa2o5cW44RjdXdUNWU3BXa2hHUEF0ZEdLNmdoNWtCRkVfVG9rZW46Ym94Y25uUmpRVVFtRE1Kb1I5QWR6QmluTE5nXzE2NjI2NDE5MTE6MTY2MjY0NTUxMV9WNA)

**写法2：**比上面哪个更容易看懂，像是人能写出来的东西

【三叶】の题解思路：

![img](https://uestc.feishu.cn/space/api/box/stream/download/asynccode/?code=MWEwMWI4ZTMzZjExOWEwYTA1NDc0NDc2MjFhYTA0MTNfTE44UktDQ3FYREh4eDFwWDhkd3RUeERJVlBPQjc1dVZfVG9rZW46Ym94Y253b3BRd2Jvb24xTW9hQTdNOHJGaExHXzE2NjI2NDE5MTE6MTY2MjY0NTUxMV9WNA)

```C++
class Solution {
public:
    int m, n;
    vector<vector<int>> g;
    vector<int> findBall(vector<vector<int>>& grid) {
        g = grid;
        m = g.size(), n = g[0].size();
        vector<int> ans(n);
        for (int i = 0; i < n; ++i) {
            ans[i] = getVal(i);
        }
        return ans;
    }
    int getVal(int x) {
        int r = 0, c = x;
        while (r < m) {
            int ne = c + g[r][c];
            if (ne < 0 || ne >= n) return -1;
            if (g[r][c] != g[r][ne]) return -1;
            r++;
            c = ne;
        }
        return c;
    }
};
```

最容易理解的一个写法：

```C++
class Solution {
public:
    vector<int> findBall(vector<vector<int>>& grid) {
        int m = grid.size(), n = grid[0].size(); 
        vector<int> ans(n);  // 当前求在第几列（-1为卡住）
        for (int j = 0; j < n; j++) ans[j] = j; 

        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                if (ans[j] == -1) continue;
                int col = ans[j]; 
                if (grid[i][col] == 1)
                    ans[j] = (col + 1 >= n || grid[i][col+1] == -1) ? -1 : col + 1; 
                else if (grid[i][col] == -1)
                    ans[j] = (col - 1 < 0 || grid[i][col-1] == 1) ? -1 : col - 1; 
            }
        }

        return ans; 
    }
};
```



#### [1725. 可以形成最大正方形的矩形数目](https://leetcode-cn.com/problems/number-of-rectangles-that-can-form-the-largest-square/)：简单求最值

> 数组内求min，然后再求max

![img](https://uestc.feishu.cn/space/api/box/stream/download/asynccode/?code=ZjE1ZjhkN2NlOTY3YjY4YjdiMzg0ZWE4NDA3OWZjOTNfZUdEaWY4aGJqTkZnTjRIT0w2WHEyZ0pGRUF6NnBpY2JfVG9rZW46Ym94Y253dXhzbjJoSFM2TDdsNHRmc0lCV1VlXzE2NjI2NDE5MTE6MTY2MjY0NTUxMV9WNA)

**一种简单的写法：**

```C++
class Solution {
public:
    int countGoodRectangles(vector<vector<int>>& rectangles) {
        int ans = 0, maxLen = 0;
        int n = rectangles.size();
        for(int i = 0; i < n; ++i){
            int cur = min(rectangles[i][0], rectangles[i][1]);
            if(cur == maxLen)
                ans++;
            else if(cur > maxLen){
                maxLen = cur;  // 找的是最大正方形
                ans = 1;
            }
        }
        return ans;
    }
};
```

**还有一种简便的C++写法：**

```C++
class Solution {
public:
    int countGoodRectangles(vector<vector<int>>& rectangles) {
        int ans = 0, maxLen = 0;
        for(auto &rec : rectangles){
            int cur = min(rec[0], rec[1]);
            if(cur == maxLen)
                ans++;
            else if(cur > maxLen){
                maxLen = cur;  // 找的是最大正方形
                ans = 1;
            }
        }
        return ans;
    }
};
# python基础写法
class Solution:
    def countGoodRectangles(self, rectangles: List[List[int]]) -> int:
        ans, maxLen = 0, 0
        for a, b in rectangles:
            cur = min(a, b)
            if cur == maxLen:
                ans += 1
            elif cur > maxLen:
                maxLen = cur
                ans = 1
        return ans
        
# python的简练写法⭐
class Solution:
    def countGoodRectangles(self, rectangles: List[List[int]]) -> int:
        return cur.count(m) if (cur := [min(rec) for rec in rectangles]) and (m := max(cur)) else 0
```



#### [1763. 最长的美好子字符串](https://leetcode-cn.com/problems/longest-nice-substring/)：朴素地枚举

![img](https://uestc.feishu.cn/space/api/box/stream/download/asynccode/?code=NzcwY2ViOTc4YWRlZDlmYzhhOGI3MWJhYTliOWNjYzJfblpLY3lEMWVhb2xkZjBET2xqakV6UndiWTc1TU5DNjFfVG9rZW46Ym94Y25GMWtQeFBRblVJWGRsVmQxSTMzV3ZiXzE2NjI2NDE5MTE6MTY2MjY0NTUxMV9WNA)

**法1：分治思想**

将原问题拆解成子问题：**如果某个字符，在当前字符串中没有它对应的大写或小写字符，它必不能构成答案中的一部分，答案只能在它左边或在它右边**。

我们返回该点左边或右边更长的答案即为答案。

如果不存在这样的字符，说明原字符串本身就是美好字符串

```Python
class Solution:
    # 分治思想⭐
    def longestNiceSubstring(self, s: str) -> str:
        if len(s) < 2:
            return ""
        for i, ch in enumerate(s):
            if ch.upper() not in s or ch.lower() not in s:
                return max(self.longestNiceSubstring(s[:i]), self.longestNiceSubstring(s[i+1:]), key = len)
        return s
```



**法2：枚举？**

![img](https://uestc.feishu.cn/space/api/box/stream/download/asynccode/?code=M2ZmMjkwOWU3ODgyZGY0Njk5NzI5YzJhZmUwMjgxNThfSVlZQU9Ja3NlOFV1b1Rmelc0YVgwekNZanpLb3ZkOWlfVG9rZW46Ym94Y25PR2thdTN0SmJqRjRxenpHOEtTMk9kXzE2NjI2NDE5MTE6MTY2MjY0NTUxMV9WNA)







#### [1816. 截断句子](https://leetcode-cn.com/problems/truncate-sentence/)：简单的切片 substr()



#### [1823. 找出游戏的获胜者](https://leetcode-cn.com/problems/find-the-winner-of-the-circular-game/)：约瑟夫环

**方法一：直接模拟**

- > 利用数据范围1 <= k <= n <= 500，我们可以直接根据规则进行模拟。

- > 创建一个标记数组 vis，若有 vis[idx] = true 则代表点编号为 idx 已被淘汰，每次我们都从当前位置 cur 开始，找到第 k 个尚未淘汰的点（vis[idx] = false），并将其进行标记（vis[idx] = true），共有 n - 1 个点需要被淘汰。

- > 一些细节，为了方便取模，我们调整点编号从 11 开始，在返回答案时再重新调整为从 11 开始。

```C++
class Solution {
public:
    int findTheWinner(int n, int k) {
        vector<bool> vis(n, false);
        int cnt = 0, cur = 0;
        while (cnt < n - 1) {
            for (int i = 0; i < k - 1; ++i) {
                cur++;
                while (vis[cur % n]) cur++;
            }
            vis[cur % n] = true;
            cnt++;
            cur++;
            while (vis[cur % n]) cur++;
        }
        return (cur % n) + 1;
    }
};
```

**方法二：递归⭐**

![img](https://uestc.feishu.cn/space/api/box/stream/download/asynccode/?code=NjE2YTgyNmUyNDcwNDM2NTQwZTg0ZjdmNTVjM2JmZTBfTDFydGRqUEVwN2JVb01OOWQ5M3d0R2Z2OGVYeURiZUtfVG9rZW46Ym94Y25RUU80Z3dzdUxEckc2clhHclJ1MjhkXzE2NjI2NDE5MTE6MTY2MjY0NTUxMV9WNA)

```C++
    int findTheWinner(int n, int k) {
        if (n <= 1)
            return n;
        int ans = (findTheWinner(n - 1, k) + k) % n;
        return ans == 0 ? n : ans;
    }
```

**方法三：约瑟夫环的数学推导**

[【负雪明烛】你能找到的最详细约瑟夫环数学推导！ - 找出游戏的获胜者 - 力扣（LeetCode） (leetcode-cn.com)](https://leetcode-cn.com/problems/find-the-winner-of-the-circular-game/solution/by-fuxuemingzhu-laof/)

```Java
    int findTheWinner(int n, int k) {
        int pos = 0;
        for (int i = 2; i < n + 1; ++i) {
            pos = (pos + k) % i;
        }
        return pos + 1;
```



#### [2000. 反转单词前缀](https://leetcode-cn.com/problems/reverse-prefix-of-word/)：find函数使用方法⭐+python简洁的反转方法

> 题意：指定字符寻找下标进行翻转

find函数找；reverse函数翻转？😅

```C++
class Solution {
public:
    string reversePrefix(string word, char ch) {
        int idx = word.find(ch);
        if(idx != string::npos){
            reverse(word.begin(), word.begin() + idx + 1);
        }
        return word;
    }
};
class Solution:
    def reversePrefix(self, word: str, ch: str) -> str:
        idx = word.find(ch)
        return word if idx == -1 else word[:idx+1][::-1] + word[idx+1:]

# 解法2
class Solution:
    def reversePrefix(self, word: str, ch: str) -> str:
        return word if (idx:=word.find(ch)) == -1 else word[:idx+1][::-1] + word[idx+1:]
```



> **双指针进行翻转？：**先从前往后遍历，找到第一个ch的下标idx（初始值-1），然后对[0,idx] 应用**双指针**进行翻转（若没有ch字符，则idx = -1，则[0,idx] 为不合法区间，翻转过程被跳过）。

```C++
class Solution {
public:
    string reversePrefix(string word, char ch) {
        int n = word.size(), idx = -1;
        for(int i = 0; i < n && idx == -1; ++i){
            if(word[i] == ch)
                idx = i;
        }
        // 用双指针进行翻转
        int l = 0, r = idx;
        while(l < r){
            char ch = word[l];
            word[l++] = word[r];
            word[r--] = ch;
        }
        return word;
    }
};
```



#### [2016. 增量元素之间的最大差值](https://leetcode-cn.com/problems/maximum-difference-between-increasing-elements/)

![img](https://uestc.feishu.cn/space/api/box/stream/download/asynccode/?code=NmFjZWVhYTlmNWJhMGQ0NjI5NzVjNmQ0ZmJlNTFmNTZfb0w1TzM4T3FqUFRaMG5zMnNtOXR6OFFJc2pOR2Y4R3dfVG9rZW46Ym94Y252MXUySlFwbFBMejJxemM2a0NJM1JmXzE2NjI2NDE5MTE6MTY2MjY0NTUxMV9WNA)

```C++
class Solution {
public:
    int maximumDifference(vector<int>& nums) {
        int n = nums.size(), ans = -1;
        int premin = nums[0];  // nums前面的最小值
        for (int i = 0; i < n; ++i) {
            if (nums[i] > premin) ans = max(ans, nums[i] - premin);
            else premin = min(premin, nums[i]);
        }
        return ans;
    }
};
```





#### [面试题 01.05. 一次编辑](https://leetcode.cn/problems/one-away-lcci/)：双指针模拟，比较字符串

> 为了比较字符串，是否通过一次编辑就能实现

![img](https://uestc.feishu.cn/space/api/box/stream/download/asynccode/?code=MDlkZmZhNDUxYTE0ZjE2NTNlNjU1OTc5YWUzOTVhMGZfd0k0dVJTNHFKS2FtdWl5em5UemE1VmlxT2t0TWpmSnlfVG9rZW46Ym94Y24yc0E5bEZYSWVxZ2d1SHBVZHN6OGJkXzE2NjI2NDE5MTE6MTY2MjY0NTUxMV9WNA)

**法1：一次性遍历，分类讨论**

```C++
#include <cmath>
class Solution {
public:
    bool oneEditAway(string first, string second) {
        int m = first.size(), n = second.size();
        if (m < n) return oneEditAway(second, first);
        if (m == n) {  // 执行一次替换
            for (int i = 0, dif = 0; i < m; i++) {
                if (first[i] != second[i]) dif++;
                if (dif > 1) return false;
            }
            return true;
        }
        if (m - n == 1) {  // 执行一次删除
            for (int i = 0, dif = 0; i < m; i++) {
                if (first[i + dif] != second[i]) {  // dif相当于偏移量
                    dif++;
                    i--;  // 以second为基准，再比较一次第i位
                }
                if (dif > 1) return false;
            }
            return true;
        }
        return false;
    }
};
```

**法2：双指针**

```TypeScript
class Solution {
public:
    bool oneEditAway(string first, string second) {
        int m = first.size(), n = second.size();
        if (m < n) return oneEditAway(second, first);
        if (m - n > 1) return false;
        int i = 0, j = 0, dif = 0;
        while (i < m && j < n && dif <= 1) {
            if (first[i] == second[j]) {
                i++, j++;
            }
            else {
                if (m == n) {
                    i++, j++, dif++;  // 说明是一次替换
                }
                else {
                    i++, dif++;  // 说明是一次删除
                }
            }
        }
        return dif <= 1 ? true : false;
    }
};
```



#### [面试题 17.11. 单词距离](https://leetcode.cn/problems/find-closest-lcci/)

```C++
class Solution {
public:
    int findClosest(vector<string>& words, string word1, string word2) {
        int n = words.size();
        int p1 = -1, p2 = -1, ans = n;
        for (int i = 0; i < n; i++) {
            if (words[i] == word1) p1 = i;
            if (words[i] == word2) p2 = i;
            if (p1 != -1 && p2 != -1) ans = min(ans, abs(p1 - p2));
        }
        return ans;
    }
};
```









# 数据结构

## (1)栈

无法复制加载中的内容

#### 20.有效括号：C++函数用法，python栈+哈希表

```C++
class Solution {
public:
    bool isValid(string s) {
        int n = s.size();
        if (n % 2 == 1)
            return false;

        unordered_map<char, char> pairs = {
            {')', '('},
            {']', '['},
            {'}', '{'}
        };
        stack<char> stk;
        for (char ch: s) {
            if (pairs.count(ch)) { //下标为ch的地方有数据，这里是根据右括号查左？
                if (stk.empty() || stk.top() != pairs[ch])
                    return false;
                stk.pop();
            }
            else
                stk.push(ch);
        }
        return stk.empty();
    }
};
//想必：if (pairs.count(ch)) 是看当前ch是右括号不是？若是则进入if
//count(ch)是查找 key的存在
//pairs[ch]是 key->value查询
class Solution:
    def isValid(self, s: str) -> bool:
        # python用列表来实现栈就可以了！方便
        if len(s)%2 == 1:
            return False
        pairs = {
            ")": "(",
            "]": "[",
            "}": "{",
        } #字典：作为哈希表
        stack = list()
        for ch in s:
            if ch in pairs:
                if not stack or stack[-1]!=pairs[ch]: # stack[-1]倒序第1个，即栈顶
                    return False
                stack.pop()
            else:
                stack.append(ch)
        
        return not stack
```

#### [32. 最长有效括号](https://leetcode-cn.com/problems/longest-valid-parentheses/)：不要想简单了 思路 边界

![img](https://uestc.feishu.cn/space/api/box/stream/download/asynccode/?code=MjM5NDkyYTdhM2ZhN2Y0MzNlZTUyOWUyNTBkM2YxYjBfalJ5UjZDR3hzRlYyUldFWDRvNEZVQUU2NjNEZUwzWUhfVG9rZW46Ym94Y25KR1owdkszRTgzSmRzcDNOcmVaMWdnXzE2NjI2NDE5MTE6MTY2MjY0NTUxMV9WNA)

用栈实现的思路是：

![img](https://uestc.feishu.cn/space/api/box/stream/download/asynccode/?code=MWFiN2IwYzcxYThlODE4ZTY4NGYyYThiMDVhZDU1M2JfVEYzQUFXbjU1aWx4TFhmRmZUdHQzSmN4RWlTNnJKcGZfVG9rZW46Ym94Y25kYk92RTRrZmw2QXJBdE1teXpFQ0VoXzE2NjI2NDE5MTE6MTY2MjY0NTUxMV9WNA)

```C++
class Solution {
public:
    int longestValidParentheses(string s) {
        int ans = 0;
        stack<int> stk;  // 栈中存放的是未匹配的括号的下标
        // 栈底元素为当前“最后一个没有被匹配的右括号的下标”
        stk.push(-1);
        for (int i = 0; i < s.length(); i++) {
            if (s[i] == '(') {
                stk.push(i);
            } else {  // 是')'则把左括号下标出栈
                stk.pop();
                // 这时，看栈中还有没有等待匹配的左括号
                if (stk.empty()) { // 如果没有左括号了，说明当前右括号是没有被匹配的
                    stk.push(i);  //把当前这个未匹配的右括号下标放入，作为新的起点！
                } else { //如果还有左括号等待匹配
                    ans = max(ans, i - stk.top());
                }
                // stk.pop();
            }
        }
        return ans;
    }
};
```

**需要记录：最近的最长括号开始位置！！**

![img](https://uestc.feishu.cn/space/api/box/stream/download/asynccode/?code=YWE4ZTFlNGQ2OTljNDBkYmFlY2ExODJjZGQyMWIzOGZfNWVKNjBvOE1LbE02WkNMVWpOT3plYU1SdGU2WXdvY3BfVG9rZW46Ym94Y25jQlRvWHVST1dOMmhycVVSekFYS1hiXzE2NjI2NDE5MTE6MTY2MjY0NTUxMV9WNA)



#### 155.最小栈

```Python
class MinStack:

    def __init__(self):
        self.stack = []
        self.min_stack = [math.inf]

    def push(self, val: int) -> None:
        self.stack.append(val)
        # self.min_stack.append(min(val, min_stack[-1])) 有个错误！忘记写self了！！
        self.min_stack.append(min(val, self.min_stack[-1]))

    def pop(self) -> None:
        self.stack.pop()
        self.min_stack.pop()

    def top(self) -> int:
        return self.stack[-1]

    def getMin(self) -> int:
        return self.min_stack[-1]

# Your MinStack object will be instantiated and called as such:
# obj = MinStack()
# obj.push(val)
# obj.pop()
# param_3 = obj.top()
# param_4 = obj.getMin()
```

#### [232. 用栈实现队列](https://leetcode-cn.com/problems/implement-queue-using-stacks/)：双栈



#### [636. 函数的独占时间](https://leetcode.cn/problems/exclusive-time-of-functions/)：栈 模拟函数执行

> `c_str()`函数的用法！！可以用于格式化分割字符串内容

```C++
char type[10];
int idx, timestamp;
sscanf(log.c_str(), "%d:%[^:]:%d", &idx, type, &timestamp);

// if (log.find("start") != string::npos)
```

自己写的一种解法：

```C++
class Solution {
public:
    vector<int> exclusiveTime(int n, vector<string>& logs) {
        vector<int> ans(n);
        stack<int> st;
        int last = -1;
        for (string log : logs) {
            int i = 0, j = log.size() - 1;
            while (log[i] != ':') i++;
            while (log[j] != ':') j--;
            int idx = stoi(log.substr(0, i));
            int t = stoi(log.substr(j + 1));

            if (log[i + 1] == 's') {  // 开始或重新开始
                if (!st.empty()) {
                    int func = st.top();
                    ans[func] += t - last;  // 记录当前st中已经执行的时间
                }
                st.push(idx);
                last = t;
            } else {  // 表示结束执行
                int func = st.top();
                st.pop();
                ans[func] += t - last + 1;
                last = t + 1;
            }
        }
        return ans;
    }
};
```



#### [946. 验证栈序列](https://leetcode.cn/problems/validate-stack-sequences/)：利用栈来模拟其行为

```C++
class Solution {
public:
    bool validateStackSequences(vector<int>& pushed, vector<int>& popped) {
        stack<int> st;
        int n = pushed.size();
        for (int i = 0, j = 0; i < n; i++) {
            st.push(pushed[i]);
            while (!st.empty() && st.top() == popped[j]) {
                st.pop();
                j++;
            }
        }
        return st.empty();
    }
};
```





#### [1047. 删除字符串中相邻重复项](https://leetcode-cn.com/problems/remove-all-adjacent-duplicates-in-string/)：string类似vector的用法 明明用栈就很好

![img](https://uestc.feishu.cn/space/api/box/stream/download/asynccode/?code=M2QzNTUyM2ExNzM0NGIyZmRkN2RmZTY2ZjJmMjliYmNfaXE0ZjVncEVkNk1KRE9mTG1YazhzdWxaN0tjcWlzemFfVG9rZW46Ym94Y25QaHpRbTBJc3FtSmI3SkM1dFRJUGJkXzE2NjI2NDE5MTE6MTY2MjY0NTUxMV9WNA)

官方直接使用字符串的操作：显然用栈比较好，这里**把string当栈用**

```C++
class Solution {
public:
    string removeDuplicates(string s) {
        string stk;
        for (char ch : s) {
            if (!stk.empty() && stk.back() == ch) {
                stk.pop_back();
            } else {
                stk.push_back(ch);
            }
        }
        return stk;
    }
};
```

![img](https://uestc.feishu.cn/space/api/box/stream/download/asynccode/?code=YmJjNzM0Y2QxNzk0ZTc5MTE5NmM5YjQ1YzVlZjAyNzNfeVg5NG9PVVNyNWIySm54aXUwaWpXYVo5eWh3c0k1R1VfVG9rZW46Ym94Y25YOUJJWnkwZHJ5TFo2MnJsY29LSFBIXzE2NjI2NDE5MTE6MTY2MjY0NTUxMV9WNA)







## 

## (3)队列

无法复制加载中的内容

#### [622. 设计循环队列](https://leetcode.cn/problems/design-circular-queue/)：模拟循环队列

#### [641. 设计循环双端队列](https://leetcode.cn/problems/design-circular-deque/)：模拟，数组or循环链表

> 类似于[622. 设计循环队列](https://leetcode.cn/problems/design-circular-queue/)，见上文



**法1：直接用数组模拟，长度仍 n = k + 1**

> 根据循环队列的定义，

> 队列判空的条件是front=rear，

> 队列判满的条件是front=(rear+1) mod capacity

> 对固定大小的数组，知道队尾与队首即可算出队列当前的长度(rear−front+capacity) mod capacity

- front：队列首元素对应的数组的索引。
- tail：队列尾元素对应的索引的下一个索引。

```C++
class MyCircularDeque {
private:
    vector<int> deq;
    int front, tail;
    int n;
public:
    MyCircularDeque(int k) {
        front = tail = 0;
        n = k + 1;
        deq = vector<int>(n);
    }

    bool isEmpty() {
        return tail == front;
    }
    
    bool isFull() {
        return (tail + 1) % n == front;
    }
    
    bool insertFront(int value) {
        if (isFull()) return false;
        front = (front - 1 + n) % n;
        deq[front] = value;
        return true;
    }
    
    bool insertLast(int value) {
        if (isFull()) return false;
        deq[tail] = value;
        tail = (tail + 1) % n;
        return true;
    }
    
    bool deleteFront() {
        if (isEmpty()) return false;
        front = (front + 1) % n;
        return true;
    }
    
    bool deleteLast() {
        if (isEmpty()) return false;
        tail = (tail - 1 + n) % n;
        return true;
    }
    
    int getFront() {
        if (isEmpty()) return -1;
        return deq[front];
    }
    
    int getRear() {
        if (isEmpty()) return -1;
        return deq[(tail - 1 + n) % n];
    }
};

/**
 * Your MyCircularDeque object will be instantiated and called as such:
 * MyCircularDeque* obj = new MyCircularDeque(k);
 * bool param_1 = obj->insertFront(value);
 * bool param_2 = obj->insertLast(value);
 * bool param_3 = obj->deleteFront();
 * bool param_4 = obj->deleteLast();
 * int param_5 = obj->getFront();
 * int param_6 = obj->getRear();
 * bool param_7 = obj->isEmpty();
 * bool param_8 = obj->isFull();
 */
```

法2：链表

```C++
struct Node {
    int val;
    Node* last;
    Node* next;
    Node(int k): val(k), last(NULL), next(NULL) {}
};

class MyCircularDeque {
private:
    Node* head;
    Node* tail;
    int capacity;
    int n;
public:
    MyCircularDeque(int k): capacity(k), n(0), head(NULL), tail(NULL){}

    bool isEmpty() {
        return n == 0;
    }    
    bool isFull() {
        return n == capacity;
    }
    
    bool insertFront(int value) {
        if (isFull()) return false;
        Node* p = new Node(value);
        if (n == 0) {
            head = p;
            tail = p;
        } else {
            p->next = head;
            head->last = p;
            head = p;

            // tail->next = head;
        }
        n++;
        return true;
    }
    
    bool insertLast(int value) {
        if (isFull()) return false;
        Node* p = new Node(value);
        if (n == 0) {
            head = p;
            tail = p;
        } else {
            tail->next = p;
            p->last = tail;
            tail = p;

            // head->last = tail;
        }
        n++;
        return true;
    }
    
    bool deleteFront() {
        if (isEmpty()) return false;
        Node* p = head;
        head = head->next;
        if (head != NULL) head->last = NULL;
        delete p;
        n--;
        return true;
    }
    
    bool deleteLast() {
        if (isEmpty()) return false;
        Node* p = tail;
        tail = tail->last;
        if (tail != NULL) tail->next = NULL;
        delete p;
        n--;
        return true;
    }
    
    int getFront() {
        if (isEmpty()) return -1;
        return head->val;
    }
    
    int getRear() {
        if (isEmpty()) return -1;
        return tail->val;
    }
};
```















#### [933. 最近的请求次数](https://leetcode-cn.com/problems/number-of-recent-calls/)：

> 关键在于看懂题意：每次t入队；取在队中的介于[t-3000, t]的元素个数

```C++
class RecentCounter {
public:
    queue<int> q;

    RecentCounter() {}
    
    int ping(int t) {
        q.push(t);
        while (q.front() < t - 3000) q.pop();
        return q.size();
    }
};
```

无非就是练习了一下队列的使用







## (4)单调队列





## (5)二叉树

无法复制加载中的内容

**重要性质：**

- **二叉搜索树or完全二叉排序树：中序遍历可以得到一个有序序列！！**





#### [449. 序列化和反序列化二叉搜索树](https://leetcode.cn/problems/serialize-and-deserialize-bst/)：⭐

![img](https://uestc.feishu.cn/space/api/box/stream/download/asynccode/?code=YTU3MjU3ZTAxNzY1M2U2ZmViMTMyNTY4ZWQwODE4MmFfalJJTnBvRXREZ0htR05ld2o0cUFienFNU3N6Vnh0dzhfVG9rZW46Ym94Y25jcUNxWDgzcWhsWFRKNDJidjY3VVdiXzE2NjI2NDE5MTE6MTY2MjY0NTUxMV9WNA)

- > 根--左--右

- > 转成字符转后，再转回来，**思考：两位数的情况，要特殊处理⭐**

```C++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Codec {
public:
    void seHandler(vector<int>& list, TreeNode* root) {
        if (root == NULL) return;
        list.push_back(root->val);
        seHandler(list, root->left);
        seHandler(list, root->right);
    }
    // Encodes a tree to a single string.
    string serialize(TreeNode* root) {
        vector<int> list;
        string se;
        seHandler(list, root);
        for (auto n : list) se += to_string(n) + ',';
        return se;
    }

    TreeNode* deHandler(vector<int>& list, int lb, int rb) {
        if (lb > rb) return NULL;
        TreeNode* root = new TreeNode(list[lb]);  //先是根
        int border = rb + 1;
        for (int i = lb + 1; i <= rb; i++) {
            if (list[i] < list[lb]) {
                continue;  // 比根小，是左子树
            }
            else {
                border = i;
                break;
            }
        }
        root->left = deHandler(list, lb + 1, border - 1);
        root->right = deHandler(list, border, rb);

        return root;
    }
    // Decodes your encoded data to tree.
    TreeNode* deserialize(string data) {
        if (data == "") return NULL;
        vector<int> list;
        string curNum = "";
        for (auto s : data) {
            if (s == ',') {
                list.push_back(stoi(curNum));
                curNum = "";
            }
            else curNum += s;
        }
        return deHandler(list, 0, list.size() - 1);  // 要规定好list的左右边界
    }
};

// Your Codec object will be instantiated and called as such:
// Codec* ser = new Codec();
// Codec* deser = new Codec();
// string tree = ser->serialize(root);
// TreeNode* ans = deser->deserialize(tree);
// return ans;
```

升级写法：

```C++
class Codec {
public:
    int idx = 0;
    int n;
    // Encodes a tree to a single string.
    string serialize(TreeNode* root) {
        if(root == NULL) return "";
        string ans = "";
        ans += to_string(root->val) + ",";
        ans += serialize(root->left) + ",";
        ans += serialize(root->right);
        return ans;
    }
    // Decodes your encoded data to tree.
    TreeNode* deserialize(string& data) { // 此处引用传递，避免值拷贝，提高效率
        n = data.size();
        if(idx >= n) return NULL;
        string num = "";
        while(idx < n && data[idx] != ',') {
            num += data[idx];
            ++idx;
        }
        ++idx;    // 跳过逗号
        if(num == "") return NULL;
        TreeNode* root = new TreeNode(stoi(num));
        root->left = deserialize(data);
        root->right = deserialize(data);
        return root;
    }
};
```



#### [450. 删除二叉搜索树中的节点](https://leetcode.cn/problems/delete-node-in-a-bst/)：删除二叉树的节点

> 直接调用了`delete`函数，不如华为oj规范

```PHP
/* Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    TreeNode* deleteNode(TreeNode* root, int key) {
        //第一种情况，不存在被删除节点
        if (root == NULL) return root;
        if (root->val == key) {
            //第二种情况，删除节点左右孩子都为空
            if (root->left == NULL && root->right == NULL) {
                delete root;
                return NULL;
            }
            //第三种情况，左孩子不为空，右孩子为空
            if (root->left != NULL && root->right == NULL) {
                TreeNode* node = root->left;
                delete root;
                return node;
            }
            //第四种情况，左孩子为空，右孩子不为空
            if (root->left == NULL && root->right != NULL) {
                TreeNode* node = root->right;
                delete root;
                return node;
            }
            //第五种情况，都不为空，将左子树放到右子树的最左侧
            if (root->left != NULL && root->right != NULL) {
                TreeNode* node = root->right;
                while (node->left != NULL) {
                    node = node->left;
                }
                node->left = root->left;
                TreeNode* tmp = root->right;
                delete root;
                return tmp;
            }
        }
        if (root->val > key) root->left = deleteNode(root->left, key);
        if (root->val < key) root->right = deleteNode(root->right, key);
        return root;
    }
};
```



#### [513. 找树左下角的值](https://leetcode.cn/problems/find-bottom-left-tree-value/)：dfs+bfs模板 

法1：dfs，用全局变量记录结果！

```C++
class Solution {
public:
    int maxDep, ans = 0;
    int findBottomLeftValue(TreeNode* root) {
        dfs(root, 1);
        return ans;
    }
    void dfs(TreeNode* root, int depth) {
        if (root == NULL) return;
        if (depth > maxDep) {
            maxDep = depth;
            ans = root->val;
        }
        dfs(root->left, depth + 1);
        dfs(root->right, depth + 1);
    }
};
```

法2：bfs

需要先把它的非空右子节点放入队列，然后再把它的非空左子节点放入队列，这样才能保证从右到左遍历每一层的节点

```C++
class Solution {
public:
    int findBottomLeftValue(TreeNode* root) {
        int ans = 0;
        queue<TreeNode *> q;
        q.push(root);
        while (!q.empty()) {
            TreeNode* p = q.front();
            q.pop();
            if (p->right) q.push(p->right);
            if (p->left) q.push(p->left);  // 找出左下角，因此要区分顺序，先右再左
            ans = p->val;
        }
        return ans;
    }
};
```



#### [515. 在每个树行中找最大值](https://leetcode.cn/problems/find-largest-value-in-each-tree-row/)

bfs

```C++
class Solution {
public:
    vector<int> largestValues(TreeNode* root) {
        if (root == NULL) return {};
        vector<int> res;
        queue<TreeNode*> q;
        q.push(root);
        while (!q.empty()) {
            int len = q.size();
            int maxVal = INT_MIN;
            while (len > 0) {
                len--;
                TreeNode* p = q.front();
                q.pop();
                maxVal = max(maxVal, p->val);
                if (p->left) q.push(p->left);
                if (p->right) q.push(p->right);
            }
            res.push_back(maxVal);
        }
        return res;
    }
};
```



#### [563. 二叉树的坡度](https://leetcode-cn.com/problems/binary-tree-tilt/)：递归地进行dfs

> 向上记录每一层的坡度

![img](https://uestc.feishu.cn/space/api/box/stream/download/asynccode/?code=NDYwN2IyYzA2NTZjMDRhYTY0NTA5ZWRlYjAzNzQ4ZDZfMlRkd0JodFBUV2VTMGY0dUh0ajVzN3pBYWNkN2pGNEVfVG9rZW46Ym94Y25vMVlqaUZaTFNmZDZlMmQ4alVVQmJoXzE2NjI2NDE5MTE6MTY2MjY0NTUxMV9WNA)

```C++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    int ans = 0; //记录每次搜索中，暂时用到的返回结果
    int findTilt(TreeNode* root) {
        dfs(root);
        return ans;
    }

    int dfs(TreeNode* node){
        if(node == NULL)
            return 0;
        int sumLeft = dfs(node->left); //左边的和，所以dfs()的返回值也应...⭐
        int sumRight = dfs(node->right);
        ans += abs(sumLeft - sumRight);
        return sumLeft + sumRight + node->val;
    }
};
```



#### [623. 在二叉树中增加一行](https://leetcode.cn/problems/add-one-row-to-tree/)：记录深度的bfs & dfs

> 不太一样的bfs和dfs，由于记录了深度

**法1：bfs**

```PHP
class Solution {
public:
    // bfs
    TreeNode* addOneRow(TreeNode* root, int val, int depth) {
        if (depth == 1) {
            TreeNode* ans = new TreeNode(val);
            ans->left = root;
            return ans;
        }
        queue<TreeNode*> q;
        q.push(root);
        int cur = 1;
        while (!q.empty()) {
            int n = q.size();
            while (n-- > 0) {
                TreeNode* p = q.front();
                q.pop();
                if (cur == depth - 1) {
                    TreeNode* addl = new TreeNode(val);
                    TreeNode* addr = new TreeNode(val);
                    addl->left = p->left, addr->right = p->right;
                    p->left = addl, p->right = addr;
                } else {
                    if (p->left != NULL) q.push(p->left);
                    if (p->right != NULL) q.push(p->right);
                }
            }
            cur++;
        }
        return root;
    }
};
```

**法2：dfs**

```PHP
class Solution {
public:
    // dfs
    int g_dep;
    int v;

    void dfs(TreeNode* root, int cur) {
        if (root == NULL) return;
        if (cur == g_dep - 1) {
            TreeNode* addl = new TreeNode(v);
            TreeNode* addr = new TreeNode(v);
            addl->left = root->left, addr->right = root->right;
            root->left = addl, root->right = addr;
        } else {
            dfs(root->left, cur + 1);
            dfs(root->right, cur + 1);
        }
    }

    TreeNode* addOneRow(TreeNode* root, int val, int depth) {
        g_dep = depth;
        v = val;
        if (g_dep == 1) {
            TreeNode* ans = new TreeNode(v);
            ans->left = root;
            return ans;
        }
        dfs(root, 1);
        return root;
    }
};
```



#### [654. 最大二叉树](https://leetcode.cn/problems/maximum-binary-tree/)：纯粹的递归 or 单调栈

**法1：递归**

```C++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    TreeNode* constructMaximumBinaryTree(vector<int>& nums) {
        return buildTree(nums, 0, nums.size() - 1);
    }
    TreeNode* buildTree(vector<int>& nums, int l, int r) {
        if (l > r) return NULL;
        int idx = l;
        for (int i = l; i <= r; i++) {
            if (nums[i] > nums[idx]) idx = i;
        }
        TreeNode* ans = new TreeNode(nums[idx]);
        ans->left = buildTree(nums, l, idx - 1);
        ans->right = buildTree(nums, idx + 1, r);
        return ans;
    }
};
```

**法2：单调栈？**

我们也可以边遍历边构造二叉树的各个节点，**用一个递减的单调栈**来存储元素，最后，栈底的元素就是整个二叉树的最大值，也就是根节点。

以 [3,2,1,6,0,5] 为例：

- 构造节点 3，入栈；
- 构造节点 2，它比栈顶元素 3 小，所以，它是 3 的右子节点，直接入栈；
- 构造节点 1，它比栈顶元素 2 小，所以，它是 2 的右子节点，直接入栈；
- 构造节点 6，它比栈顶元素 1 大，所以，1 是它的左子节点，弹出 1；同样地，栈顶元素 2 也比它小，弹出 2 并做为它的左子节点；把栈顶所有比它小的元素都弹出，最后弹出的是 3，所以，最终是 3 做为 6 的左子节点，并把 6 入栈；
- 构造节点 0，它比栈顶元素 6 小，所以，它是 6 的右子节点，直接入栈；
- 构造节点 5，它比栈顶元素 0 大，所以，0 是它的左子节点，弹出 0；接着比较，它比栈顶元素 6 小，所以，它是 6 的右子节点，入栈；
- 最后，栈中元素为 [6,5]，栈底元素为 6，是最终的根节点；

```C++
class Solution {
public:
    TreeNode* constructMaximumBinaryTree(vector<int>& nums) {
        stack<TreeNode*> st;
        for (int num : nums) {
            TreeNode* p = new TreeNode(num);
            // 如果新进来的数num比栈里面的大，要放在num的左子树上
            while (!st.empty() && num > st.top()->val) {
                p->left = st.top();
                st.pop();
            }
            // 新进来的数num比栈里面的小
            if (!st.empty()) st.top()->right = p;
            st.push(p);
        }
        while (st.size() != 1) st.pop();
        return st.top();
    }
};
```

> 感觉用vector会更简洁一些



#### [655. 输出二叉树](https://leetcode.cn/problems/print-binary-tree/)：dfs构造、输出

> 如果使用全局变量会更加简洁

```C++
class Solution {
public:
    int dfs_geth(TreeNode* root) {
        int h = 0;
        if (root->left != NULL) h = max(h, dfs_geth(root->left) + 1);
        if (root->right != NULL) h = max(h, dfs_geth(root->right) + 1);
        return h;
    }
    void dfs_print(vector<vector<string>>& ans, TreeNode* root, int x, int y, int h) {
        ans[x][y] = to_string(root->val);
        if (root->left != NULL) {
            dfs_print(ans, root->left, x + 1, y - (1 << (h - x - 1)), h);
        }
        if (root->right != NULL) {
            dfs_print(ans, root->right, x + 1, y + (1 << (h - x - 1)), h);
        }
    }
    vector<vector<string>> printTree(TreeNode* root) {
        int h = dfs_geth(root);
        int m = h + 1, n = (1 << (h + 1)) - 1;
        vector<vector<string>> ans(m, vector<string>(n, ""));
        dfs_print(ans, root, 0, (n - 1) / 2, h);
        return ans;
    }
};
```



#### [662. 二叉树最大宽度](https://leetcode.cn/problems/maximum-width-of-binary-tree/)：dfs

> 本题int对于下标idx不够用了？

```C++
class Solution {
public:
    unsigned long long ans;
    map<int, unsigned long long> mp;
    void dfs(TreeNode* root, unsigned long long idx, int depth) {
        if (root == NULL) return;
        if (mp.count(depth) == 0) mp[depth] = idx;
        ans = max(ans, idx - mp[depth] + 1);
        dfs(root->left, idx * 2, depth + 1);
        dfs(root->right, idx * 2 + 1, depth + 1);
    }
    int widthOfBinaryTree(TreeNode* root) {
        dfs(root, 1, 0);
        return (int)ans;
    }
};
```



#### [687. 最长同值路径](https://leetcode.cn/problems/longest-univalue-path/)：递归

设计递归函数 int dfs(TreeNode root)，含义为传入根节点 root，**返回以该节点为起点，往下走同值路径所能经过的最大节点数量**（即在路径中该节点不能作为根节点，不能同时往左右节点走），同时使用全局变量 max 记录答案路径所包含的节点数量。

在递归函数内部，先通过递归 root 的左右子节点，拿到以 root.left 和 root.right 为起点的最大节点数 l 和 r，然后根据当前节点值和左右子节点值的相等关系来更新 ans，同时**用 cur 维护「以当前节点 root 为目标路径中深度最小（位置最高）节点时」所经过的最大节点数量**。

```C++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    int n_max = 0;
    int dfs(TreeNode* root) {
        if (root == NULL) return 0;
        int cur = 1, ans = 1;
        int l = dfs(root->left);
        int r = dfs(root->right);
        
        if (root->left != NULL && root->left->val == root->val) {
            ans = l + 1;
            cur += l;
        }
        if (root->right != NULL && root->right->val == root->val) {
            ans = max(ans, r + 1);
            cur += r;
        }
        n_max = max(n_max, cur);
        
        return ans;
    }
    int longestUnivaluePath(TreeNode* root) {
        dfs(root);
        return max(n_max - 1, 0);
    }
};
```







#### [814. 二叉树剪枝](https://leetcode.cn/problems/binary-tree-pruning/)

```C++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    TreeNode* pruneTree(TreeNode* root) {
        if (root == NULL) return NULL;
        root->left = pruneTree(root->left);
        root->right = pruneTree(root->right);

        if (root->left != NULL || root->right != NULL) return root;
        return root->val == 0 ? NULL : root;
    }
};
```





#### [863. 二叉树中所有距离为 K 的结点](https://leetcode-cn.com/problems/all-nodes-distance-k-in-binary-tree/)：



#### [919. 完全二叉树插入器](https://leetcode.cn/problems/complete-binary-tree-inserter/)：bfs完全二叉树插入

```PHP
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class CBTInserter {
public:
    TreeNode* treeRoot;
    queue<TreeNode*> addin;

    CBTInserter(TreeNode* root) {
        this->treeRoot = root;
        queue<TreeNode*> q;
        q.push(treeRoot);

        while (!q.empty()) {
            TreeNode* p = q.front();
            q.pop();
            if (p->left != NULL) q.push(p->left);
            if (p->right != NULL) q.push(p->right);
            if (!(p->left && p->right)) addin.push(p);  // 非满，记录空位
        }
    }
    
    int insert(int val) {
        TreeNode* p = addin.front();
        int ret = p->val;   // 要先提前保存一下
        TreeNode* child = new TreeNode(val);
        
        if (p->left == NULL) {
            p->left = child;
        } else {
            p->right = child;
            addin.pop();
        }

        addin.push(child);
        return ret;
    }
    
    TreeNode* get_root() {
        return treeRoot;
    }
};
```





#### [938. 二叉搜索树的范围和](https://leetcode-cn.com/problems/range-sum-of-bst/)：同上bfs中



#### [965. 单值二叉树](https://leetcode.cn/problems/univalued-binary-tree/)：**模板题** dfs / bfs

**法1：dfs**

```C++
class Solution {
public:
    bool dfs(int val, TreeNode* root) {
        if (root == NULL) return true;
        if (root->val != val) return false;
        return dfs(root->val, root->left) && dfs(root->val, root->right);
    }
    bool isUnivalTree(TreeNode* root) {
        return dfs(root->val, root);
    }
};
```

或者升级版：

```C++
class Solution {
public:
    int val = -1;
    bool isUnivalTree(TreeNode* root) {
        if (val == -1) val = root->val;
        if (root == NULL) return true;
        if (root->val != val) return false;
        return isUnivalTree(root->left) && isUnivalTree(root->right);
    }
};
```

**法2：bfs**

```C++
class Solution {
public:
    bool isUnivalTree(TreeNode* root) {
        queue<TreeNode*> q;
        q.push(root);
        int val = root->val;
        while (!q.empty()) {
            TreeNode* node = q.front();
            q.pop();
            if (node == NULL) continue;
            if (node->val != val) return false;
            q.push(node->left);
            q.push(node->right);
        }
        return true;
    }
};
```



#### [998. 最大二叉树 II](https://leetcode.cn/problems/maximum-binary-tree-ii/)：常规模拟 ？

> 类似于[654. 最大二叉树](https://leetcode.cn/problems/maximum-binary-tree/)？

题意不是很好理解，先稍微解释一下吧。

大概意思是最大树 root 是根据特定的规则构造出来的，即给定的 root 其实对应一个具体的 nums，题目要求是**将 val 追加到 nums 的尾部**，然后再对得到的 nums 运用相同规则的构造，**返回重新构造的最大树头结点**。

根据构造规则，若有下标 i < j，则 nums[i] 必然在 nums[j] 水平线的左边，而 val 又是追加在原有 nums 的结尾。因此其最终位置分如下两种情况：

- val 为新 nums 中的最大值，同时 val 又是追加在原有 nums 的结尾，此时将原有的 root 挂在 val 对应节点的左子树即可，新树的根节点为 val 对应节点；
- 否则，我们只需要不断在 root 的右子树中找目标位置（反证法可以知，val 必不可能出现在任一非右位置，否则可推断出在 val 右边仍有元素，这与 val 位于 nums 的结尾位置冲突）。假设目标位置的父节点为 prev，目标位置的原节点为 cur，根据构造规则可知 prev.right = node 且 node.left = cur，新树的根节点不变。

```PHP
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    TreeNode* insertIntoMaxTree(TreeNode* root, int val) {
        TreeNode* node = new TreeNode(val);
        TreeNode* prev = NULL;
        TreeNode* cur = root;

        while (cur != NULL && cur->val > val) {
            prev = cur;
            cur = cur->right;
        }
        if (prev == NULL) {
            node->left = cur;
            return node;
        } else {
            prev->right = node;
            node->left = cur;
            return root;
        }
    }
};
```













#### [1022. 从根到叶的二进制数之和](https://leetcode.cn/problems/sum-of-root-to-leaf-binary-numbers/)：两种dfs写法

> 递归有使用**「函数返回值」**和**「全局变量」**两种实现方式。

法1：使用函数返回值

```PHP
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    int dfs(TreeNode* root, int cur) {
        int ans = 0;
        cur = cur * 2 + root->val;  // (cur << 1) + root.val
        if (root->left != NULL) ans += dfs(root->left, cur);
        if (root->right != NULL) ans += dfs(root->right, cur);
        return (root->left == NULL && root->right == NULL) ? cur : ans;
    }
    int sumRootToLeaf(TreeNode* root) {
        return dfs(root, 0);
    }
};
```

法2：全局变量

```PHP
class Solution {
public:
    int ans = 0;
    void dfs(TreeNode* root, int cur) {
        cur = cur * 2 + root->val;  // (cur << 1) + root.val
        if (root->left != NULL) dfs(root->left, cur);
        if (root->right != NULL) dfs(root->right, cur);
        if (root->left == NULL && root->right == NULL) ans += cur;
        return;
    }
    int sumRootToLeaf(TreeNode* root) {
        dfs(root, 0);
        return ans;
    }
};
```



#### [1302. 层数最深叶子节点的和](https://leetcode.cn/problems/deepest-leaves-sum/)：dfs or bfs

> 求的是：最深的叶节点之和

**法1：dfs**

```C++
class Solution {
public:
    int sum = 0;
    int maxdep = -1;
    int deepestLeavesSum(TreeNode* root) {
        dfs(root, 0);
        return sum;
    }
    void dfs(TreeNode* root, int depth) {
        if (root == NULL) return;
        
        if (depth > maxdep) {
            maxdep = depth;
            sum = root->val;
        } else if (depth == maxdep) {
            sum += root->val;
        }

        dfs(root->left, depth + 1);
        dfs(root->right, depth + 1);
    }
};
```

**法2：bfs**

```PHP
class Solution {
public:
    int deepestLeavesSum(TreeNode* root) {
        int sum = 0;
        queue<TreeNode*> q;
        q.push(root);
        while (!q.empty()) {
            sum = 0;
            int n = q.size();
            for (int i = 0; i < n; i++) {
                TreeNode* p = q.front();
                q.pop();
                sum += p->val;
                if (p->left != NULL) q.push(p->left);
                if (p->right != NULL) q.push(p->right);
            }
        }
        return sum;
    }
};
```



#### [1305. 两棵二叉搜索树中的所有元素](https://leetcode-cn.com/problems/all-elements-in-two-binary-search-trees/)：注意vector作为形参

![img](https://uestc.feishu.cn/space/api/box/stream/download/asynccode/?code=YWQzZTBlOTlkMmFkNjE4NDEwZGY1YTUyMDU2NzZmYzRfOEF1UElyNExWa3dySFBaQzhIdnRaS2hBTVZlOExGQklfVG9rZW46Ym94Y25pZDI4ZWhRbzd6R2RoeTk0a1JsN3NiXzE2NjI2NDE5MTE6MTY2MjY0NTUxMV9WNA)

- > **中序遍历的有序性；**

- > **将两个有序序列合并成一个有序序列则是利用了经典的「归并排序」**

```C++
// 中序遍历后，合并（归并排序）
class Solution {
public:
    void dfs(TreeNode* curNode, vector<int> &list)
    {
        if (curNode == NULL) return;
        dfs(curNode->left, list);
        list.push_back(curNode->val);
        dfs(curNode->right, list);
    }
    vector<int> getAllElements(TreeNode* root1, TreeNode* root2) {
        vector<int> ans;
        vector<int> list1, list2;
        dfs(root1, list1);
        dfs(root2, list2);
        int m = list1.size(), n = list2.size();
        int i = 0, j = 0;
        while(i < m || j < n) {
            int a = i < m ? list1[i] : INT_MAX;
            int b = j < n ? list2[j] : INT_MAX;
            if (a <= b) {
                ans.push_back(a);
                i++;
            }
            else {
                ans.push_back(b);
                j++;
            }
        }
        return ans;
    }
};
```



#### [面试题 04.06. 后继者](https://leetcode.cn/problems/successor-lcci/)：二叉搜索树的性质⭐

![img](https://uestc.feishu.cn/space/api/box/stream/download/asynccode/?code=Nzc0YzdkOWNmMTgzOGZmODNiODIyZjExMGU3YTU2NTVfTUg2Z0M2Yk10T1BvNnRNNEFwVHRkNTRXRVR0cVE0eERfVG9rZW46Ym94Y25HV01vWEpRYnhMczVRQkFjbzJxNEtlXzE2NjI2NDE5MTE6MTY2MjY0NTUxMV9WNA)![img](https://uestc.feishu.cn/space/api/box/stream/download/asynccode/?code=M2U4NGNjN2E1MTkyM2IwMWMwNGU5OGE4MTE5ZmM5OTVfUjg3eTlyN1FtOVdWQ3JwTjJxR1BLZ3BldWFZNlVPM3lfVG9rZW46Ym94Y25seDR6WWtQVlU3VUtndEtybVpDQzRmXzE2NjI2NDE5MTE6MTY2MjY0NTUxMV9WNA)

- > 当`root.val<=p.val`时，去root右子树上找p，返回结果一定在`root.right`上；所以递归到右子树，无右子树则返回NULL

- > 当`root.val>p.val`时，去root左子树上找p，p一定在`root.left`上；如果p有右子树，返回递归到右子树，无右子树则返回root

- > 再者：如果p是左子树上的，返回p的`root`；如果p是右子树上的，返回`p.right`（看p相对于上一个是左是右）

- > 特殊一点的：p=4需要返回5

```C++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
 * };
 */
class Solution {
public:
    TreeNode* inorderSuccessor(TreeNode* root, TreeNode* p) {
        if (root == NULL) return NULL;
        if (p->val >= root->val)
            return inorderSuccessor(root->right, p);
        TreeNode* ans = inorderSuccessor(root->left, p);  // 默认往左走
        return ans == NULL ? root : ans;
    }
};
```

**法2：中序遍历⭐**

BST的性质，中序遍历的方式似乎好理解一些：思路是，**深度优先**，用中序遍历恢复出递增的序列

```C++
class Solution {
public:
    bool isFind = false;
    TreeNode* ans;
    void dfs(TreeNode* curRoot, TreeNode* p) {
        if (curRoot == NULL) return;    // 先判空
        dfs(curRoot->left, p);          // 左子树
        if (isFind) {                   // 是否已经找到p，若已找到，当前就是要返回的
            if (ans == NULL) ans = curRoot;
            return;
        }
        if (curRoot->val == p->val) isFind = true;
        dfs(curRoot->right, p);        // 右子树
    }
    TreeNode* inorderSuccessor(TreeNode* root, TreeNode* p) {
        dfs(root, p);
        return ans;
    }
};
```





## (6)链表

#### [剑指 Offer II 029. 排序的循环链表](https://leetcode.cn/problems/4ueAj6/)：链表作循环队列

```PHP
/*
class Node {
public:
    int val;
    Node* next;
    Node() {}
    Node(int _val) {
        val = _val;
        next = NULL;
    }
    Node(int _val, Node* _next) {
        val = _val;
        next = _next;
    }
};
*/

class Solution {
public:
    Node* insert(Node* head, int insertVal) {
        if (head == NULL) {
            Node* ans = new Node(insertVal);
            ans->next = ans;
            return ans;
        }
        Node* p = head;
        while (!(p->val <= insertVal && insertVal <= p->next->val)) {
            p = p->next;
            if (p == head || (p->val > p->next->val && (insertVal >= p->val || insertVal <= p->next->val))) break;
        }
        p->next = new Node(insertVal, p->next);
        return head;
    }
};
```



## (7)哈希表

无法复制加载中的内容



#### [398. 随机数索引](https://leetcode-cn.com/problems/random-pick-index/)：双解，哈希or蓄水池抽样

> 题目并没有很看懂

**法1：哈希表**

```C++
class Solution {
public:
    unordered_map<int, vector<int>> position;  // 用哈希表记录相同元素下标位置⭐
    Solution(vector<int>& nums) {
        for (int i = 0; i < nums.size(); ++i) {
            position[nums[i]].push_back(i);
        }
    }
    
    int pick(int target) {
        auto idx = position[target];  // 取target下标构成列表
        return idx[rand() % idx.size()];
    }
};
```



#### [442. 数组中重复的数据](https://leetcode-cn.com/problems/find-all-duplicates-in-an-array/)：原地哈希

自己的解法可能会浪费空间，

```C++
vector<int> findDuplicates(vector<int>& nums) {
    int n = nums.size();
    vector<bool> isExist(n, false);
    vector<int> ans;
    for (int i = 0; i < n; ++i) {
        if (!isExist[nums[i] - 1])
            isExist[nums[i] - 1] = true;
        else ans.push_back(nums[i]);
    }
    return ans;
}
```

- > 直接使用哈希表，把次数为2的数字输出：不满足复杂度要求；

- > **原地哈希：**`**h(value) = value - 1**`

> 题目说：nums 的所有整数都在范围 [1, n] 内，那可能不难想到要使用**原地哈希**的方法，简单来说，就是将题目给的数组当成一个哈希表

> 为什么要构建这样的一个哈希函数呢？首先，我们的数组下标是[0, n - 1]的，而数据范围是 [1, n]，如果数据范围内的数字每个都出现一次，那么很容易就能找到nums[val - 1] = val的哈希函数使得每个数值不重不漏的映射到唯一的数组下标，并填满整个数组。

> 若有整数出现不止一次，那么必定某些数值缺少，而缺失数值的位置被重复的数值占据了，我们只需调整数组满足上述的哈希映射，即可很容易找到重复的数据。

![img](https://uestc.feishu.cn/space/api/box/stream/download/asynccode/?code=YzUxYTVhYzBjNGUyZmQ2YTI5MGM2OWYxMWNmNzRiNTlfbnp2VUhyZVE5U2tsQTJ1WjJYWjh4TUVSRzFXeUQ0MnFfVG9rZW46Ym94Y25CVXRndVFzU0Jlak1TaHlGRGRIWDlHXzE2NjI2NDE5MTE6MTY2MjY0NTUxMV9WNA)

原地哈希的实现是交换元素位置：**每一次交换操作会使得至少一个元素被交换到对应的正确位置**

1. 一个不太好的写法：

```C++
    vector<int> findDuplicates(vector<int>& nums) {
        vector<int> ans;
        int n = nums.size();
        for (int i = 0; i < n; i++) {
            if (nums[i] < 0 || nums[i] - 1 == i) continue;
            if (nums[nums[i] - 1] == nums[i]) {
                ans.push_back(nums[i]);
                nums[i] *= -1;
            }
            else {
                int c = nums[nums[i] - 1];
                nums[nums[i] - 1] = nums[i];
                nums[i--] = c;
            }
        }
        return ans;
    }
```

1. 第二种写法⭐：

```C++
vector<int> findDuplicates(vector<int>& nums) {
    int n = nums.size();
    for (int i = 0; i < n; ++i) {                 // 遍历nums上的每一位
        while (nums[i] != nums[nums[i] - 1]) {    // 保证每一次i位上都有正确的数
            swap(nums[i], nums[nums[i] - 1]);
        }
    }
    vector<int> ans;
    for (int i = 0; i < n; ++i) {
        if (nums[i] - 1 != i) {
            ans.push_back(nums[i]);
        }
    }
    return ans;
}
```

1. 直接**用正负号做标记**，进一步简化⭐：负数说明已经至少出现过一次

![img](https://uestc.feishu.cn/space/api/box/stream/download/asynccode/?code=NjgxNmE2MzJiY2VmM2MyNzdhYWVmZGYwNTlmNjA2NWZfU1JsNnVPdTBzV0pXNUlGR1pzYTFmTm0wRzRKZmIyVzdfVG9rZW46Ym94Y25oSzJDRHJHc29QMFdvTTRCSDRsWm9lXzE2NjI2NDE5MTE6MTY2MjY0NTUxMV9WNA)

```C++
vector<int> findDuplicates(vector<int>& nums) {
    int n = nums.size();
    vector<int> ans;
    for (int i = 0; i < n; ++i) {
        int x = abs(nums[i]);
        if (nums[x - 1] > 0) {
            nums[x - 1] = -nums[x - 1];
        }
        else {
            ans.push_back(x);
        }
    }
    return ans;
}
```



#### [1001. 网格照明](https://leetcode-cn.com/problems/grid-illumination/)：哈希表+set，线性映射模拟❗

![img](https://uestc.feishu.cn/space/api/box/stream/download/asynccode/?code=MjBlMjNkMjBkNWIzODc5ZmU1ODZiMzQxOTI1N2RlNGFfNFVlTHdSbFNHYWpmZEpWR1Z6WVpBTWZoYUFodXFqb1VfVG9rZW46Ym94Y25nREs5d09URlM5M3ZTNWdRaFhqblpiXzE2NjI2NDE5MTE6MTY2MjY0NTUxMV9WNA)

> 再看看原题！



#### [1282. 用户分组](https://leetcode.cn/problems/group-the-people-given-the-group-size-they-belong-to/)：哈希表实现分组操作

```C++
class Solution {
public:
    vector<vector<int>> groupThePeople(vector<int>& gs) {
        unordered_map<int, vector<int>> map;
        int n = gs.size();
        for (int i = 0; i < n; i++) {
            int size = gs[i];
            map[size].push_back(i);
        }
        vector<vector<int>> ans;
        for (auto &[size, p] : map) {
            int m = p.size() / size;
            for (int i = 0; i < m; i++) {
                vector<int> tmp;
                int start = i * size;
                for (int j = 0; j < size; j++) tmp.push_back(p[start + j]);
                ans.push_back(tmp);
            }
        }
        return ans;
    }
};
```





#### [2006. 差的绝对值为 K 的数对数目](https://leetcode-cn.com/problems/count-number-of-pairs-with-absolute-difference-k/)：要想到用map（哈希表）

**法1：直接朴素地进行简单模拟**

```C++
class Solution {
public:
    int countKDifference(vector<int>& nums, int k) {
        int n = nums.size(), ans = 0;
        for (int i = 0; i < n; i++){
            for (int j = i + 1; j < n; j++){
                if (abs(nums[i] - nums[j]) == k)
                    ans++;
            }
        }
        return ans;
    }
};
class Solution:
    def countKDifference(self, nums: List[int], k: int) -> int:
        n, m = 0, len(nums)
        for i in range(m-1):
            for j in range(i, m):
                if abs(nums[i] - nums[j]) == k:
                    n += 1
        return n
```

**法2：哈希表**

**再来说得深入一点：【三叶】の题解**

![img](https://uestc.feishu.cn/space/api/box/stream/download/asynccode/?code=YjZiOTJhM2ZhMWI2NzQzYzFjZmE3Y2ViMDMyMzk1M2NfaEMxd1ZlUDdKVHBpTHZuSjZGd3ZiRjMyUDVBRk9QZW9fVG9rZW46Ym94Y25UTFFzSUdOS2FvMEE0MGpUZ2NFRVdlXzE2NjI2NDE5MTE6MTY2MjY0NTUxMV9WNA)

![img](https://uestc.feishu.cn/space/api/box/stream/download/asynccode/?code=ZDc5ZGEwMjgzN2MxMGQ0YmQ1YzUyZmIwZjQzYWMyNDFfcEVqbDg1WXRYQTlWMHo4bHh3SmJtS0c3T285Y1VSd0VfVG9rZW46Ym94Y250NWExVHJHNmNiTTNPT1JWMWtsbUVlXzE2NjI2NDE5MTE6MTY2MjY0NTUxMV9WNA)

于是，遍历一遍，把每个元素的对应两个值记录到哈希表中：

```C++
class Solution {
public:
    int countKDifference(vector<int>& nums, int k) {
        unordered_map<int, int> cnt;
        int ans = 0;
        for (auto n : nums) {
            cnt[n]++;
            ans += cnt[n-k];
            ans += cnt[n+k];
        }
        return ans;
    }
};
```

升级解法：用数组代替哈希表进行提速（多亏题目说nums[i]<100）

```C++
class Solution {
public:
    int countKDifference(vector<int>& nums, int k) {
        int cnt[101] = {0};
        int ans = 0;
        for (auto n : nums) {
            cnt[n]++;
            if (n-k>0) ans += cnt[n-k];
            if (n+k<101) ans += cnt[n+k];
        }
        return ans;
    }
};
```







## (8)堆/优先队列

#### [1005. K 次取反后最大化的数组和 ](https://leetcode-cn.com/problems/maximize-sum-of-array-after-k-negations/)？？？



## (9)树

#### [1719. 重构一棵树的方案数](https://leetcode-cn.com/problems/number-of-ways-to-reconstruct-a-tree/)：❓❓困难题

> 说实话，题意没看懂。。。

> 参考【微扰理论】の题解

![img](https://uestc.feishu.cn/space/api/box/stream/download/asynccode/?code=ZWNiMWYxZDU3NDhiMTUwNDcxY2ZjYmM1ODhiZjhhZTJfemllbjFDYzBnc2tlQTQ1R0szMWFzS2VVd0RSN3JZdFJfVG9rZW46Ym94Y25RYjdLUnlqUWxlVlhJdG50blJYRVpjXzE2NjI2NDE5MTE6MTY2MjY0NTUxMV9WNA)

![img](https://uestc.feishu.cn/space/api/box/stream/download/asynccode/?code=ZTBjOTE2ODRkZWJhYjVmMWZkMjI1NTY5MTJkYjM5YjFfZkZ0dUJEUHZvWkdTaUdYQWZmeFMyNWpPb1BDZDdKc2pfVG9rZW46Ym94Y24yWVZLTXowQ2pSenpUbjE3RE0xYmNiXzE2NjI2NDE5MTE6MTY2MjY0NTUxMV9WNA)

![img](https://uestc.feishu.cn/space/api/box/stream/download/asynccode/?code=MDA1N2QxMDQ3YTAwZDQ3ODBjNTgzYjJlMDdiOGU3MmZfaVhIRzVRUzlQUTF4dG44aGJyeVBkRFBYbllJUmhSUThfVG9rZW46Ym94Y24xVjFhTThRRk94dGwxMmtGbG91MzFmXzE2NjI2NDE5MTE6MTY2MjY0NTUxMV9WNA)





# 子串匹配

#### [28. 实现 strStr()](https://leetcode-cn.com/problems/implement-strstr/)：若用模式匹配 KMP

使用find内置函数当然可以解题，两次遍历的方法也可以；但是，这里介绍的是：KMP算法！







#### [686. 重复叠加字符串匹配](https://leetcode-cn.com/problems/repeated-string-match/)：子串匹配 多解⭐

![img](https://uestc.feishu.cn/space/api/box/stream/download/asynccode/?code=NzViOWZiOTViZTY1NzkxM2E5NTExMWUxNzdjNDVlNzdfakQ3TE9hZzBsSnhjVGZJeVk3RjBmNFU4ODFEZ0hzS3FfVG9rZW46Ym94Y24yZHp3bmhtRVg3WVRIQmhwVk9aR3dVXzE2NjI2NDE5MTE6MTY2MjY0NTUxMV9WNA)

**基本分析：**

首先，可以分析复制**次数**的「下界」和「上界」为何值：

对于**「下界」**的分析是容易的：**至少将 a 复制长度大于等于 b 的长度**，才有可能匹配。

在明确了「下界」后，再分析再经过多少次复制，能够明确得到答案，能够得到明确答案的最小复制次数即是上界。画个图！

由于主串是由 a 复制多次而来，并且是从主串中找到子串 b，因此可以明确子串的起始位置，不会超过 a 的长度。即长度越过 a 长度的起始匹配位置，必然在此前已经被匹配过了。

由此，我们可知复制次数**「上界」最多为「下界 + 1」**。

- 令 a 的长度为 n，b 的长度为 m，下界次数为 c1，上界次数为 c2 = c1 + 1。
- 因此我们可以对 a 复制 c2 次，得到主串后匹配 b，如果匹配成功后的结束位置不超过了 n * c1，说明复 c1即可，返回c1，超过则返回c2；匹配不成功则返回-1。



**法1：直接上下界控制+直接用C++内置函数find()**

```C++
class Solution {
public:
    int repeatedStringMatch(string a, string b) {
        string s = a;
        int ans = 1;  //下界
        while(s.size() < b.size()){ //不是<=，注意边界⭐
            s += a;  //s.append(a);
            ans++;
        }
        s += a;  //直接与上界次数的进行子串匹配
        size_t fd = s.find(b);
        if(fd == string::npos) return -1;
        return fd + b.size() > a.size() * ans ? ans + 1 : ans;
    }
};
```

python的代码更好看一些：

```Python
class Solution:
    def repeatedStringMatch(self, a: str, b: str) -> int:
        s = a
        ans = 1
        while len(s) < len(b):
            s += a
            ans += 1
        s += a
        fd = s.find(b)
        if(fd == -1): return -1
        return ans + 1 if fd + len(b) > len(a) * ans else ans
```



**法2：KMP算法**

关于KMP初次，在：[28. 实现 strStr()](https://leetcode-cn.com/problems/implement-strstr/)



**法3：Rabin-Karp**

见官方题解的讲解





#### [1044. 最长重复子串](https://leetcode-cn.com/problems/longest-duplicate-substring/)：？没做

![img](https://uestc.feishu.cn/space/api/box/stream/download/asynccode/?code=YWY4YWMxZmQ1MDU5NWVmNmUyZGI5OTQzZDk3NzQzZmRfVmJVOXdYQkpLbEJkQ0JyYzRoQVMzdWt2ell3N3ZRcGlfVG9rZW46Ym94Y25LQzZlbUQxT1FRWFRuM2p0ZjFPUHVkXzE2NjI2NDE5MTE6MTY2MjY0NTUxMV9WNA)

**法0：python暴力解法**

```Python
class Solution:
    def longestDupSubstring(self, s: str) -> str:
        ans = ""
        for i in range(len(s)):
            while s[i:i+len(ans)+1] in s[i+1:]:
                ans = s[i:i+len(ans) + 1]
        return ans
```



**法1：字符串哈希+二分**

![img](https://uestc.feishu.cn/space/api/box/stream/download/asynccode/?code=NzNjODg0MjMyMzA5ZTcwMjU0YWMyMGI5OTJhYjVjZmRfRVd2Sm9xbkE1VjVKOGc5UFdFVnNzMm5oRFg1bzVrWHFfVG9rZW46Ym94Y25kSDcxZ0pGOERZUGFwN0lCdGVCR1ZoXzE2NjI2NDE5MTE6MTY2MjY0NTUxMV9WNA)









**法1：Rabin-Karp**

> 参见微扰的题解，

![img](https://uestc.feishu.cn/space/api/box/stream/download/asynccode/?code=NDNhZTk2YTBiNGY3ZTdiNWJkY2MxYTU0NDgxNTVjY2VfaXlyanZLSWRWalQwY0tOak40SVVLWmJnMzV2NHo1b0NfVG9rZW46Ym94Y254NHNONzZYRU83UTdqV1dzdU9YSGVlXzE2NjI2NDE5MTE6MTY2MjY0NTUxMV9WNA)

![img](https://uestc.feishu.cn/space/api/box/stream/download/asynccode/?code=YTg1OGI5MzYzMDM0OGI3Njc3ZTUwYTg1MzIzNTY1OTVfTzBPd3ZPelBLSkV4c0N4SHAxeEdicndWQ0dkYWxlSlRfVG9rZW46Ym94Y25JbUY0dnpCZUNaOHF4elE2Wm1DTU13XzE2NjI2NDE5MTE6MTY2MjY0NTUxMV9WNA)

![img](https://uestc.feishu.cn/space/api/box/stream/download/asynccode/?code=NWFmNDZkNzMyMWFkMmVhZjU5ODU3NGY3ODA2N2IzNjRfY0VYU3pPZFVjelZRcFlLc2RLSWdPM1ZDNlk0MTZFRUxfVG9rZW46Ym94Y25CYmlIdDd6V3FxaEhyeTMySjFTNXpmXzE2NjI2NDE5MTE6MTY2MjY0NTUxMV9WNA)











# 排序

无法复制加载中的内容

#### [937. 重新排列日志文件](https://leetcode-cn.com/problems/reorder-data-in-log-files/)：自定义规则排序

> 注意一下自定义排序书写方法

![img](https://uestc.feishu.cn/space/api/box/stream/download/asynccode/?code=Y2FkMzE3ZmUwYTY4MmViMjY0Mzc1ZjJhZmFiMzMxZGNfMUhsNnFCTHZHeW1GNWZZODA1TEFRWTRvRWpNYUlwN0ZfVG9rZW46Ym94Y244dmpFcXptdFBLNm5mMloza2NpYkdnXzE2NjI2NDE5MTE6MTY2MjY0NTUxMV9WNA)

![img](https://uestc.feishu.cn/space/api/box/stream/download/asynccode/?code=YTFmY2U1ZjMzYmYyZTZkZmJkNDkzMmZmNDdmNzUzZjdfVzZabXBWeVJ2U0U1TDB2U0FSS000OHF0UEZrdkNUa1BfVG9rZW46Ym94Y256QmoxQktjZEdDbVVZcnU0aGFMTXBGXzE2NjI2NDE5MTE6MTY2MjY0NTUxMV9WNA)

```C++
class Solution {
public:
    static bool logCompare(string log1, string log2)
    {
        int i = log1.find(' '), j = log2.find(' ');
        if (log1.substr(i + 1) != log2.substr(j + 1)) {
            return log1.substr(i + 1) < log2.substr(j + 1);
        }
        return log1 < log2;
    }

    vector<string> reorderLogFiles(vector<string>& logs) {
        int n = logs.size();
        if (n <= 1) return logs;
        vector<string> digit, letter;
        for (int i = 0; i < n; ++i) {
            int j = logs[i].find(' ');
            if (isdigit(logs[i][j + 1])) {
                digit.push_back(logs[i]);
            }
            else {
                letter.push_back(logs[i]);
            }
        }
        // 自定义规则对字母日志排序
        sort(letter.begin(), letter.end(), logCompare);
        letter.insert(letter.end(), digit.begin(), digit.end());
        return letter;
    }
};
```





# 回溯算法

无法复制加载中的内容

#### [1219. 黄金矿工](https://leetcode-cn.com/problems/path-with-maximum-gold/)：dfs解决⚒ dx,dy+vis

**dx, dy控制移动方向：**类似的参考，“图论-1034.边界着色”中，注意dx, dy移动方法

还有一个注意的：**dfs函数的参数**

- 本题可以当作模板题

移动方法+dfs的写法1：

```C++
class Solution {
public:
    vector<vector<int>> g;  // 为了gird能全局地访问⭐
    vector<vector<bool>> vis;
    int m, n;
    int dx[4] = {1, -1, 0, 0};
    int dy[4] = {0, 0, 1, -1};
    
    int getMaximumGold(vector<vector<int>>& grid) {
        m = grid.size();  // m行
        n = grid[0].size();  // n列
        g = grid;
        vis = vector<vector<bool>>(m, vector<bool>(n));
        int ans = 0;
        for(int i = 0; i < m; ++i)
            for(int j = 0; j < n; ++j) {
                vis[i][j] = true;
                ans = max(ans, dfs(i, j));
                vis[i][j] = false;
            }
        return ans;
    }

    int dfs(int i, int j) {
        int ans = g[i][j];
        for(int k = 0; k < 4; ++k){
            int x = i + dx[k], y = j + dy[k];
            if(x >= m || y >= n || x < 0 || y < 0) continue;
            if(g[x][y] == 0) continue;
            if(vis[x][y]) continue;
            vis[x][y] = true;
            ans = max(ans, g[i][j] + dfs(x, y));
            vis[x][y] = false;
        }
        return ans;
    }
};
```

其中如注释所说，专门定义一个vector<vector<int>> g 是为了gird数组能全局地访问⭐，当然还有一种方法，如下，在**dfs函数的参数**的地方有区别！

另外，关于vis数组的创建和初始化，两种方法

```C++
方法1：
visited = vector<vector<bool>>(m, vector<bool>(n, false));
visited = vector<vector<int>>(m, vector<int>(n, 0));

方法2：这里用的就是另一种，
直接创建 vis = vector<vector<bool>>(m, vector<bool>(n));
然后再循环中初始化
```

移动写法2：

```C++
public:
    vector<vector<int>> direct = {{1,0},{-1,0},{0,1},{0,-1}};  
    int getMaximumGold(vector<vector<int>>& grid) {...}
    int dfs(int i, int j) {
        int ans = g[i][j];
        for(auto d : direct){
            int x = i + d[0], y = j + d[1];
            ...
        }
        return ans;
    }
```

**python写法：**

```Python
class Solution:
    def getMaximumGold(self, grid: List[List[int]]) -> int:
        m, n = len(grid), len(grid[0])  # 计算 List[List[int]] m行n列
        ans = 0         
        
        def dfs(x, y):
            if x < 0 or y < 0 or x == m or y == n or not grid[x][y]:
                return 0
            record = grid[x][y]
            grid[x][y] = mx = 0
            for dx, dy in (0, 1), (1, 0), (0, -1), (-1, 0):
                mx = max(mx, dfs(x + dx, y + dy))
            grid[x][y] = record
            return record + mx
                
        for i in range(m):
            for j in range(n):
                ans = max(ans, dfs(i, j))
        
        return ans
```









# 图论

## (1)dfs / bfs

#### [1034. 边界着色](https://leetcode-cn.com/problems/coloring-a-border/)：dfs 理解题意 四个方向 vis

四个方向只要有一个与自己颜色不同则就在边界上！

```C++
class Solution {
public:
    vector<vector<int>> visited;  //记录当前[i][j]是否被访问过
    int m, n;  //m行 n列
    int dx = {0, 0, -1, 1}  //横向移动：上，下，左，右
    int dy = {1, -1, 0, 0}  //纵向移动：上，下，左，右
    vector<vector<int>> colorBorder(vector<vector<int>>& grid, int row, int col, int color) {
        // 注意二维vector的行列数计算⭐
        m = grid.size();
        n = grid[0].size();
        // 不要忘记visited也要创建和初始化
        visited = vector<vector<int>>(m, vector<int>(n, 0));

        target = grid[row][col];
        dfs(grid, row, col, target);  //根据指定的颜色，开始深度优先搜索

        //搜索完成后，直接遍历整个数组，更改颜色
        for(int i = 0; i < m; ++i){
            for(int j = 0; j < n; ++j){
                if(grid[i][j] == 0){
                    grid[i][j] = color;
                }
            }
        }
        return grid;
    }

    void dfs(vector<vector<int>>& grid, int row, int col, int target) {
        //target是起始点参考用的颜色grid[row][col]
        if(visited[row][col]) return;
        visited[row][col] = 1;
        if(grid[row][col] != target) return;

        int cnt = 0;  //记录四个方向尝试的次数，用来区分“连通集内”的边界与非边界
        for(int i = 0; i < 4; ++i){
            // 考虑当前(row,col)移动某方向后的(x,y)
            int x = row + dx[i];
            int y = col + dy[i];
            if(0 <= x < m && 0 <= y < n){
                if(grid[x][y] == target || grid[x][y] == 0){
                    // 注意 grid[x][y] == 0 也要包含在内⭐
                    dfs(grid, x, y, target);
                    cnt++;
                }
            }
        }
        if(cnt != 4) grid[row][col] = 0;  //把0作为特殊色，因为据题意，所有的值都不会是0
    }
};
class Solution:
    def colorBorder(self, grid: List[List[int]], row: int, col: int, color: int) -> List[List[int]]:
        m, n = len(grid), len(grid[0])
        visited = [[False] * n for _ in range(m)]
        borders = []  # 记录边界的坐标(i,j)
        target = grid[row][col]

        self.dfs(grid, row, col, visited, borders, target)
        for x, y in borders:
            grid[x][y] = color
        return grid

    def dfs(self, grid, row, col, visited, borders, target):  
        visited[row][col] = True
        isBorder = False

        m, n = len(grid), len(grid[0])
        direc = ((-1, 0), (1, 0), (0, -1), (0, 1))

        for dx, dy in direc:
            x, y = row + dx, col + dy
            if 0 <= x < m and 0 <= y < n and grid[x][y] == grid[row][col]:
                if not visited[x][y]:
                    self.dfs(grid, x, y, visited, borders, target)
            else:
                isBorder = True  #说明(x,y)与矩阵边界或颜色不同点相邻，因此该点为连通块边界
        if isBorder:
            borders.append((row, col))
```

#### [200. 岛屿数量](https://leetcode-cn.com/problems/number-of-islands/)：是同类题

```C++
class Solution {
public:
    int m, n;

    int numIslands(vector<vector<char>>& grid) {
        //m行 n列
        m = grid.size();
        n = grid[0].size();
        // if (!m) return 0;

        int num = 0;
        for (int i = 0; i < m; ++i) {
            for (int j = 0; j < n; ++j) {
                if (grid[i][j] == '1') {
                    num++;
                    dfs(grid, i, j);
                }
            }
        }
        return num;
    }

    void dfs(vector<vector<char>>& grid, int row, int col){
        grid[row][col] = '0';
        if(row-1>=0 && grid[row-1][col] == '1') dfs(grid, row-1, col);
        if(row+1<m && grid[row+1][col] == '1') dfs(grid, row+1, col);
        if(col-1>=0 && grid[row][col-1] == '1') dfs(grid, row, col-1);
        if(col+1<n && grid[row][col+1] == '1') dfs(grid, row, col+1);
    }
};
```





## (2)拓扑排序

#### [851. 喧闹和富有](https://leetcode-cn.com/problems/loud-and-rich/)：❗拓扑 or dfs

> 看起来不太适合作为拓扑的入门

> 补一下：**[拓扑排序入门](https://mp.weixin.qq.com/s?__biz=MzU4NDE3MTEyMA==&mid=2247489706&idx=1&sn=771cd807f39d1ca545640c0ef7e5baec&chksm=fd9cb3b5caeb3aa333809633f09e3967c8f62d10feec5a463c7e30d4781e1fecb50e7f46e4af&token=126965152&lang=zh_CN#rd)**

```C++
class Solution {
public:
    // 需要使用全局变量了！
    vector<int> ans;  // 全局使用
    vector<int> quiet;
    vector<vector<int>> g;  // n行的，比i更有钱邻接矩阵
    vector<int> loudAndRich(vector<vector<int>>& richer, vector<int>& _quiet) {
        quiet = _quiet;
        int n = quiet.size();
        ans = vector<int>(n, -1);
        g = vector<vector<int>>(n);
        // 将拓扑排序图存入矩阵
        for(auto r : richer)
            g[r[1]].push_back(r[0]);
        // dfs
        for(int i = 0; i < n; ++i)
            dfs(i);
        return ans;
    }
    int dfs(int i){
        if(ans[i] != -1)
            return ans[i];
        else ans[i] = i;
        // 对比i有钱的所有节点遍历搜寻（在邻接矩阵中找）
        for(auto n : g[i]){
            if(quiet[dfs(n)] < quiet[ans[i]])
                ans[i] = dfs(n);
        }
        return ans[i];
    }
};
class Solution {
public:
    vector<int> loudAndRich(vector<vector<int>>& richer, vector<int>& quiet) {
        int n = quiet.size();
        vector<vector<int>> g(n);
        vector<int> inDegree(n);       
        // 将拓扑排序图存入矩阵+入度
        for(auto r : richer){
            g[r[0]].push_back(r[1]);  //这里与dfs不同！
            ++inDegree[r[1]];
        }
        vector<int> ans(n);
        for(int i = 0; i < n; ++i) ans[i] = i;      
        queue<int> que;
        for(int i = 0; i < n; ++i){
            if(inDegree[i] == 0)
                que.push(i);
        }
        // 拓扑：从入度为0的结点开始（从更有钱的开始，与dfds那个不同）
        while(!que.empty()){
            int x = que.front();
            que.pop();
            for(auto y : g[x]){
                if(quiet[ans[y]] > quiet[ans[x]])
                    ans[y] = ans[x];
                if(--inDegree[y] == 0)
                    que.push(y);
            }
        }
        return ans;
    }
};
```



#### [剑指 Offer II 114. 外星文字典](https://leetcode.cn/problems/Jf1JuT/)

> 困难题，没做。。



## (3)最短路径



## (4)最小生成树









# 递归 & 迭代

## DFS

无法复制加载中的内容



#### 208.Trie树：this? 模板

```C++
class Trie {
private:
    vector<Trie*> children;
    bool isEnd;

    Trie* searchPrefix(string prefix) {
        Trie* node = this;
        for (char ch : prefix) {
            ch -= 'a';
            if (node->children[ch] == nullptr) {
                return nullptr;
            }
            node = node->children[ch];
        }
        return node;
    }

public:
    Trie() : children(26), isEnd(false) {}

    void insert(string word) {
        Trie* node = this;
        for (char ch : word) {
            ch -= 'a';
            if (node->children[ch] == nullptr) {
                node->children[ch] = new Trie();
            }
            node = node->children[ch];
        }
        node->isEnd = true;
    }

    bool search(string word) {
        Trie* node = this->searchPrefix(word);
        return node != nullptr && node->isEnd;
    }

    bool startsWith(string prefix) {
        return this->searchPrefix(prefix) != nullptr;
    }
};
class Trie:
    def __init__(self):
        self.children = [None] * 26
        self.isEnd = False
    
    def searchPrefix(self, prefix: str) -> "Trie":
        node = self
        for ch in prefix:
            ch = ord(ch) - ord("a")
            if not node.children[ch]:
                return None
            node = node.children[ch]
        return node

    def insert(self, word: str) -> None:
        node = self
        for ch in word:
            ch = ord(ch) - ord("a")
            if not node.children[ch]:
                node.children[ch] = Trie()
            node = node.children[ch]
        node.isEnd = True

    def search(self, word: str) -> bool:
        node = self.searchPrefix(word)
        return node is not None and node.isEnd

    def startsWith(self, prefix: str) -> bool:
        return self.searchPrefix(prefix) is not None
        
# Your Trie object will be instantiated and called as such:
# obj = Trie()
# obj.insert(word)
# param_2 = obj.search(word)
# param_3 = obj.startsWith(prefix)
```





#### 221.添加与搜索单词



#### [241. 为运算表达式设计优先级](https://leetcode.cn/problems/different-ways-to-add-parentheses/)：拆分式子⭐

> 这个题解写得比较好！！

```C++
class Solution {
public:
    vector<int> diffWaysToCompute(string exp) {
        vector<int> ans;
        int n = exp.size();
        // 整数不超过两位数
        if (n == 1 || n == 2) {
            ans.push_back(stoi(exp));
            return ans;
        }

        for (int i = 0; i < n; i++) {
            int x = exp[i];
            if (x == '+' || x == '-' || x == '*') {
                vector<int> leftExp = diffWaysToCompute(exp.substr(0, i));
                vector<int> rightExp = diffWaysToCompute(exp.substr(i + 1));

                // 分治 dfs
                for (int left : leftExp) {
                    for (int right : rightExp) {
                        switch (x) {
                            case '+': ans.push_back(left + right); break;
                            case '-': ans.push_back(left - right); break;
                            case '*': ans.push_back(left * right); break;
                        }
                    }
                } 
            }
        }
        return ans;
    }
};
```



#### [473. 火柴拼正方形](https://leetcode.cn/problems/matchsticks-to-square/)：⭐很棒的解法，居然是用dfs

> 剪纸？

```C++
class Solution {
public:
    int m;
    int edgs[4] = {0};
    bool makesquare(vector<int>& match) {
        if (match.size() < 4) return false;
        int sum = accumulate(match.begin(), match.end(), 0);
        if (sum % 4 != 0) return false;
        m = sum / 4;
        sort(match.begin(), match.end(), greater<int>());  // 从大到小排序，优先选用大边可以令不成功的情况更快返回
        return dfs(match, 0);
    }
    bool dfs(vector<int>& match, int idx) {
        if (idx >= match.size()) {
            return edgs[0] == edgs[1] && edgs[1] == edgs[2] && edgs[2] == m;
        }
        for (int i = 0; i < 4; i++) {
            if (edgs[i] + match[idx] > m) continue;  // 这根火柴不能放到当前边上
            else {
                edgs[i] += match[idx];
                if (dfs(match, idx + 1)) return true;
                else edgs[i] -= match[idx];
            }
        }
        return false;
    }
};
```



#### [508. 出现次数最多的子树元素和](https://leetcode.cn/problems/most-frequent-subtree-sum/)：正常dfs

> 题意描述不清，应该理解为：

> 二叉树所有子树（包括包含根节点的树）的元素和当中，出现次数最多的，返回

1. > 所有的子树和为： [2, -3, 4] 都是出现一次，所以返回所有

2. > 所有的子树和为： [2, -5, 2] 2出现两次 ，为出现的次数最多，返回出现次数最多的元素 ：[2]

> 

- > 因此，要用上哈希表，哈希表在for(auto)中的用法，跟pair的用法一样

- > 使用dfs对树进行遍历，同时将每棵子树的总和值存入哈希表（以元素和为 key，出现次数为 value），并实时维护最大子树和，使用变量 max 存储。

- > 当遍历完整棵树后，将哈希表中值为 max 的键存入答案。

```C++
class Solution {
public:
    unordered_map<int, int> sumMap;
    int maxCnt = 0;

    int dfs(TreeNode* node) {
        if (node == NULL) return 0;
        int sum = node->val + dfs(node->left) + dfs(node->right);
        maxCnt = max(maxCnt, ++sumMap[sum]);
        return sum;
    }
    vector<int> findFrequentTreeSum(TreeNode* root) {
        (void)dfs(root);
        vector<int> ans;
        for (auto s : sumMap) {
            if (s.second == maxCnt) ans.push_back(s.first);
        }
        return ans;
    }
};
```



#### [652. 寻找重复的子树](https://leetcode.cn/problems/find-duplicate-subtrees/)：可以用哈希表来记录

哈希表unordered_map记录每个子树的出现次数

只对`string subtree = to_string(root->val) + dfs(root->left) + dfs(root->right);`是不正确的，不能区分开！

```C++
class Solution {
public:
    unordered_map<string, int> umap;
    vector<TreeNode*> ans;
    string dfs(TreeNode* root) {
        if (root == NULL) return "";

        string subtree = to_string(root->val) + "-" + dfs(root->left) + "-" + dfs(root->right);
        umap[subtree]++;
        if (umap[subtree] == 2) ans.push_back(root);
        return subtree;
    }
    vector<TreeNode*> findDuplicateSubtrees(TreeNode* root) {
        (void)dfs(root);
        return ans;
    }
};
```



#### [1020. 飞地的数量](https://leetcode-cn.com/problems/number-of-enclaves/)：直接dfs就可以，模板题⭐

![img](https://uestc.feishu.cn/space/api/box/stream/download/asynccode/?code=YjBkODAwOWI2YTdmMGEzOWFhY2YzNjcxMGVhNDBjNjdfRVZNRFVHWlIzbG9vOFRGTU9YQWIzaTlqM21UOFdxUklfVG9rZW46Ym94Y25zMXFhOHBXcjN3NG1scThxajRzdXBjXzE2NjI2NDE5MTE6MTY2MjY0NTUxMV9WNA)

```C++
class Solution {
public:
    vector<vector<int>> direct = {{1,0},{-1,0},{0,1},{0,-1}};
    vector<vector<int>> g;
    int m, n;
    int numEnclaves(vector<vector<int>>& grid) {
        g = grid;
        m = grid.size(), n = grid[0].size();  // m行n列
        int ans = 0;  // 等价于找到不和边缘相连的独立块的面积和
        for (int i = 0; i < m; ++i) {
            for (int j = 0; j < n; ++j) {
               if (i == 0 || j == 0 || i == m-1 || j == n-1)
                dfs(i, j); 
            }
        }

        for (int i = 0; i < m; ++i) {
            for (int j = 0; j < n; ++j) {
                ans += g[i][j];
            }
        }
        return ans;
    }

    void dfs(int x, int y) {
        if (0 <= x && x < m && 0 <= y && y < n && g[x][y]) {
            g[x][y] = 0;  // 能到边缘的陆地置为0
            for (auto d : direct)
                dfs(x+d[0], y+d[1]);
        }
    }
};
```









## BFS

无法复制加载中的内容



#### [433. 最小基因变化](https://leetcode-cn.com/problems/minimum-genetic-mutation/)：BFS模板题



BFS总共有两个模板：

**模板一：**

如果不需要确定当前遍历到了哪一层，BFS 模板如下。

```C++
while queue 不空：
    cur = queue.pop()
    if cur 有效且未被访问过：
        进行处理
    for 节点 in cur 的所有相邻节点：
        if 该节点有效：
            queue.push(该节点)
```

**模板二：**

如果要确定当前遍历到了哪一层，BFS 模板如下。

这里增加了 level 表示当前遍历到二叉树中的哪一层了，也可以理解为在一个图中，现在已经走了多少步了。size 表示在当前遍历层有多少个元素，也就是队列中的元素数，我们把这些元素一次性遍历完，即把当前层的所有元素都向外走了一步。

```C++
level = 0
while queue 不空：
    size = queue.size()
    while (size --) {
        cur = queue.pop()
        if cur 有效且未被访问过：
            进行处理
        for 节点 in cur的所有相邻节点：
            if 该节点有效：
                queue.push(该节点)
    }
    level ++;
```





#### 559.N 叉树的最大深度：dfs bfs 注意写法

```Python
"""
# Definition for a Node.
class Node:
    def __init__(self, val=None, children=None):
        self.val = val
        self.children = children
"""
# dfs
class Solution:
    def maxDepth(self, root: 'Node') -> int:
        return max((self.maxDepth(child) for child in root.children), default = 0) + 1 if root else 0
# bfs
class Solution:
    def maxDepth(self, root: 'Node') -> int:
        if root is None:
            return 0
        ans = 0
        queue = [root]
        while queue:
            queue = [child for node in queue for child in node.children]
            ans += 1
        return ans
```



#### [675. 为高尔夫比赛砍树](https://leetcode.cn/problems/cut-off-trees-for-golf-event/)：BFS模板⭐ / 迪杰斯特拉

- > 包括需要记录层数的广度优先搜索

- > 可以使用自定义规则排序，也可以直接要比较的那个放在pair的前者

![img](https://uestc.feishu.cn/space/api/box/stream/download/asynccode/?code=MDY5OTRjMWY2ZTZhYmI0NzA4YmFiZDUxYjMyOTY5ZThfMlJEUkpHbDBCckhScUtxejVoZ29mYkJSRkp6Mm45emNfVG9rZW46Ym94Y25Od2hJb1F1d2pFMDZab0J1N3d4NE9nXzE2NjI2NDE5MTE6MTY2MjY0NTUxMV9WNA)

- > 砍完所有的🌳

- > 只要不是障碍都可以走，但是树只能从低到高砍；也就是**不是目前最矮的树可以路过，但是不能砍**。

![img](https://uestc.feishu.cn/space/api/box/stream/download/asynccode/?code=ZTJhNzhlZTE2MDdjOTcyMTZmMzJiNjE3NWU5YjVjOWNfSzRBdkVVTUtlR3FOdUh4Y0dqc3FVMjlWWlRBdDN2b2lfVG9rZW46Ym94Y25LTUpFWlZ5b3lTQTlMdFd6UGNyakJlXzE2NjI2NDE5MTE6MTY2MjY0NTUxMV9WNA)![img](https://uestc.feishu.cn/space/api/box/stream/download/asynccode/?code=OWVjNTgwNmUwYzAzMzRjOTYxYjg0MTAzNzRlYTJmNzJfaTVnMzRkTzZ1SHFrc0t6VHdpTUh5Q2Z0MXRWbnl3WTZfVG9rZW46Ym94Y241N1RZZTdLbVJPajAySlprZ3pCTE1jXzE2NjI2NDE5MTE6MTY2MjY0NTUxMV9WNA)

**法1：BFS⭐**

```C++
class Solution {
public:
    int m, n;
    vector<vector<int>> direct = {{1,0},{-1,0},{0,1},{0,-1}};
    vector<vector<int>> g;

    int bfs(pair<int, int>& start, pair<int, int>& goal) {  // 从起点到目标砍的树
        if (start.first == goal.first && start.second == goal.second) return 0;
        queue<pair<int, int>> q;
        q.push(start);
        int step = 0;
        vector<vector<bool>> vis(m, vector<bool>(n, false));
        vis[start.first][start.second] = true;
        while (!q.empty()) {
            step++;
            int size = q.size();
            
            while (size--) {
                pair<int, int> p = q.front();
                q.pop();

                for (auto d : direct) {
                    int x = p.first + d[0], y = p.second + d[1];
                    if (x < 0 || y < 0 || x >= m || y >= n) continue;
                    if (g[x][y] == 0) continue;
                    if (vis[x][y]) continue;
                    if (x == goal.first && y == goal.second) return step;

                    vis[x][y] = true;
                    q.push(make_pair(x, y));
                }
            }
        }
        return -1;
    }

    int cutOffTree(vector<vector<int>>& forest) {
        m = forest.size(), n = forest[0].size();
        g = forest;
        if (g[0][0] == 0) return -1;
        vector<pair<int, pair<int, int>>> tree;  //pair<height, (i,j)>
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                if (g[i][j] > 1) tree.push_back(make_pair(g[i][j], make_pair(i, j)));
            }
        }
        sort(tree.begin(), tree.end());  // 这里可能会需要对tree.first排序

        pair<int, int> start = make_pair(0, 0);
        int ans = 0;
        for (auto t : tree) {
            int step = bfs(start, t.second);
            if (step == -1) return -1;
            ans += step;
            start = t.second;
        }
        return ans;
    }
};
```

- > BFS只搜索，并不找路径

- > 对于dx,dy的方向移动，direct的方式用时更长！

```C++
这种写法似乎更省时！！
int dx[4] = {1, -1, 0, 0};
int dy[4] = {0, 0, 1, -1};
for (int i = 0; i < 4; i++) {
    int x = p.first + dx[i], y = p.second + dy[i];
    ...
}
```



**法2：Dijkstra 算法**

![img](https://uestc.feishu.cn/space/api/box/stream/download/asynccode/?code=YWMzMDMwMjk0ZjZhZGYwNWE4MjkzNDdiMDQ4NjNlMTdfd2l3dHVUNWR2SElwM1prSEd2cnRHUWJtdEZ5RFA4WndfVG9rZW46Ym94Y25aVkx5VEZab1ZWNzExZFRvM2EyM09nXzE2NjI2NDE5MTE6MTY2MjY0NTUxMV9WNA)

```C++
class Solution {
public:
    int dirs[4][2] = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};

    int bfs(vector<vector<int>>& forest, int sx, int sy, int tx, int ty) {
        if (sx == tx && sy == ty) return 0;

        int row = forest.size();
        int col = forest[0].size();
        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> pq;
        vector<vector<bool>> visited(row, vector<bool>(col, false));
        pq.emplace(0, sx * col + sy);
        visited[sx][sy] = true;
        while (!pq.empty()) {
            auto [dist, loc] = pq.top();
            pq.pop();
            for (int j = 0; j < 4; ++j) {
                int nx = loc / col + dirs[j][0];
                int ny = loc % col + dirs[j][1];
                if (nx >= 0 && nx < row && ny >= 0 && ny < col) {
                    if (!visited[nx][ny] && forest[nx][ny] > 0) {
                        if (nx == tx && ny == ty) return dist + 1;
                        pq.emplace(dist + 1, nx * col + ny);
                        visited[nx][ny] = true;
                    }
                }
            }
        }
        return -1;
    }

    int cutOffTree(vector<vector<int>>& forest) {
        vector<pair<int, int>> trees;
        int row = forest.size();
        int col = forest[0].size();
        for (int i = 0; i < row; ++i)
            for (int j = 0; j < col; ++j)
                if (forest[i][j] > 1) trees.emplace_back(i, j);

        sort(trees.begin(), trees.end(), [&](const pair<int, int> & a, const pair<int, int> & b) {
            return forest[a.first][a.second] < forest[b.first][b.second];
        });
        
        int cx = 0;
        int cy = 0;
        int ans = 0;
        for (int i = 0; i < trees.size(); ++i) {
            int steps = bfs(forest, cx, cy, trees[i].first, trees[i].second);
            if (steps == -1) {
                return -1;
            }
            ans += steps;
            cx = trees[i].first;
            cy = trees[i].second;
        }
        return ans;
    }
};
```





#### [691. 贴纸拼词](https://leetcode.cn/problems/stickers-to-spell-word/)：BitMap / 状态压缩 / 记忆化搜索

> 困难题

![img](https://uestc.feishu.cn/space/api/box/stream/download/asynccode/?code=ODQ5NWM0ODdhMTFiNzAzYWFiZWQ2NmU0MWM1NjRkNTNfMmN2VEVPbHdRZzExeERFVlM3ZUl5cTVMY3laSjV4OW9fVG9rZW46Ym94Y243c3BVcjF3cng4VmNFRzNnM2VYM01DXzE2NjI2NDE5MTE6MTY2MjY0NTUxMV9WNA)

**使用位图+动态规划dp的方式：**

![img](https://uestc.feishu.cn/space/api/box/stream/download/asynccode/?code=MzA2MmM4MDI4MDI4MjRiM2I2MGRjNDYwMzcyNjBhNzJfdGJaZWFaemFtb1BoeEdqM0RrMDhtUlc2M1UzRzRPc25fVG9rZW46Ym94Y243dFR3YmE0RFlrcE1zanpjRDgzSExoXzE2NjI2NDE5MTE6MTY2MjY0NTUxMV9WNA)

```C++
class Solution {
public:
    int minStickers(vector<string>& stickers, string target) {
        int n = target.size();
        vector<int> dp((1 << n), 0);
        queue<int> q;  // bfs
        q.push(0);
        while (!q.empty()) {
            int cur = q.front();  // 当前位的状态
            q.pop();
            for (auto s : stickers) {
                int state = cur;
                vector<int> cnt(26);
                for (auto c : s) cnt[c-'a']++;
                // 更改target每一位的state
                for (int i = 0; i < n; i++) {
                    if (cnt[target[i]-'a'] > 0 && (state & (1 << i)) == 0) {
                        state |= 1 << i;  // 第i位置为1
                        cnt[target[i]-'a']--;
                    }
                }
                if (dp[state] || state == 0) continue;
                q.push(state);
                dp[state] = dp[cur] + 1;;
                if (state == (1 << n) - 1) {
                    return dp[state];
                }
            }
        }
        return -1;
    }
};
```





#### [938. 二叉搜索树的范围和](https://leetcode-cn.com/problems/range-sum-of-bst/)：？二叉搜索树的中序遍历是有序的

```C++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    int rangeSumBST(TreeNode* root, int low, int high) {
        if(root==nullptr) return 0;
        if(root->val<low) return rangeSumBST(root->right,low,high);
        if(root->val>high) return rangeSumBST(root->left,low,high);
        return root->val+rangeSumBST(root->left,low,high)+rangeSumBST(root->right,low,high);
    }
};
```

优秀解法：**二叉搜索树的中序遍历是有序的**

```C++
class Solution {
public:
    int ans = 0, low, high;
    int rangeSumBST(TreeNode* root, int _low, int _high) {
        low = _low, high = _high;
        dfs(root);
        return ans;
    }

    void dfs(TreeNode* root){
        if(root==nullptr) return;
        dfs(root->left);
        if(root->val >= low && root->val <= high) ans += root->val;
        dfs(root->right);
    }
};
```



#### [1609. 奇偶树](https://leetcode-cn.com/problems/even-odd-tree/)：bfs用队列，python无穷大inf

```C++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    // 直接广度优先bfs
    bool isEvenOddTree(TreeNode* root) {
        queue<TreeNode*> q;
        q.push(root);
        int level = 0;
        while (!q.empty()) {
            int size = q.size(); 
            int prev = level % 2 == 0 ? INT_MIN : INT_MAX;  // prev记录当前层的上一节点的值
            
            for (int i = 0; i < size; i++) {  //根据当前层有几个节点，来决定循环次数
                TreeNode * node = q.front();
                q.pop();
                int cur = node->val;
                if (level % 2 == cur % 2) {  // 要保证奇数层是偶数、偶数层是奇数
                    return false;
                }
                if ((level % 2 == 0 && cur <= prev) || (level % 2 == 1 && cur >= prev)) {
                    return false;
                }
                prev = cur;
                if (node->left != nullptr) q.push(node->left);
                if (node->right != nullptr) q.push(node->right);
            }
            level++;
        }

        return true;
    }
};
```

python的inf用法：

```Python
# Definition for a binary tree node.
# class TreeNode:
#     def __init__(self, val=0, left=None, right=None):
#         self.val = val
#         self.left = left
#         self.right = right
class Solution:
    def isEvenOddTree(self, root: Optional[TreeNode]) -> bool:
        level, nodes = 0, [root]
        while nodes:
            nxt, cur = [], float("inf") if level % 2 else 0  # 奇数降序，偶数升序
            for node in nodes:
                if (level % 2 == node.val % 2) or (level % 2 and cur <= node.val) or ((not level % 2) and cur >= node.val):
                        return False
                cur = node.val
                if node.left: nxt.append(node.left)
                if node.right: nxt.append(node.right)
            nodes = nxt
            level += 1
        return True
```



# 滑动窗口

无法复制加载中的内容



#### 594. 最长和谐子序列：sort 滑动窗口 or 哈希表

2种解法：更像是枚举的滑动窗口 & 哈希表！

```C++
class Solution {
public:
    // 比起滑动窗口，本题这个解法更像是枚举的方法
    // 本题的子序列并不是连续的子序列，可以断开，因此直接把序列sort
    int findLHS(vector<int>& nums) {
        sort(nums.begin(),nums.end());  //vector的begin和end是使用迭代器
        int begin = 0;
        int res = 0;  //res记录当前最大的
        for (int end = 0; end < nums.size(); end++) {
            while (nums[end] - nums[begin] > 1) {
                begin++;
            }
            if (nums[end] - nums[begin] == 1) {
                res = max(res, end - begin + 1);
            }
        }
        return res;
    }
};
class Solution {
public:
    // 官方题解：哈希表的方法⭐
    int findLHS(vector<int>& nums) {
        unordered_map<int, int> cnt;  // 村塾每个数出现的次数
        int res = 0;
        // 先构建哈希表
        for (int num : nums) {
            cnt[num]++;
        }
        // 再利用键值对查询次数
        for (auto [key, val] : cnt) {
            if (cnt.count(key + 1)) {
                res = max(res, val + cnt[key + 1]);
            }
        }
        return res;
    }
};
# 官方：哈希表
class Solution:
    def findLHS(self, nums: List[int]) -> int:
        cnt = Counter(nums)
        return max((val + cnt[key + 1] for key, val in cnt.items() if key + 1 in cnt), default=0)
class Solution:
    # 一个好理解的python版本，结合IDLE截图理解⭐
    def findLHS(self, nums: List[int]) -> int:
        res = 0
        cnt = collections.Counter(nums)

        for key in cnt.keys():
            if key + 1 in cnt.keys():
                res = max(res, cnt[key] + cnt[key + 1])
        return res
```

![img](https://uestc.feishu.cn/space/api/box/stream/download/asynccode/?code=YzBkMzgyYjU4NmRmMzEyYThkNDUwY2Q1YjQ5NDg4NGZfNE0zZ3hTRXJBTW1BYWZCVDA1OTM2YW4xam55YkRMQ1FfVG9rZW46Ym94Y25tYUpMZ3FpWjhzZTd4WkRxN3I3M0JlXzE2NjI2NDE5MTE6MTY2MjY0NTUxMV9WNA)

![img](https://uestc.feishu.cn/space/api/box/stream/download/asynccode/?code=ZmJjNDU3MWZmNGZkY2MzODI3N2QyNDRmZjcyOTRlNjVfMUFMTmd3MjdmcDdQNTBwT0s5U2NxODVMT1RSZjg3elhfVG9rZW46Ym94Y25oeTJNYjJ6WGE0NjQwOWNsaXRlTWxpXzE2NjI2NDE5MTE6MTY2MjY0NTUxMV9WNA)





#### [689. 三个无重叠子数组的最大和](https://leetcode-cn.com/problems/maximum-sum-of-3-non-overlapping-subarrays/)：3个滑动窗口

![img](https://uestc.feishu.cn/space/api/box/stream/download/asynccode/?code=Nzk1ZjA4NzFkNTBjOGQ2NmU0OGI2OTNhMjc5NDlmMDNfRWc0N3ZHUHFNYk1JcHlKQTFRekpNTkNBUnkzVmJac2ZfVG9rZW46Ym94Y25ZandmZ1NmQXNPeFlnMFZOeWF1T1JoXzE2NjI2NDE5MTE6MTY2MjY0NTUxMV9WNA)

三次过程中，下标要分别保存！不然就会像第一次那样出错。。

```C++
class Solution {
public:
    vector<int> maxSumOfThreeSubarrays(vector<int> &nums, int k) {
        vector<int> ans;
        int sum1 = 0, maxSum1 = 0, maxSum1Idx = 0;
        int sum2 = 0, maxSum12 = 0, maxSum12Idx1 = 0, maxSum12Idx2 = 0;
        int sum3 = 0, maxTotal = 0;
        for (int i = k * 2; i < nums.size(); ++i) {
            sum1 += nums[i - k * 2];
            sum2 += nums[i - k];
            sum3 += nums[i];
            if (i >= k * 3 - 1) {
                if (sum1 > maxSum1) {
                    maxSum1 = sum1;
                    maxSum1Idx = i - k * 3 + 1;
                }
                if (maxSum1 + sum2 > maxSum12) {
                    maxSum12 = maxSum1 + sum2;
                    maxSum12Idx1 = maxSum1Idx;
                    maxSum12Idx2 = i - k * 2 + 1;
                }
                if (maxSum12 + sum3 > maxTotal) {
                    maxTotal = maxSum12 + sum3;
                    ans = {maxSum12Idx1, maxSum12Idx2, i - k + 1};
                }
                sum1 -= nums[i - k * 3 + 1];
                sum2 -= nums[i - k * 2 + 1];
                sum3 -= nums[i - k + 1];
            }
        }
        return ans;
    }
};
```



#### [713. 乘积小于 K 的子数组](https://leetcode-cn.com/problems/subarray-product-less-than-k/)：变长滑动窗口

```C++
class Solution {
public:
    // 滑动窗口or双指针
    int numSubarrayProductLessThanK(vector<int>& nums, int k) {
        if (k <= 1) return 0;
        int n = nums.size(), ans = 0;
        for (int l = 0, r = 0, cur = 1; r < n; r++) {
            cur *= nums[r];
            while (cur >= k) cur /= nums[l++];
            ans += (r - l + 1);
        }
        return ans;
    }
};
```



#### [1984. 学生分数的最小差值](https://leetcode-cn.com/problems/minimum-difference-between-highest-and-lowest-of-k-scores/)：排序+滑动窗口

这是个很简单的题

![img](https://uestc.feishu.cn/space/api/box/stream/download/asynccode/?code=OTI1ZjY3ZWQwNzRlNWNiNWQ5OWY0M2UyZGZjMThiYTNfRUtLMGNkMEt3eEJ5cDFEN0l0Y0k3WVptcENYYnl3Q3JfVG9rZW46Ym94Y24wMkdWaEFWVDlqWFExZ2JPY0pRaHFkXzE2NjI2NDE5MTE6MTY2MjY0NTUxMV9WNA)

![img](https://uestc.feishu.cn/space/api/box/stream/download/asynccode/?code=NTljYjM3Zjk3YTQwN2Y4NjgxMjRlZDIwZmNlZTlkYjhfYXR1ZkdZYnBsOXAzOEZLcEswM3JRS1dYNmJ4MWFZRzBfVG9rZW46Ym94Y25mNGxMSGtUUWswVlJKNzBNZFVrWkliXzE2NjI2NDE5MTE6MTY2MjY0NTUxMV9WNA)

```C++
class Solution {
public:
    int minimumDifference(vector<int>& nums, int k) {
        sort(nums.begin(), nums.end());
        int n = nums.size(), ans = nums[k-1] - nums[0];
        // 滑动窗口长度为k
        for (int i = k; i < n; ++i) {
            ans = min(ans, nums[i] - nums[i-k+1]);
        }
        return ans;
    }
};
```

**在python中，排序的函数有两个**

- 第一个是sort()，sort函数对序列进行永久性的改变，
- 第二个是sorted()，sorted函数在排序后会生成一个新的序列，原序列不变。

```Python
class Solution:
    def minimumDifference(self, nums: List[int], k: int) -> int:
        nums.sort()
        n = len(nums)
        ans = nums[k-1] - nums[0]
        # 滑动窗口长度为k
        for i in range(k, n):
            ans = min(ans, nums[i] - nums[i-k+1])
        return ans

        # return min(s[i + k - 1] - s[i] for i in range(len(s) - k + 1)) if k > 1 and (s:=sorted(nums)) else 0
```





# 双指针

无法复制加载中的内容



#### 3.无重复字符最长子串：滑动窗口 哈希集合unordered_set

哈希集合：记录字符是否出现过！！

如果我们依次递增地枚举子串的起始位置，那么子串的结束位置也是递增的！

这里的原因在于，假设我们选择字符串中的第k个字符作为起始位置，并且得到了不包含重复字符的最长子串的结束位置为r_k。那么当我们选择第 k+1个字符作为起始位置时，首先从k+1到 r_k的字符显然是不重复的，并且由于少了原本的第k个字符，我们可以尝试继续增大r_k ，直到右侧出现了重复字符为止。

这样一来，我们就可以使用「滑动窗口」来解决这个问题了

```C++
class Solution {
public:
    int lengthOfLongestSubstring(string s) {
        unordered_set<char> win;  // 哈希集合，记录每个字符是否出现过
        int n = s.size();
        int rk = -1, ans = 0;  // 右指针rk
        for(int i = 0; i < n; ++i){
            if(i != 0){  //第一个开始的窗口不移动
                win.erase(s[i-1]);
            }
            while(rk+1<n && !win.count(s[rk+1])){
                win.insert(s[rk+1]);
                ++rk;
            }
            ans = max(ans, rk-i+1);
        }
        return ans;
    }
};
```



#### [658. 找到 K 个最接近的元素](https://leetcode.cn/problems/find-k-closest-elements/)：二分+双指针

法1：

容易想到先通过「二分」找到与 x 差值最小的位置 idx，然后从 idx 开始使用「双指针」往两边进行拓展（初始化左端点 i = idx - 1，右端点 j = idx + 1），含义为 [i + 1, j - 1] 范围内子数组为候选区间，不断根据两边界与 x 的差值关系进行扩充，直到候选区间包含 k 个数。

```C++
class Solution {
public:
    vector<int> findClosestElements(vector<int>& arr, int k, int x) {
        int n = arr.size();
        int l = 0, r = n - 1;
        while (l < r) {
            int mid = l + r + 1 >> 1;        // int mid = (l + r + 1) / 2;
            if (arr[mid] <= x) l = mid;
            else r = mid - 1;
        }
        // 与x最近的位置在r上
        if (r < n - 1 && abs(arr[r + 1] - x) < abs(arr[r] - x)) r += 1;

        int i = r - 1, j = r + 1;
        // [i+1, j-1]
        while (j - i - 1 < k) {
            if (i >= 0 && j < n) {
                if (abs(arr[j] - x) < abs(arr[i] - x)) j++;
                else i--;
            } else if (i >= 0) {
                i--;
            } else {
                j++;
            }
        }
        vector<int> ans;
        for (int p = i + 1; p <= j - 1; p++) ans.push_back(arr[p]);
        return ans;
    }
};
```

法2：还有种直接排序的做法

```C++
class Solution {
public:
    vector<int> findClosestElements(vector<int>& arr, int k, int x) {
        sort(arr.begin(), arr.end(), [x](int a, int b) -> bool {
            return abs(a - x) < abs(b - x) || abs(a - x) == abs(b - x) && a < b;
        });
        sort(arr.begin(), arr.begin() + k);
        return vector<int>(arr.begin(), arr.begin() + k);
    }
};
```

法3：不用首尾扩展，直接按照k长度滑窗

```Swift
class Solution {
public:
    vector<int> findClosestElements(vector<int>& arr, int k, int x) {
    int left=0;  int right=arr.size();
    while(true){
        if(right-left==k){
            break;
        }
   if(abs(arr[left]-x)<abs(arr[right-1]-x)||abs(arr[left]-x)==abs(arr[right-1]-x)){
        right--;
   }else{
       left++;
   }
    }
    return     vector<int>(arr.begin()+left,arr.begin()+right);
    }
};
```





#### [825. 适龄的朋友](https://leetcode-cn.com/problems/friends-of-appropriate-ages/)：排序+双指针

这个解法，是以y为视角，看哪个x可以给自己发

![img](https://uestc.feishu.cn/space/api/box/stream/download/asynccode/?code=MTM4NzZjMDc5MjU5NDdlYTQ5OGI2MDRlMWI5Yjk3MDJfUmZFcVMzdWJoSlNxOTI4SDh2OENwTGZFdDNvdWVSNWpfVG9rZW46Ym94Y25lcE1sV016SFVyZVNtRGFZdUV2MkxnXzE2NjI2NDE5MTE6MTY2MjY0NTUxMV9WNA)

```C++
class Solution {
public:
    // x只会向比自己小的发送
    // 从y的视角，(i,j]， 使用双指针
    // 即对于一个确定的y，会发送好友请求的x范围为连续段：同龄y~在限定条件下的一定范围
    int numFriendRequests(vector<int>& ages) {
        sort(ages.begin(), ages.end());
        int ans = 0, n = ages.size();
        for(int k = 0, i = 0, j = 0; k < n; k++){
            while(i < k && !check(ages[i], ages[k])) i++;  // i+1开始就可以发送
            if(j < k) j = k + 1;
            while(j < n && check(ages[j], ages[k])) j++;  // 直到j之后就不能再发送
            if(j > i) ans += j - i - 1;
        }
        return ans;
    }

    // 判断条件统一写！检查是否 x->y 发送，发送则为true
    bool check(int x, int y){
        if(y <= 0.5 * x + 7) return false;
        if(y > x) return false;
        if(y > 100 && x < 100) return false; 
        return true;
    }
};
```



#### [917. 仅仅反转字母](https://leetcode-cn.com/problems/reverse-only-letters/)：

```C++
class Solution {
public:
    string reverseOnlyLetters(string s) {
        int n = s.size();
        for (int i = 0, j = n - 1; i < j; ) {
            while (i < j && !isalpha(s[i])) i++;
            while (i < j && !isalpha(s[j])) j--;
            if (i < j) {
                swap(s[i], s[j]);
                i++, j--;
            }
        }
        return s;
    }
};
class Solution:
    def reverseOnlyLetters(self, s: str) -> str:
        ls = list(s)
        i, j = 0, len(ls)-1
        while True:
            while i < j and not ls[i].isalpha(): i += 1
            while i < j and not ls[j].isalpha(): j -= 1
            if i >= j: break
            ls[i], ls[j] = ls[j], ls[i]
            i += 1
            j -= 1
        return ''.join(ls)
```



#### [1021. 删除最外层的括号](https://leetcode.cn/problems/remove-outermost-parentheses/)：双指针模拟更好理解

> 只需要找出外层括号，删除；于是就相当于记录一下括号的深度

![img](https://uestc.feishu.cn/space/api/box/stream/download/asynccode/?code=ZjJhN2U5NDdmODkxNjgwZTdmNjI5ZTVlN2EzOWM4ZGJfQjRURGhSSlV5RnozN29CTE5yMmtTRVpCQzhlZlNyYk1fVG9rZW46Ym94Y25qY09BZW4xdFY4eHNPNklMOHM5ajdnXzE2NjI2NDE5MTE6MTY2MjY0NTUxMV9WNA)

**法1：双指针**

- > 注意C++中，求子串`s.substr(a,b) `是指从a开始的b个；

- > **注意边界！！**

```C++
string removeOuterParentheses(string s) {
    string ans;
    int n = s.size();
    for (int i = 0; i < n; i++) {
        int j = i;
        int score = 0;
        while (i == j || score != 0) {
            score += (s[j++] == '(') ? 1 : -1;
        }
        ans += s.substr(i + 1, j - i - 2);  // [i+1, j−1)  j-2-i-1+1
        i = j - 1;
    }
    return ans;
}
```

**法2：直接做一个标记，顺序很重要！**

```C++
string removeOuterParentheses(string s) {
    string ans;
    int tag = 0;
    for (auto c : s) {
        if (c == ')') tag--;
        if (tag != 0) ans.push_back(c);
        if (c == '(') tag++;
    }
    return ans;
}
```



#### [1446. 连续字符](https://leetcode.cn/problems/consecutive-characters/)：按照下标一次遍历

> 求连续字符长度：遍历



#### [1748. 唯一元素的和](https://leetcode-cn.com/problems/sum-of-unique-elements/)：双指针 or 哈希表

![img](https://uestc.feishu.cn/space/api/box/stream/download/asynccode/?code=NTk1ZmFmODJhZTViYjBkM2NmMDU0OWUzMmYwNzJhZGZfZ0JqYlJ4Mjl2azlDVlhISjBXQVhaRnBvV3NGcUpnODRfVG9rZW46Ym94Y25TNmlYdmpxSXQzazhrZ1ZFbkNiMEZDXzE2NjI2NDE5MTE6MTY2MjY0NTUxMV9WNA)

**双指针的方法：**

```C++
class Solution {
public:
    int sumOfUnique(vector<int>& nums) {
        sort(nums.begin(), nums.end());
        int n = nums.size(), ans = 0;
        for(int i = 0; i < n; ){
            int j = i;
            while(j < n && nums[j] == nums[i])
                j++;
            if(j - i == 1)
                ans += nums[i];
            i = j;
        }
        return ans;
    }
};
```



**哈希表的方法：**

```C++
class Solution {
public:
    int sumOfUnique(vector<int>& nums) {
        unordered_map<int, int> map;
        int ans = 0;
        for(auto &i : nums)
            map[i]++;
        for(auto &i : nums){
            if(map[i] == 1)
                ans += i;
        }
        return ans;
    }
};
class Solution:
    def sumOfUnique(self, nums: List[int]) -> int:
        return sum(i for i, j in Counter(nums).items() if j == 1)
```











# 二分



> **二分查找**有不同的应用：

1. > 找到 target 的位置（常见）

2. > 找到大于等于 target 的第一个位置

3. > 找到大于 target 的第一个位置

4. > 找到小于等于 target 的第一个位置

5. > 找到小于 target 的第一个位置

总结起来，其方法：

## **几种常见的二分法及相应使用场景**

1. ### 在一个单调递增区间内查找某个值

- 使用left <= right，left初始值指向区间第一个索引（一般是0），right初始值指向区间最后一个索引（一般是n-1）；
- 找到直接返回mid；
- 如果nums[mid] < target,则left = mid + 1;
- 否则nums[mid] > target,则right = mid - 1。

```Java
public int bsearch(int[] nums, int target) {
    int left = 0, right = nums.length - 1;
    while (left <= right) {
        int mid = left + (right - left) / 2;
        if (nums[mid] == target) return mid;
        
        else if (nums[mid] < target) left = mid + 1;
        else right = mid - 1;
    }
    // 找不到target返回-1
    return -1;
}
```

1. ### 在一个单调递增区间内查找一个大于等于某个值的最小索引或小于等于某个值的最大索引

此时，如果找到这个mid值，不能直接返回，还需要判断这个值是否是最大索引或最小索引，有对应的**向左逼近**的二分查找和**向右逼近**的二分查找方法（这里的逼近是指当nums[mid]==target时，搜索域向左逼近或向右逼近）。

#### 2.1 向左逼近：查找第一个大于等于给定值的元素

> 找==目标的右侧

```Java
向左逼近：查找第一个大于等于给定值的元素
public static int bsearch1(int[] nums, int target) {
    int left = 0, right = nums.length;
    while (left < right) {
        int mid = left + (right - left) / 2;
        if (nums[mid] < target) left = mid + 1;
        else right = mid;
    }
    if (left == nums.length) return -1;
    return left;
}
```

#### 2.2 向右逼近：查找最后一个小于等于给定值的元素

> 找==目标的左侧

```Java
向右逼近：查找最后一个小于等于给定值的元素
public static int bsearch2(int[] nums, int target) {
    int left = 0, right = nums.length;
    while (left < right) {
        int mid = left + (right - left) / 2;
        if (nums[mid] > target) right = mid;
        else left = mid + 1;
    }
    if (left == 0) return -1;
    return left - 1;
}
```

#### 2.3 向左逼近和向右逼近的区别

区别主要在对nums[mid] == target场景的处理，此时，

- 如果处理为right = mid，可理解为right指针向左移动逼近mid，则是向左逼近；
- 如果处理为left = mid + 1，可理解为left指针向右移动逼近mid，则是向右逼近。

二分查找完成后返回值不一样，向左逼近是返回left，向右逼近是返回left - 1，为什么是这样，又如何理解？

- 首先明确一点，**当使用left < right类的二分查找结束时**，**left == right**，退出while循环；
- 向左逼近是当nums[mid] == target，采取right = mid，所以循环最后得到可用的mid的值，是等于right的，也等于left，所以返回left；
- 而向右逼近，当nums[mid] == target，采取的是left = mid + 1，故 mid = left - 1, 即循环最后得到可用的mid的值，是等于left - 1的，所以返回left - 1。



> 但是，不必拘泥于上述的模板！！

## 题目

#### [436. 寻找右区间](https://leetcode.cn/problems/find-right-interval/)：排序+二分

> 寻找当前区间是否有重叠区间？

> 定义：当区间 *B* 的起点 **大于等于** 区间 *A* 的终点，我们就说区间 *B* 在区间 *A* 的右侧。

![img](https://uestc.feishu.cn/space/api/box/stream/download/asynccode/?code=ZTA0OWFkZDdmMTJiNjUyMmEyMTQxOGIxMzkyYTY5YmNfVkY5UUtWVkpOaUpKUE9ZaDM4Q3NWcXNLeWhBRFg0ek1fVG9rZW46Ym94Y25XVk1wS3pPcmNoRDE0eVc0WGtwOGhlXzE2NjI2NDE5MTE6MTY2MjY0NTUxMV9WNA)

> 这里的二分查找，就是找>=target的第一个位置

![img](https://uestc.feishu.cn/space/api/box/stream/download/asynccode/?code=NzgyY2QwOGI5OTIyNmRkOGZjYmU5ZGRhZmVlYzAzZWRfTGs4S1FkdG5KTUxRRDRFMVFlSDJneFVVVHpqT3VzY2RfVG9rZW46Ym94Y25OaldldXROOHdoYnhZZjRpMVhDTExjXzE2NjI2NDE5MTE6MTY2MjY0NTUxMV9WNA)

```Java
class Solution {
    public int[] findRightInterval(int[][] its) {
        int n = its.length;
        int[][] clone = new int[n][2];
        for (int i = 0; i < n; i++) clone[i] = new int[]{its[i][0], i};
        Arrays.sort(clone, (a,b)->a[0]-b[0]);
        int[] ans = new int[n];
        for (int i = 0; i < n; i++) {
            int l = 0, r = n - 1;
            while (l < r) {
                int mid = l + r >> 1;
                if (clone[mid][0] >= its[i][1]) r = mid;
                else l = mid + 1;
            }
            ans[i] = clone[r][0] >= its[i][1] ? clone[r][1] : -1;
        }
        return ans;
    }
}
官方题解：
    vector<int> findRightInterval(vector<vector<int>>& its) {
        vector<pair<int, int>> itsPair;
        int n = its.size();
        for (int i = 0; i < n; i++) {
            itsPair.emplace_back(its[i][0], i);
        }
        sort(itsPair.begin(), itsPair.end());

        vector<int> ans(n, -1);
        for (int i = 0; i < n; i++) {
            auto it = lower_bound(itsPair.begin(), itsPair.end(), make_pair(its[i][1], 0));
            if (it != itsPair.end()) {
                ans[i] = it->second;
            }
        }
        return ans;
```

- > `lower_bound`用于查找容器中大于等于某值的数，返回这个数的指针。

- > `upper_bound`用于查找容器中大于某值的数，返回这个数的指针。

- > `#include <algorithm>`



#### [475. 供暖器](https://leetcode-cn.com/problems/heaters/)：含有贪心思想的双指针？

关于复杂度的计算：

![img](https://uestc.feishu.cn/space/api/box/stream/download/asynccode/?code=ZGYyNTdlNTljYTA3MmZiY2EzNmNjMWZkNzliNjM4NGFfYXRsVDI0WmFjZnEwY0NXRndHNTZsTG14UG90MmJ3NUJfVG9rZW46Ym94Y256cWJzbGV4MXp0SkdacHQyUVU1TTNkXzE2NjI2NDE5MTE6MTY2MjY0NTUxMV9WNA)

优解：在heater两端设置两个极限情况，用来控制边界

```C++
class Solution {
public:
    int findRadius(vector<int>& houses, vector<int>& heaters) {
        sort(houses.begin(), houses.end());
        sort(heaters.begin(), heaters.end());
        // 增加左右两个控制边界的heater
        heaters.insert(heaters.begin(), INT_MIN);
        heaters.push_back(INT_MAX);

        long long r = 0;
        int n = heaters.size(), m = houses.size();
        int cur = 0;
        for(int i = 0; i < m; i++){
            while(cur <= n + 1){
                if(heaters[cur] >= houses[i])
                    break;
                else cur++;
            }
            long long x = min((long long)heaters[cur] - houses[i], (long long)houses[i] - heaters[cur - 1]);
            r = max(r, x);
        }

        return r;
    }
};

// 一个技巧：我们可以直接在左边和右边分别放置一个最远的加热器，
// 它不会成为到房屋最近的加热器，但是让我们不再需要处理边界条件了
```



#### [540. 有序数组中的单一元素](https://leetcode-cn.com/problems/single-element-in-a-sorted-array/)：脑筋急转弯？明确要求复杂度

![img](https://uestc.feishu.cn/space/api/box/stream/download/asynccode/?code=NGRlZmM5M2U2YThlMWM3ZGUzYTUxN2Q4ODc1MWFmOTJfaXB2cjJIbUF3UjIwSlZiNmc5eVlob0RjY0NqVEZQMXlfVG9rZW46Ym94Y25EVW12V3NvdHBJeFFEOWJGRlR4Nm9nXzE2NjI2NDE5MTE6MTY2MjY0NTUxMV9WNA)

关键在于：怎么样二分？由于这是一个有序数组：

![img](https://uestc.feishu.cn/space/api/box/stream/download/asynccode/?code=ZGNjYTkxMDdiYjViYmM3MDAzMjRiNzM4N2I3MWE2YzRfT3JqZTRDYWdzOGR0VEt3OXY5RURjWXlpSXpXV0szWXJfVG9rZW46Ym94Y244Z1R6dmtZQzh2TDlJRTJIYVgxbmVkXzE2NjI2NDE5MTE6MTY2MjY0NTUxMV9WNA)

```C++
class Solution {
public:
    // 题目明确要求O(log n)的时间复杂度：二分查找😅
    int singleNonDuplicate(vector<int>& nums) {
        int n = nums.size();
        int l = 0, r = n - 1;
        while (l < r) {
            int mid = (l + r) / 2;
            if (mid % 2 == 0) {
                if (mid + 1 < n && nums[mid] == nums[mid + 1]) l = mid + 1;  //说明在mid右边
                else r = mid;  // 说明在mid左边
            }
            else {
                if (mid - 1 >= 0 && nums[mid - 1] == nums[mid]) l = mid + 1;
                else r = mid;
            }
        }
        return nums[r];
    }
};
```

> 由于数组有序，且只有一个元素出现一次；剩下所有元素结对出现。

> 那么对于 [l, mid]，[mid+1, r] 两段区间而言，唯一的元素 target 必然出现在两者之一的位置。

> 考虑数组中任意偶数下标x的元素：如果x之前，没有出现过 target，显然 x 和 x+1 对应的元素应该是一样的，因为没有出现target则意味着所有元素都是成对出现。



#### [668. 乘法表中第k小的数](https://leetcode.cn/problems/kth-smallest-number-in-multiplication-table/)：困难题，妙思

![img](https://uestc.feishu.cn/space/api/box/stream/download/asynccode/?code=ZTliZjdhYmJhZGU2MDMwYzZmNTE0YTJiZjcyNDI2OGRfakZRS3g4b3M0OEZYS2xHWXhCczdzVzAxY21KdDBOSmZfVG9rZW46Ym94Y255SURrd2RmYmtuUXdrRFhMMEM0cDdiXzE2NjI2NDE5MTE6MTY2MjY0NTUxMV9WNA)

![img](https://uestc.feishu.cn/space/api/box/stream/download/asynccode/?code=OWQ2NzgxN2Q2MmQwMDQ5MDJlM2ZkNzNmNjQxNmNlZGNfWEs1QnV5TFhraktpdkFXN1lLUFpoQ3pwaEJ4cWNDblNfVG9rZW46Ym94Y255dnAwaUtxWnN6MHdYY0NJajF4QVVoXzE2NjI2NDE5MTE6MTY2MjY0NTUxMV9WNA)

**本题的关键思想：**

![img](https://uestc.feishu.cn/space/api/box/stream/download/asynccode/?code=ODcyOGRkZTQ0YjM3MzM5YWZhMjljMGNmYjY2NmI0OTZfVFdPU0xQNDdkNktsbnBhQlhQcGhlWEhvTlNabm4yVHZfVG9rZW46Ym94Y25Pa2ozUG9BRklpQkFyN0Jub0pRSDdnXzE2NjI2NDE5MTE6MTY2MjY0NTUxMV9WNA)

```Java
class Solution {
public:
    int getCnt(int m, int n, int k) {  // 获取<=k的数目
        int res = 0;
        for (int i = 1; i <= m; i++) {
            res += min(k / i, n);
        }
        return res;
    }
    int findKthNumber(int m, int n, int k) {
        int l = 1, r = m * n;  // l,r 规定了候选区间的左右边界
        while (l < r) {   // 不能写成<=，会死循环！！
            int mid = l + (r - l) / 2;
            if (getCnt(m, n, mid) >= k) r = mid;
            else l = mid + 1;
        }
        return l;
    }
};
```



#### [719. 找出第 K 小的数对距离](https://leetcode.cn/problems/find-k-th-smallest-pair-distance/)：二分+双指针

转化了一下思路：“第k小的”-->“距离取值范围，取到哪个会让恰好有k个”

- > 思路：我们先对数组进行排序，设数对距离为dis，则dis的取值范围是**[0,nums[n-1]-nums[0]]**，然后我们通过**二分查找**第k小距离是多少。

- > 为了找到当前小于mid的数对个数，我们可以通过**双指针**来计算贡献值。

- > 可统计值小于等于 mid 的数量：枚举左端点 i，每次找第一个不满足条件的右端点 j

- > 由于j是第一个不满足条件的值，因此合法右端点范围为`[i+1, j-1]`，共`j-i-1`个，

- > 利用 nums 有序，并且所有nums[i]均为正数，可知 j 会随着 i 增大而逐步增大，即这部分利用「双指针」可实现 O(n) 复杂度

```C++
class Solution {
public:
    int check(int mid, vector<int> nums)  // 间距比mid小的个数
    {
        int n = nums.size(), ans = 0;
        for (int i = 0, j = 1; i < n; i++) {
            while (j < n && nums[j] - nums[i] <= mid) j++;
            ans += (j - i - 1);
        }
        return ans;
    }
    int smallestDistancePair(vector<int>& nums, int k) {
        sort(nums.begin(), nums.end());
        int n = nums.size();
        int l = 0, r = nums[n - 1] - nums[0];  // 间距的取值左右边界
        while (l < r) {
            int mid = l + (r - l) / 2;
            if (check(mid, nums) >= k) r = mid;  // 比mid小的个数是否有k个
            else l = mid + 1;
        }
        return r;  // l=r=mid，因为是第k个！
    }
};
```



#### [875. 爱吃香蕉的珂珂](https://leetcode.cn/problems/koko-eating-bananas/)：分析好边界！

```PowerShell
示例 1：
输入：piles = [3,6,7,11], h = 8
输出：4
示例 2：
输入：piles = [30,11,23,4,20], h = 5
输出：30
示例 3：
输入：piles = [30,11,23,4,20], h = 6
输出：23
```

- > 速度大于`max(piles[i])`，实则是无效的，因为每小时一堆；

- > 当h太小，吃不完就可以摆烂了😅

![img](https://uestc.feishu.cn/space/api/box/stream/download/asynccode/?code=MWM2YTlmNzViMzJiZDFmNjRiNzNlZWY4OGRjMzc0ODZfTkMzSlBXM1F0V25YWjNacEdhNmJEVXYzQXRRY2lpdU1fVG9rZW46Ym94Y25CenJMM1lGY291aDhJM1cwS0pDV2RmXzE2NjI2NDE5MTE6MTY2MjY0NTUxMV9WNA)

- 计算出以当前mid的速度吃掉，需要消耗多少时间，也很重要！
- 我的解法：`ans += pile%mid==0 ? pile/mid : pile/mid + 1;`

![img](https://uestc.feishu.cn/space/api/box/stream/download/asynccode/?code=ZDA1YmIyNDc3NmExMjZmOWI1NWNmYzRmY2YzNDA5NzlfbjJwS013bHZCMDhmTnZsbzNodG5XYlVUWUF3a0JscUlfVG9rZW46Ym94Y25nNnN2VGhIR2lneEJtcGdheXRZczBkXzE2NjI2NDE5MTE6MTY2MjY0NTUxMV9WNA)

```C++
class Solution {
public:
    bool check (vector<int>& piles, int h, int mid) {
        int ans = 0;
        for (int& pile : piles) 
            // ans += (pile + mid - 1) / mid;
            ans += pile%mid==0 ? pile/mid : pile/mid + 1;
        if (ans <= h) return true;
        else return false;
    }
    int minEatingSpeed(vector<int>& piles, int h) {
        int maxNum = INT_MIN;  // #include <limits.h>
        for (auto& pile : piles) maxNum = max(maxNum, pile);

        int l = 1, r = maxNum;
        while (l < r) {
            int mid = l + (r - l) / 2;
            if (check(piles, h, mid)) r = mid; // r是最起码的速度
            else l = mid + 1;
        }
        return l;
    }
};
```







#### [911. 在线选举](https://leetcode-cn.com/problems/online-election/)：

实现思路：可以参考演草

![img](https://uestc.feishu.cn/space/api/box/stream/download/asynccode/?code=MzE5MWJhOGYwYjI1MGRjYTk3OTk4NDMxNTI1NTRlNGZfNDNSUWpPdUNieVVVcHh4NVFYOVJFSkpObUFyeEY2cXdfVG9rZW46Ym94Y240bTBMTmdkVUo4QVNpVzhKSjNlcGtmXzE2NjI2NDE5MTE6MTY2MjY0NTUxMV9WNA)

#### 









# 并查集

无法复制加载中的内容





# 数学

#### [50. Pow(x, n)](https://leetcode-cn.com/problems/powx-n/)：二进制移位，快速幂

```C++
class Solution {
public:
    double myPow(double x, int n) {
        long long N = n;
        return N >= 0 ? quickMul(x, N) : 1.0 / quickMul(x, -N);
    }
    double quickMul(double x, long long N) {
        double ans = 1.0;
        while (N > 0){
            if(N&1)
                ans *= x;
            x *= x;
            N >>= 1;
        }
        return ans;
    }
};
class Solution:
    def myPow(self, x: float, n: int) -> float:
        return self.quickMul(x, n) if n >= 0 else 1.0 / self.quickMul(x, -n)
    def quickMul(self, x, N):
        ans = 1.0
        while N > 0:
            if N % 2 == 1:
                ans *= x
            x *= x
            N //= 2
        return ans
```



#### [372. 超级次方](https://leetcode-cn.com/problems/super-pow/)：秦九韶，快速幂

C++注意防止越界！

```C++
class Solution {
public:
    // 直接：秦九韶算法的思想
    const int MOD = 1337;
    int superPow(int a, vector<int>& b) {
        int ans = 1;
        for(int i : b){
            // [(a^i1)^10 * a^i2]^10 * a^i3
            ans = (long) mypow(ans, 10) * mypow(a, i) % MOD;
        }
        return ans;
    }

    int mypow(int a, int n){
        // 化为二进制快速幂，a^n(mod 1337)，其中n是个位数
        int res = 1;
        while(n){
            if(n & 1){
                res = (long) res * a % MOD;
            }
            a = (long) a * a % MOD;
            // 遇到问题： runtime error: signed integer overflow
            n >>= 1;  // n /= 2;同理
        }
        return res;
    }
};
class Solution:
    def superPow(self, a: int, b: List[int]) -> int:
        # a^b(mod 1337)
        MOD = 1337
        ans = 1
        for e in b:
            ans = pow(ans, 10, MOD) * pow(a, e, MOD) % MOD
        return ans
```



#### [478. 在圆内随机生成点](https://leetcode.cn/problems/generate-random-point-in-a-circle/)：圆内的随机数

![img](https://uestc.feishu.cn/space/api/box/stream/download/asynccode/?code=OGFiMmUxYzVhM2RmM2ZhZmJlNTRkZmVjMTdlNDk3YWRfbGt1YnFua0JXaHpmb1c0clVaUDJncVdSR1lvOTZlQWFfVG9rZW46Ym94Y24yNFFUM1FRSHNFT0RGUWQ2cUhzbk1nXzE2NjI2NDE5MTE6MTY2MjY0NTUxMV9WNA)

![img](https://uestc.feishu.cn/space/api/box/stream/download/asynccode/?code=NWViMDMzYzVjMTU0ZDgxODg4OTI5ZjBlZmZjMjRlZTRfb1FYb0JKUEs3NVVCMzhybXZnQzJFYUEyZk9jS3VFMGxfVG9rZW46Ym94Y24yM1hEOEJFOGpqeHZWQWxxc0FtVGplXzE2NjI2NDE5MTE6MTY2MjY0NTUxMV9WNA)

1. > `rand() / double(RAND_MAX) `产生随机数的范围是0至1；

2. > `rand() / double(RAND_MAX) * 2 * r` 产生随机数范围为0至2r;

3. > `rand() / double(RAND_MAX) * 2 * r - r + x`产生随机数范围为x-r至x+r

```C++
#include <cmath>
class Solution {
public:
    double r, x, y;
    Solution(double radius, double x_center, double y_center): r(radius), x(x_center), y(y_center) {}
    
    vector<double> randPoint() {
        while (1) {
            double ranx = rand() / double(RAND_MAX) * 2 * r - r + x;
            double rany = rand() / double(RAND_MAX) * 2 * r - r + y;
            if (pow(x - ranx, 2) + pow(y - rany, 2) <= pow(r, 2))
                return vector<double> {ranx, rany};
        }
        // return vector<double>();
    }
};

/**
 * Your Solution object will be instantiated and called as such:
 * Solution* obj = new Solution(radius, x_center, y_center);
 * vector<double> param_1 = obj->randPoint();
 */
```

- 注意`class Solution`的初始化；
- 注意`rand()`函数的使用方法



#### [497. 非重叠矩形中的随机点](https://leetcode.cn/problems/random-point-in-non-overlapping-rectangles/)：按面积抽样

方法1：直接按照面积来分配概率

![img](https://uestc.feishu.cn/space/api/box/stream/download/asynccode/?code=ZDM4MjE2YTgxMWNiYmM3N2RjZGI1NjAxYzBlMzIxNzFfSUFOYUI0d0pBMkpnamRZa1E0R1hXNTU1ZEVxd2FtT0VfVG9rZW46Ym94Y25pQlllOXEzUkswOUpyYlFUa2dFaElnXzE2NjI2NDE5MTE6MTY2MjY0NTUxMV9WNA)

```C++
class Solution {
public:
    vector<vector<int>> recs;
    Solution(vector<vector<int>>& rectangles) {
        recs = rectangles;
    }
    
    vector<int> pick() {
        int idx = 0, curp = 0, allp = 0;
        int n = recs.size();
        for (int i = 0; i < n; i++) {
            int x1 = recs[i][0], y1 = recs[i][1];
            int x2 = recs[i][2], y2 = recs[i][3];
            curp = (x2 - x1 + 1) * (y2 - y1 + 1);
            allp += curp;
            if (rand() % allp < curp) idx = i;
        }
        int x = recs[idx][0] + rand() % (recs[idx][2] - recs[idx][0] + 1);
        int y = recs[idx][1] + rand() % (recs[idx][3] - recs[idx][1] + 1);
        return {x, y};
    }
};
```

> 如何选定一个矩形，还是按照随机的方式：巧思！



方法2：前缀和+二分？



#### [667. 优美的排列 II](https://leetcode.cn/problems/beautiful-arrangement-ii/)：构造升降序列

给定范围在[1,n] 的 n 个数，当「直接升序/降序」排列时，相邻项差值为 1，仅一种；

而从首位开始按照「升序」间隔排列，次位开始按照「降序」间隔排列（即排列为 [1, n, 2, n-1, 3, ...]）时，相邻差值会从 n - 1 开始递减至 1，共 n - 1 种。

> 1,2,3,4,5,6===>1,6,2,5,3,4（有5个间隔，5种）

那么当我们需要构造 k 种序列时，我们可以先通过「直接升序」的方式构造出若干个 1，然后再通过「间隔位分别升降序」的方式构造出从 k 到 1 的差值，共 k 个。

显然，我们需要 k + 1 个数来构造出 k 个差值。因此我们可以先从 1 开始，使用 n - (k + 1) 个数来直接升序（通过方式一构造出若干个 1），然后从 n - k 开始间隔升序排列，按照 n 开始间隔降序排列，构造出剩下的序列。

> **输入：**n = 3, k = 2，**输出：**[1, 3, 2]

```C++
class Solution {
public:
    vector<int> constructArray(int n, int k) {
        vector<int> ans(n);
        for (int i = 0; i < n - k - 1; i++) {
            ans[i] = i + 1;
        }
        int a = n - k, b = n;
        for (int i = n - k - 1; i < n; ) {
            ans[i++] = a++;
            if (i < n) ans[i++] = b--;
        }
        return ans;
    }
};
```









#### [793. 阶乘函数后 K 个零](https://leetcode.cn/problems/preimage-size-of-factorial-zeroes-function/)：？ 数学+二分

```Java
class Solution {
    public int preimageSizeFZF(int k) {
        if (k <= 1) return 5;
        return f(k) - f(k - 1);
    }
    int f(int x) {
        long l = 0, r = (long) 1e10;
        while (l < r) {
            long mid = l + r + 1 >> 1;
            if (getCnt(mid) <= x) l = mid;
            else r = mid - 1;
        }
        return (int)r;
    }
    long getCnt(long x) {
        long ans = 0;
        while (x != 0) {
            ans += x / 5; x /= 5;
        }
        return ans;
    }
}
```





#### [829. 连续整数求和](https://leetcode.cn/problems/consecutive-numbers-sum/)：运用数论

```Makefile
给定一个正整数 n，返回 连续正整数满足所有数字之和为 n 的组数 。 

示例 1:
输入: n = 5
输出: 2
解释: 5 = 2 + 3，共有两组连续整数([5],[2,3])求和后为 5。

示例 2:
输入: n = 9
输出: 3
解释: 9 = 4 + 5 = 2 + 3 + 4

示例 3:
输入: n = 15
输出: 4
解释: 15 = 8 + 7 = 4 + 5 + 6 = 1 + 2 + 3 + 4 + 5
```

原来数学也能解决算法题！！

![img](https://uestc.feishu.cn/space/api/box/stream/download/asynccode/?code=NTVlZTE1ZTNkYjdjZjEzYjIzNDE2M2U1MzVhNDg4ZjRfWVJvQ2x4TjhjWjd4bGdxenpZT1htd2VTdDNtYkF5V3RfVG9rZW46Ym94Y250R1VSWEFZcnlCRVFBZ2tJMFhxRDZjXzE2NjI2NDE5MTI6MTY2MjY0NTUxMl9WNA)

```Java
class Solution {
public:
    int consecutiveNumbersSum(int n) {
        int ans = 0;
        for (int k = 1; k*k < 2*n; k++) {
            if (2*n % k != 0) continue;
            // (2a+k−1)×k=2n 
            if ((2*n/k - (k-1)) % 2 == 0) ans++;
        }
        return ans;
    }
};
```



#### [899. 有序队列](https://leetcode.cn/problems/orderly-queue/)：最小表示法

```C++
给定一个字符串 s 和一个整数 k 。可以从 s 的前 k 个字母中选择一个，并把它加到字符串的末尾。
返回：在应用上述步骤的任意数量的移动后，字典上最小的字符串 。
```



**最小表示法**

- 当 k > 1 时，我们能够构造出任意的字符串方案，因此当 k > 1 时，我们可以直接通过对字符串排序来得到答案，复杂度为O(nlogn)。
- 当 k = 1 时，我们共有n种候选方案（将字符串 s 看作一个首尾相接的循环字符串，共有n个起点可枚举），枚举过程中需要与当前最优的方案进行比较，比较复杂度为O(n)，因此整体复杂度为O(n^2)

上述的做法已经可以通过本题，可以看出瓶颈在于对 k = 1 的处理。

而实际上，对于给定字符串s，求其循环同构的所有方案中字典序最小的方案，可以使用「最小表示法」来做，复杂度为 O(n)。

最小表示法将「方案比较」与「构造更优方案」进行结合：假设我们当前有两字符串 a 和 b 需要进行比较，其均为原串 s 的循环同构具体方案。假设 a 和 b 分别对应了原串下标为 i 和 j 的具体方案，且假设两字符串前 k 个字符均相同。当两字符串第一个不同的字符大小关系为cs[i+k]>cs[j+k] 时，可以发现以下标范围 [i,i+k] 作为起点的新方案必然不可能比字符串 b 更优，因此我们可以直接从 i+k+1 位置构造新的更优方案，并与 b 再次比较。而 cs[i+k]<cs[j+k] 的分析同理。

```C++
class Solution {
public:
    string orderlyQueue(string s, int k) {
        if (k == 1) {
            string small = s;
            int n = s.size();
            for (int i = 0; i < n; i++) {
                char ch = s[0];
                s = s.substr(1);
                s.push_back(ch);
                if (s < small) small = s;
            }
            return small;

        } else {
            sort(s.begin(), s.end());
            return s;
        }
    }
};
class Solution {
    public String orderlyQueue(String s, int _k) {
        char[] cs = s.toCharArray();
        if (_k == 1) {
            int i = 0, j = 1, k = 0, n = cs.length;
            while (i < n && j < n && k < n) {
                char a = cs[(i + k) % n], b = cs[(j + k) % n];
                if (a == b) k++;
                else {
                    if (a > b) i += k + 1;
                    else j += k + 1;
                    if (i == j) i++;
                    k = 0;
                }
            }
            i = Math.min(i, j);
            return s.substring(i) + s.substring(0, i);
        } else {
            Arrays.sort(cs);
            return String.valueOf(cs);
        }
    }
}
```



#### [1610. 可见点的最大数目](https://leetcode-cn.com/problems/maximum-number-of-visible-points/)：极坐标+滑动窗口

注意极坐标的转化方法！

```C++
class Solution {
public:
    // 全部换为[0,2π]上的极坐标就行，计算角度，从小到大放入排序？+滑动窗口
    int visiblePoints(vector<vector<int>>& points, int angle, vector<int>& location) {
        int sameCnt = 0;
        vector<double> polarDegrees;
        for (auto & point : points) {
            if (point[0] == location[0] && point[1] == location[1]) {
                sameCnt++;
                continue;
            }
            // atan2的返回值范围为[−π,π]，覆盖范围为2π，atan2(y,x)=>arctan(y/x)
            double degree = atan2(point[1] - location[1], point[0] - location[0]);
            polarDegrees.push_back(degree);
        }
        sort(polarDegrees.begin(), polarDegrees.end());
        int m = polarDegrees.size();
        for (int i = 0; i < m; ++i) {
            polarDegrees.push_back(polarDegrees[i] + 2 * M_PI);  // 全部把区间换为[0,2π]
        }

        int maxCnt = 0;
        int right = 0;  // 滑动窗口右下标
        double polar_angle = angle * M_PI / 180;
        for (int i = 0; i < m; ++i) {
            while (right < polarDegrees.size() && polarDegrees[right] <= polarDegrees[i] + polar_angle) {
                right++;  // 符合角度范围条件就一直增大窗口
            }
            maxCnt = max(maxCnt, right - i);
        }
        return maxCnt + sameCnt;
    }
};
```

####  

#### [1447. 最简分数](https://leetcode-cn.com/problems/simplified-fractions/)：利用gcd(a,b)

```C++
class Solution {
public:
    vector<string> simplifiedFractions(int n) {
        vector<string> ans;
        for (int b = 2; b <= n; ++b) {
            for (int a = 1; a < b; ++a) {
                if (gcd(a, b) == 1)
                    ans.push_back(to_string(a) + "/" + to_string(b));  // =>a/b
            }
        }
        return ans;
    }
};
class Solution:
    def simplifiedFractions(self, n: int) -> List[str]:
        return ["{}/{}".format(a,b) for b in range(2, n + 1) for a in range(1,b) if gcd(a, b) == 1]
```

这里，还可尝试几种求解最大公约数的方法：

**辗转相除法：**

一行代码就能实现gcd！！

```Python
class Solution:
    def simplifiedFractions(self, n: int) -> List[str]:
        
        def my_gcd(a, b):
            return my_gcd(b % a, a) if b % a else a

        return ["{}/{}".format(a,b) for b in range(2, n + 1) for a in range(1,b) if my_gcd(a, b) == 1]
class Solution {
public:
    vector<string> simplifiedFractions(int n) {
        vector<string> ans;
        for (int b = 2; b <= n; ++b) {
            for (int a = 1; a < b; ++a) {
                if (_gcd(a, b) == 1)
                    ans.push_back(to_string(a) + "/" + to_string(b));  // =>a/b
            }
        }
        return ans;
    }

    int _gcd (int a, int b) {
        return b % a == 0 ? a : gcd(b % a, a);
    }

};
```

**更相减损术：**

```Python
class Solution:
    def simplifiedFractions(self, n: int) -> List[str]:
        def my_gcd(a, b):
            while True:
                if a>b: a-=b
                elif a<b: b-=a
                else: return a

        return ["{}/{}".format(a,b) for b in range(2, n + 1) for a in range(1,b) if my_gcd(a, b) == 1]
```

**素数筛：**

```Python
class Solution:
    def simplifiedFractions(self, n: int) -> List[str]:
        isPrime = [True] * (n + 1)
        primes = []
        for i in range(2, n + 1):  # j/i
            if isPrime[i]:
                for j in range(i * i, n + 1, i):
                    isPrime[j] = False
                primes.append(i)
        ans = []
        # 枚举分母
        for i in range(2, n + 1):
            if isPrime[i]:
                ans += ["{}/{}".format(j, i) for j in range(1, i)]
            else:
                idx, ps = 0, set()
                # 分母的所有质因子
                while idx < len(primes) and primes[idx] < i // 2 + 1:
                    if not i % primes[idx]:
                        ps.add(primes[idx])
                    idx += 1
                s = set()
                # 构造分母的所有最大公约数不为1的分子
                for p in ps:
                    for j in range(p, i, p):
                        s.add(j)
                ans += ["{}/{}".format(j, i) for j in range(1, i) if j not in s]
        return ans
```



#### [1518. 换酒问题](https://leetcode-cn.com/problems/water-bottles/)

![img](https://uestc.feishu.cn/space/api/box/stream/download/asynccode/?code=ZWMzNzA1NmU3MWNkZjNjOTA4NDE1NmQ1MDM1NzQyMDVfckZQa2VoZTVDY2p3TTc4bXFyWElFVFpNeFZLVWFXeTJfVG9rZW46Ym94Y25ERUp0SFFIckFBYUNVdm5ZWGJKUGg3XzE2NjI2NDE5MTI6MTY2MjY0NTUxMl9WNA)

```Python
class Solution:
    def numWaterBottles(self, numBottles: int, numExchange: int) -> int:
        ans = numBottles
        while numBottles >= numExchange:
            a, b = numBottles // numExchange, numBottles % numExchange
            ans += a
            numBottles = a + b
        return ans
```

#### [2022. 一维数组变成二维](https://leetcode-cn.com/problems/convert-1d-array-into-2d-array/)：巧妙的写法+emplace_back

```C++
class Solution {
public:
    vector<vector<int>> construct2DArray(vector<int>& original, int m, int n) {
        vector<vector<int>> ans;
        if(original.size() != m * n)
            return ans;
        for(auto p = original.begin(); p != original.end(); p += n){
            ans.emplace_back(p, p + n);
        }
        return ans;
    }
};
class Solution:
    def construct2DArray(self, original: List[int], m: int, n: int) -> List[List[int]]:
        length = len(original)
        if length != m * n:
            return []
        return [original[i : i + n] for i in range(0, length, n)]
```





# 动态规划

**Learning plan：**

- [【动态规划/背包问题】那就从 0-1 背包问题开始讲起吧 ... (qq.com)](https://mp.weixin.qq.com/s/xmgK7SrTnFIM3Owpk-emmg)
- 练题：[【宫水三叶の相信科学系列】详解为何能转换为背包问题 - 最后一块石头的重量 II - 力扣（LeetCode）](https://leetcode.cn/problems/last-stone-weight-ii/solution/gong-shui-san-xie-xiang-jie-wei-he-neng-jgxik/)
- [【宫水三叶】详解完全背包一维空间优化推导（附背包问题攻略） - 完全平方数 - 力扣（LeetCode）](https://leetcode.cn/problems/perfect-squares/solution/gong-shui-san-xie-xiang-jie-wan-quan-bei-nqes/)





## **动态规划**

系统学习一下动态规划：[代码随想录 (programmercarl.com)](https://programmercarl.com/动态规划理论基础.html#什么是动态规划)

状态转移公式（递推公式）是很重要，但动规不仅仅只有递推公式。

**对于动态规划问题，拆解为如下五步曲，这5步都搞清楚了，才能说把动态规划真的掌握了！**

1. 确定dp数组（dp table）以及下标的含义（dp[i]的含义）
2. 确定递推公式
3. dp数组如何初始化
4. 确定遍历顺序（从前向后/从后向前，两层for是先遍历背包还是先遍历物品？）
5. 打印dp数组（是为了验证结果，看看是不是按照思路进行的）

```C++
伪代码

for (i ...背包)
    for (j ...物品)
        dp[]=...递推公式
```



## **背包问题**

参考：[代码随想录 (programmercarl.com)](https://programmercarl.com/背包理论基础01背包-1.html)

- 01背包、完全背包、多重背包
- 对于背包问题，常用二维dp数组进行解决，进而可以优化为一维dp数组

背包最大重量为4。

物品为：

无法复制加载中的内容

问背包能背的物品最大价值是多少？

以下讲解和图示中出现的数字都是以这个例子为例。

### [二维dp数组01背包](https://programmercarl.com/背包理论基础01背包-1.html#二维dp数组01背包)

依然动规五部曲分析一波。

1. 确定dp数组以及下标的含义

对于背包问题，有一种写法， 是使用二维数组，（01背包，是多种物品放与不放的问题）

即**dp[i][j] 表示从下标为[0-i]的物品里任意取，放进容量为j的背包，****价值总和最大是多少**。

只看这个二维数组的定义，大家一定会有点懵，看下面这个图：

![img](https://uestc.feishu.cn/space/api/box/stream/download/asynccode/?code=NjNlYjgzMGE2MGI5MzM0NjU2NWY3OGJhYzdhYTNmYTNfSnlkSkpKaGF4TGx5bjVkTWw2bE1aVWs1NTFvT3VNaWNfVG9rZW46Ym94Y250U1J3bzhaYUhYWmoyNmUzMHVzR0RlXzE2NjI2NDE5MTI6MTY2MjY0NTUxMl9WNA)

**要时刻记着这个dp数组的含义，下面的一些步骤都围绕这dp数组的含义进行的**，如果哪里看懵了，就来回顾一下i代表什么，j又代表什么。

1. 确定递推公式

再回顾一下dp[i][j]的含义：从下标为[0-i]的物品里任意取，放进容量为j的背包，价值总和最大是多少。那么可以有两个方向推出来dp[i][j]，

- **不放物品i**：由dp[i - 1][j]推出，即背包容量为j，里面不放物品i的最大价值，此时dp[i][j]就是dp[i - 1][j]。(其实就是当物品i的重量大于背包j的重量时，物品i无法放进背包中，所以被背包内的价值依然和前面相同。)
- **放物品i**：由dp[i - 1][j - weight[i]]推出，dp[i - 1][j - weight[i]] 为背包容量为j - weight[i]的时候不放物品i的最大价值，那么dp[i - 1][j - weight[i]] + value[i] （物品i的价值），就是背包放物品i得到的最大价值

所以递归公式：`dp[i][j] = max(dp[i-1][j], dp[i-1][j-weight[i]] + value[i]);`

1. dp数组如何初始化（见视频讲解）
2. 确定遍历顺序

有两个遍历的维度：物品与背包重量那么问题来了，**先遍历 物品还是先遍历背包重量呢？**

**其实都可以！！ 但是先遍历物品更好理解**。

那么我先给出先遍历物品，然后遍历背包重量的代码。

> 遍历过程中，当前dp[i][j]是由它的上方和左上方的数值决定的

```C++
// weight数组的大小 就是物品个数
for (int i = 1; i < weight.size(); i++) { // 遍历物品
    for (int j = 0; j <= bagweight; j++) { // 遍历背包容量
        if (j < weight[i]) dp[i][j] = dp[i - 1][j]; 
        else dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i]);

    }
}
```

先遍历背包，再遍历物品，也是可以的！（注意我这里使用的二维dp数组）

```C++
// weight数组的大小 就是物品个数
for (int j = 0; j <= bagweight; j++) { // 遍历背包容量
    for (int i = 1; i < weight.size(); i++) { // 遍历物品
        if (j < weight[i]) dp[i][j] = dp[i - 1][j];
        else dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i]);
    }
}
void test() {
    vector<int> weight = {1, 3, 4};
    vector<int> value = {15, 20, 30};
    int bagweight = 4;

    vector<vector<int>> dp(weight.size(), vector<int>(bagweight + 1, 0));

    // 初始化
    for (int j = weight[0]; j <= bagweight; j++) {
        dp[0][j] = value[0];
    }

    // weight数组的大小 就是物品个数
    for(int i = 1; i < weight.size(); i++) { // 遍历物品
        for(int j = 0; j <= bagweight; j++) { // 遍历背包容量
            if (j < weight[i]) dp[i][j] = dp[i - 1][j];
            else dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i]);
        }
    }
    cout << dp[weight.size() - 1][bagweight] << endl;
}
```

### 一维dp数组01背包（滚动数组）

一维数组实现，其实是对二维dp数组的压缩，把i-1层的数据拷贝更新成i层的就可以了（但for有顺序）

1. 确定dp数组的定义

在一维dp数组中，**dp[j]表示：容量为j的背包，所背的物品价值可以最大为dp[j]。**

1. 一维dp数组的递推公式

递归公式为：`dp[j] = max(dp[j], dp[j-weight[i]] + value[i]);`

1. 一维dp数组如何初始化：全是0就行。
2. 一维dp数组遍历顺序：`dp[j] = max(dp[j], dp[j-weight[i]] + value[i])`

注意，**遍历背包的时候是倒序地遍历！！**

> 每次遍历某一类物品i时，倒序地遍历背包容量j，才能保证物品只放进去一次

```C++
for (int i = 0; i < weight.size(); i++) { // 遍历物品
    for (int j = bagWeight; j >= weight[i]; j--) { // 遍历背包容量
        dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);
    }
}
void test() {
    vector<int> weight = {1, 3, 4};
    vector<int> value = {15, 20, 30};
    int bagWeight = 4;

    // 初始化
    vector<int> dp(bagWeight + 1, 0);
    for(int i = 0; i < weight.size(); i++) { // 遍历物品
        for(int j = bagWeight; j >= weight[i]; j--) { // 遍历背包容量
            dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);
        }
    }
    cout << dp[bagWeight] << endl;
}
```



### 完全背包

完全背包不需要保证每个物品只出现一次。

> 01背包和完全背包唯一不同就是体现在遍历顺序上：我们知道01背包内嵌的循环是从大到小遍历，为了保证每个物品仅被添加一次。

而完全背包的物品是可以添加多次的，所以要从小到大去遍历，即：

> 注意这里是一维的dp数组

```C++
// 先遍历物品，再遍历背包
for (int i = 0; i < weight.size(); i++) { // 遍历物品
    for (int j = weight[i]; j <= bagWeight; j++) { // 遍历背包容量
        dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);
    }
}
```

因此，完全背包的两个for循环的顺序也是无所谓的，二者都是从小到大。

```C++
// 先遍历物品，在遍历背包
void test{
    vector<int> weight = {1, 3, 4};
    vector<int> value = {15, 20, 30};
    int bagWeight = 4;
    vector<int> dp(bagWeight + 1, 0);
    for(int i = 0; i < weight.size(); i++) { // 遍历物品
        for(int j = weight[i]; j <= bagWeight; j++) { // 遍历背包容量
            dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);
        }
    }
    cout << dp[bagWeight] << endl;
}

// 先遍历背包，再遍历物品
    for(int j = 0; j <= bagWeight; j++) { // 遍历背包容量
        for(int i = 0; i < weight.size(); i++) { // 遍历物品
            if (j - weight[i] >= 0) {
                dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);
            }
        }
    }
```





- > 发现dp的问题大多与**前缀和**有关：**前缀和就是从位置1到位置i这个区间内的所有的数字之和**



## (0)动态规划

> 这一分类是因为单纯不知道怎么分类了



**系统练习：**

#### [509. 斐波那契数](https://leetcode.cn/problems/fibonacci-number/)

#### [70. 爬楼梯](https://leetcode.cn/problems/climbing-stairs/)

#### [746. 使用最小花费爬楼梯](https://leetcode.cn/problems/min-cost-climbing-stairs/)

这里注意返回值！！到达n，是计算从n-1和n-2出发

```C++
class Solution {
public:
    // dp[i]的定义：到达第i个台阶所花费的最少体力为dp[i]。
    // cost[i]是从i出发的费用
    int minCostClimbingStairs(vector<int>& cost) {
        int n = cost.size();
        vector<int> dp(n);
        dp[0] = cost[0], dp[1] = cost[1];
        for (int i = 2; i < n; i++) {
            dp[i] = min(dp[i - 1], dp[i - 2]) + cost[i];
        }
        return min(dp[n - 1], dp[n - 2]);
    }
};
```

#### [62. 不同路径](https://leetcode.cn/problems/unique-paths/)：二维dp[i][j]

按照动规五部曲来分析：

1. 确定dp数组（dp table）以及下标的含义

dp[i][j] ：表示从（0 ，0）出发，到(i, j) 有dp[i][j]条不同的路径。

1. 确定递推公式

想要求dp[i][j]，只能有两个方向来推导出来，即dp[i - 1][j] 和 dp[i][j - 1]。

此时在回顾一下 dp[i - 1][j] 表示啥，是从(0, 0)的位置到(i - 1, j)有几条路径，dp[i][j - 1]同理。

那么很自然，dp[i][j] = dp[i - 1][j] + dp[i][j - 1]，因为dp[i][j]只有这两个方向过来。

1. **dp数组的初始化**

如何初始化呢，首先dp[i][0]一定都是1，因为从(0, 0)的位置到(i, 0)的路径只有一条，那么dp[0][j]也同理。

所以初始化代码为：

```Plain%20Text
for (int i = 0; i < m; i++) dp[i][0] = 1;
for (int j = 0; j < n; j++) dp[0][j] = 1;
```

1. 确定遍历顺序

这里要看一下递归公式dp[i][j] = dp[i - 1][j] + dp[i][j - 1]，**dp[i][j]都是从其上方和左方推导而来**，那么从左到右一层一层遍历就可以了。

这样就可以保证推导dp[i][j]的时候，dp[i - 1][j] 和 dp[i][j - 1]一定是有数值的。

1. 举例推导dp数组

```C++
class Solution {
public:
    // dp[i][j]：从起点到(i,j)有dp[i][j]条路径
    // dp[i][j] = dp[i - 1][j] + dp[i][j - 1]
    int uniquePaths(int m, int n) {
        vector<vector<int>> dp(m, vector<int>(n, 0));       // m * n
        for (int i = 0; i < m; i++) dp[i][0] = 1;
        for (int j = 0; j < n; j++) dp[0][j] = 1;

        for (int i = 1; i < m; i++) {
            for (int j = 1; j < n; j++) {
                dp[i][j] = dp[i - 1][j] + dp[i][j - 1];
            }
        }
        return dp[m - 1][n - 1];
    }
};
```

**注意循环条件！！**

#### [63. 不同路径 II](https://leetcode.cn/problems/unique-paths-ii/)：带有障碍物的二维dp

与上面一题的不同之处在于，

1. 递推公式需要加上条件判断：无障碍物
2. 初始化边界值理应不变，但是如果障碍物在边界上，后续的就不能够再赋值1了

```C++
class Solution {
public:
    int uniquePathsWithObstacles(vector<vector<int>>& obst) {
        int m = obst.size(), n = obst[0].size();
        if (obst[0][0] == 1 || obst[m - 1][n - 1] == 1) return 0;   // 如果在起点或终点出现了障碍，直接返回0

        vector<vector<int>> dp(m, vector<int>(n, 0));
        for (int i = 0; i < m && obst[i][0] == 0; i++) dp[i][0] = 1;
        for (int j = 0; j < n && obst[0][j] == 0; j++) dp[0][j] = 1;

        for (int i = 1; i < m; i++) {
            for (int j = 1; j < n; j++) {
                if (obst[i][j] == 1) continue;
                else dp[i][j] = dp[i - 1][j] + dp[i][j - 1];
            }
        }
        return dp[m - 1][n - 1];
    }
};
```

#### [343. 整数拆分](https://leetcode.cn/problems/integer-break/)：居然可以动规！

动规五部曲，分析如下：

1. 确定dp数组（dp table）以及下标的含义

**dp[i]：分拆数字i，可以得到的最大乘积为dp[i]。**

dp[i]的定义讲贯彻整个解题过程，下面哪一步想不懂了，就想想dp[i]究竟表示的是啥！

1. 确定递推公式

可以想 dp[i]最大乘积是怎么得到的呢？

其实可以从1遍历j，然后有两种渠道得到dp[i].

- 一个是j * (i - j) 直接相乘。
- 一个是j * dp[i - j]，相当于是拆分(i - j)，对这个拆分不理解的话，可以回想dp数组的定义。

> **那有同学问了，j怎么就不拆分呢？**

j是从1开始遍历，拆分j的情况，在遍历j的过程中其实都计算过了。那么从1遍历j，比较(i - j) * j和dp[i - j] * j 取最大的。

**递推公式：**`**dp[i] = max(dp[i], max((i - j) \* j, dp[i - j] \* j))**`**;**

也可以这么理解，j * (i - j) 是单纯的把整数拆分为两个数相乘，而j * dp[i - j]是拆分成两个以及两个以上的个数相乘。

如果定义dp[i - j] * dp[j] 也是默认将一个数强制拆成4份以及4份以上了。

所以递推公式：dp[i] = max({dp[i], (i - j) * j, dp[i - j] * j});

那么在取最大值的时候，为什么还要比较dp[i]呢？

因为在递推公式推导的过程中，每次计算dp[i]，取最大的而已。

1. dp的初始化

不少同学应该疑惑，dp[0] dp[1]应该初始化多少呢？

有的题解里会给出dp[0] = 1，dp[1] = 1的初始化，但解释比较牵强，主要还是因为这么初始化可以把题目过了。

严格从dp[i]的定义来说，dp[0] dp[1] 就不应该初始化，也就是没有意义的数值。

拆分0和拆分1的最大乘积是多少？

这是无解的。

这里我只初始化dp[2] = 1，从dp[i]的定义来说，拆分数字2，得到的最大乘积是1，这个没有任何异议！

1. 确定遍历顺序

确定遍历顺序，先来看看递归公式：dp[i] = max(dp[i], max((i - j) * j, dp[i - j] * j));

**dp[i] 是依靠 dp[i - j]的状态，所以遍历i一定是从前向后遍历**，先有dp[i - j]再有dp[i]。

**枚举的时候，j是从1开始的，i是从3开始**，这样dp[i - j]就是dp[2]正好可通过我们初始化的数值求出来。

所以遍历顺序为：

```Plain%20Text
for (int i = 3; i <= n ; i++) {
    for (int j = 1; j < i - 1; j++) {
        dp[i] = max(dp[i], max((i - j) * j, dp[i - j] * j));
    }
}
```

1. 举例推导dp数组

```C++
class Solution {
public:
    // dp[i]：分拆数字i，可以得到的最大乘积为dp[i]
    // 递推公式：dp[i] = max(dp[i], max((i - j) * j, dp[i - j] * j))
    int integerBreak(int n) {
        vector<int> dp(n + 1);
        dp[2] = 1;
        for (int i = 3; i <= n; i++) {
            for (int j = 1; j < i - 1; j++) {
                dp[i] = max(dp[i], max(j * (i - j), j * dp[i - j]));
            }
        }
        return dp[n];
    }
};
```

> 此外，还有一种数学分析方法

#### [96. 不同的二叉搜索树](https://leetcode.cn/problems/unique-binary-search-trees/)：也是一种动规！

1. 确定dp数组和下标含义

**dp[i] ： 1到i为节点组成的二叉搜索树的个数为dp[i]**。

也可以理解是i的不同元素节点组成的二叉搜索树的个数为dp[i] ，都是一样的。

1. 确定递推公式

在上面的分析中，其实已经看出其递推关系， 

dp[i] += dp[**以j为头结点左子树节点数量**] * dp[**以j为头结点右子树节点数量**]

j相当于是头结点的元素，从1遍历到i为止。

所以递推公式：`dp[i] += dp[j - 1] * dp[i - j]`; ，j-1 为j为头结点左子树节点数量，i-j 为以j为头结点右子树节点数量

以j为分割，j-1个比j小的在左子树，i-j个比j大的在右子树

> 比如：

> dp[3] = 元素1为头结点搜索树的数量 + 元素2为头结点搜索树的数量 + 元素3为头结点搜索树的数量

> 元素1为头结点搜索树的数量 = 右子树有2个元素的搜索树数量 * 左子树有0个元素的搜索树数量

> 元素2为头结点搜索树的数量 = 右子树有1个元素的搜索树数量 * 左子树有1个元素的搜索树数量

> 元素3为头结点搜索树的数量 = 右子树有0个元素的搜索树数量 * 左子树有2个元素的搜索树数量

> 也就是：dp[3] = dp[2] * dp[0] + dp[1] * dp[1] + dp[0] * dp[2]，依次选择根进行分类讨论

1. dp数组如何初始化

初始化，只需要初始化dp[0]就可以了，推导的基础，都是dp[0]。

那么dp[0]应该是多少呢？

从定义上来讲，空节点也是一棵二叉树，也是一棵二叉搜索树，这是可以说得通的。

从递归公式上来讲，dp[以j为头结点左子树节点数量] * dp[以j为头结点右子树节点数量] 中以j为头结点左子树节点数量为0，也需要dp[以j为头结点左子树节点数量] = 1， 否则乘法的结果就都变成0了。

所以初始化dp[0] = 1

1. 确定遍历顺序

首先一定是遍历节点数，从递归公式：dp[i] += dp[j - 1] * dp[i - j]可以看出，节点数为i的状态是依靠 i之前节点数的状态。

那么遍历i里面每一个数作为头结点的状态，用j来遍历。

代码如下：

```C++
for (int i = 1; i <= n; i++) {
    for (int j = 1; j <= i; j++) {
        dp[i] += dp[j - 1] * dp[i - j];
    }
}
```

1. 举例推导dp数组

```C++
class Solution {
public:
    // dp[i] += dp[以j为头结点左子树节点数量] * dp[以j为头结点右子树节点数量]
    int numTrees(int n) {
        vector<int> dp(n + 1);
        dp[0] = 1;
        for (int i = 1; i <= n; i++) {
            for (int j = 1; j <= i; j++) {
                dp[i] += dp[j - 1] * dp[i - j];
            }
        }
        return dp[n];
    }
};
```

另一种边界：

```C++
class Solution {
public:
    int numTrees(int n) {
        vector<int> dp(n + 1);
        dp[0] = 1, dp[1] = 1;
        for (int i = 2; i <= n; i++) {
            for (int j = 1; j <= i; j++) {
                dp[i] += dp[j - 1] * dp[i - j];
            }
        }
        return dp[n];
    }
};
```



法2：纯数学方法（见官方题解）



#### [416. 分割等和子集](https://leetcode.cn/problems/partition-equal-subset-sum/)：居然是01背包

据说可以类似[473. 火柴拼正方形](https://leetcode.cn/problems/matchsticks-to-square/) 这个题目的思路来思考

但是，本题实则是用动态规划的01背包：背包容量sum/2，并且要恰好装满

- > 【三叶の题解】[【宫水三叶の背包问题(上)】如何将原问题抽象为「01 背包」问题](https://leetcode.cn/problems/partition-equal-subset-sum/solution/gong-shui-san-xie-bei-bao-wen-ti-shang-r-ln14/)

我们直接套用「01 背包」的状态定义：

*f*[*i*][*j*] 代表考虑前 *i* 个数值，其选择数字总和不超过 *j* 的最大价值。

![img](https://uestc.feishu.cn/space/api/box/stream/download/asynccode/?code=MTFkMTNhNTU3NWZjYjVhNWFhYzUxYzgxY2MyZTA1N2RfdjQ5dkJHRFlGUjZLbnpaaGV5T1dDWXpzTjlPanlVNTNfVG9rZW46Ym94Y25QRjR2SVJQOFNZQnA4dWUxT2dGWHFlXzE2NjI2NDE5MTI6MTY2MjY0NTUxMl9WNA)

```C++
class Solution {
public:
    bool canPartition(vector<int>& nums) {
        int n = nums.size();
        int sum = accumulate(nums.begin(), nums.end(), 0);
        if (sum % 2 != 0) return false;
        int target = sum / 2;

        // dp[i][j]：前i个数的总和不超过容量j的最大价值
        vector<vector<int>> dp(n, vector<int>(target + 1));

        // 对于第一个数
        for (int j = 0; j <= target; j++) {
            if (j >= nums[0]) dp[0][j] = nums[0];
        }
        // 依次考虑后面几个数
        for (int i = 1; i < n; i++) {
            for (int j = 0; j <= target; j++) {
                if (j < nums[i]) dp[i][j] = dp[i-1][j];     // 不放第i个
                else dp[i][j] = max(dp[i-1][j], dp[i-1][j-nums[i]] + nums[i]);      // 放第i个
            }
        }
        // 如果最大价值等于 target，说明可以拆分成两个「等和子集」
        return dp[n-1][target] == target;
    }
};
```



如果使用滚动数组进行一维空间优化：

```C++
class Solution {
public:
    bool canPartition(vector<int>& nums) {
        int n = nums.size();
        int sum = accumulate(nums.begin(), nums.end(), 0);
        if (sum % 2 != 0) return false;
        int target = sum / 2;

        // dp[j]：for前i个数的总和遍历，不超过容量j的最大价值
        vector<int> dp(target + 1);

        // // 对于第一个数
        // for (int j = 0; j <= target; j++) {
        //     if (j >= nums[0]) dp[j] = nums[0];
        // }
        // 依次考虑后面几个数
        for (int i = 1; i < n; i++) {
            for (int j = target; j >= 0; j--) {
                if (j < nums[i]) continue;     // 不放第i个
                else dp[j] = max(dp[j], dp[j-nums[i]] + nums[i]);      // 放第i个
            }
        }
        // 如果最大价值等于 target，说明可以拆分成两个「等和子集」
        return dp[target] == target;
    }
};
```

其实第二层for循环有点多，可以直接：

```C++
for (int i = 0; i < nums.size(); i++) {
    for (int j = target; j >= nums[i]; j--) { 
        dp[j] = max(dp[j], dp[j - nums[i]] + nums[i]);
    }
}
```



#### [1049. 最后一块石头的重量 II](https://leetcode.cn/problems/last-stone-weight-ii/)：01背包

将石头尽量分成和相等的两堆再求差值，类似于分割等和子集--**转化为01背包来做**

【三叶の题解】将问题彻底切换为 01 背包问题：从stones数组中选择，凑成总和不超过 sum/2的最大价值。其中「成本」&「价值」均为数值本身。

整理一下：定义f[i][j]代表考虑前i个物品（数值）凑成总和不超过j的最大价值。

每个物品都有「选」和「不选」两种决策，转移方程为：

```
f[i][j] = max(f[i−1][j], f[i−1][j−stones[i−1]] + stones[i−1])
```

与完全背包不同，01 背包的几种空间优化是不存在时间复杂度上的优化，因此写成 朴素二维、滚动数组、一维优化 都可以。

建议直接上手写「一维空间优化」版本，是其他背包问题的基础。

**与上一题几乎一模一样！！**

```C++
class Solution {
public:
    int lastStoneWeightII(vector<int>& stones) {
        int n = stones.size();
        int sum = accumulate(stones.begin(), stones.end(), 0);
        int target = sum / 2;

        // dp[i][j]：前i个数的总和不超过容量j的最大价值
        vector<vector<int>> dp(n, vector<int>(target + 1));
        for (int j = 0; j <= target; j++) {
            if (j >= stones[0]) dp[0][j] = stones[0];
        }
        for (int i = 1; i < n; i++) {
            for (int j = 0; j <= target; j++) {
                if (j < stones[i]) dp[i][j] = dp[i-1][j];
                else dp[i][j] = max(dp[i-1][j], dp[i-1][j-stones[i]] + stones[i]);
            }
        }
        return abs(sum - dp[n-1][target] - dp[n-1][target]);
    }
};
class Solution {
public:
    int lastStoneWeightII(vector<int>& stones) {
        int n = stones.size();
        int sum = accumulate(stones.begin(), stones.end(), 0);
        int target = sum / 2;

        vector<int> dp(target + 1);
        for (int j = 0; j <= target; j++) {
            if (j >= stones[0]) dp[j] = stones[0];
        }
        for (int i = 1; i < n; i++) {
            for (int j = target; j >= stones[i]; j--) {
                dp[j] = max(dp[j], dp[j-stones[i]] + stones[i]);
            }
        }
        return abs(sum - dp[target] - dp[target]);
    }
};
```

> 对一维dp的初始化！第二个for从1开始，那么就要对第一个进行一次初始化（注意与上面的区别）



#### [494. 目标和](https://leetcode.cn/problems/target-sum/)：dfs or 背包动规

求增加运算符后的运算结果等于target的方法数

**法1：dfs 【三叶の题解】**

数据范围只有20，而且每个数据只有+/-两种选择，因此可以直接使用dfs进行「爆搜」。

而dfs有**「使用全局变量维护」**和**「接收返回值处理」**两种形式。

```C++
class Solution {
public:
    int ans = 0;
    void dfs(vector<int>& nums, int target, int idx, int sum) {
        if (idx == nums.size()) {
            if (sum == target) ans++;
            return;
        }
        dfs(nums, target, idx + 1, sum + nums[idx]);
        dfs(nums, target, idx + 1, sum - nums[idx]);
    }
    int findTargetSumWays(vector<int>& nums, int target) {
        dfs(nums, target, 0, 0);
        return ans;
    }
};
class Solution {
public:
    int dfs(vector<int>& nums, int target, int idx, int sum) {
        if (idx == nums.size()) {
            if (sum == target) return 1;
            else return 0;
        }
        int left = dfs(nums, target, idx + 1, sum + nums[idx]);
        int right = dfs(nums, target, idx + 1, sum - nums[idx]);
        return left + right;
    }
    int findTargetSumWays(vector<int>& nums, int target) {
        return dfs(nums, target, 0, 0);
    }
};
```



**法2：动态规划**

还是把+和-分成两部分，总和是target。

总和sum，正数部分和m，负数部分和(sum-m)，m-(sum-m)=target，则m=(target+sum)/2

**问题再次转换为：从nums中凑出和为m的那部分数**

定义f[i][j]：涵盖到第i个数，从nums凑出总和恰好为 j 的方案数。最终答案为f[n][m]，f[0][0]=1为起始条件：代表不考虑任何数，凑出计算结果为0的方案数为1种。

每个数值有「选」和「不选」两种决策，转移方程为：

```
f[i][j] = f[i - 1][j] + f[i - 1][j - nums[i - 1]]
class Solution {
public:
    int findTargetSumWays(vector<int>& nums, int target) {
        int n = nums.size();
        int sum = accumulate(nums.begin(), nums.end(), 0);
        // 对于负数的target不行
        target = abs(target);
        if (sum < target || (sum + target) % 2 != 0) return 0;

        int m = (sum + target) / 2;

        // dp[i][j]：凑出总和恰好为 j 的方案数
        vector<vector<int>> dp(n + 1, vector<int>(m + 1));
        dp[0][0] = 1;
        for (int i = 1; i <= n; i++) {
            for (int j = 0; j <= m; j++) {
                dp[i][j] += dp[i-1][j];
                if (j >= nums[i-1]) {
                    dp[i][j] += dp[i-1][j-nums[i-1]];
                }
            }
        }
        return dp[n][m];
    }
};
```

其实，仿照三叶の做法，使用负数会避免这样的问题

```C++
if (sum < target || (sum - target) % 2 != 0) return 0;
int m = (sum - target) / 2;
```

直接优化为**一维的dp数组**：(似乎更好理解）

```C++
class Solution {
public:
    int findTargetSumWays(vector<int>& nums, int target) {
        int n = nums.size();
        int sum = accumulate(nums.begin(), nums.end(), 0);
        if (sum < target || (sum - target) % 2 != 0) return 0;
        
        int m = (sum - target) / 2;
        vector<int> dp(m + 1);
        dp[0] = 1;
        for (int i = 0; i < n; i++) {
            for (int j = m; j >= nums[i]; j--) {
                dp[j] += dp[j - nums[i]];
            }
        }
        return dp[m];
    }
};
```



#### [474. 一和零](https://leetcode.cn/problems/ones-and-zeroes/)：多维01背包

仍然可以使用01背包，只不过物品的价值有多个维度

**每个字符串的价值都是 1（对答案的贡献都是 1），选择的成本是该字符串中 1 的数量和 0 的数量。**

**dp[k][i][j]代表考虑前 k 件物品，在数字1容量不超过** ***i*****，数字0容量不超过** ***j*** **的条件下的「最大价值」（每个字符串的价值均为 1）**

```C++
class Solution {
public:
    int findMaxForm(vector<string>& strs, int m, int n) {
        int len = strs.size();
        // 预处理str中的0和1数量
        vector<vector<int>> cnt(len, vector<int>(2));
        for (int i = 0; i < len; i++) {
            string str = strs[i];
            int zero = 0, one = 0;
            for (char c : str) {
                if (c == '0') zero++;
                else one++;
            }
            cnt[i] = {zero, one};
        }
        
        // dp[k][i][j]代表考虑前k件物品，在数字1容量不超过i，数字0容量不超过j的条件下的最大元素个数
        vector<vector<vector<int>>> dp(len, vector<vector<int>>(m + 1, vector<int>(n + 1)));
        // 对第一个数进行初始化
        for (int i = 0; i <= m; i++) {
            for (int j = 0; j <= n; j++) {
                if (i >= cnt[0][0] && j >= cnt[0][1]) dp[0][i][j] = 1;
            }
        }
        // 处理考虑其余物品的情况
        for (int k = 1; k < len; k++) {
            int zero = cnt[k][0], one = cnt[k][1];
            for (int i = 0; i <= m; i++) {
                for (int j = 0; j <= n; j++) {
                    if (i >= zero && j >= one) {
                        // 选择第 k 件物品（前提是有足够的 m 和 n 额度可使用）
                        dp[k][i][j] = max(dp[k-1][i][j], dp[k-1][i-zero][j-one] + 1);
                    } else {
                        // 不选择第 k 件物品
                        dp[k][i][j] = dp[k-1][i][j];
                    }
                }
            }
        }
        return dp[len - 1][m][n];
    }
};
```

进行优化：

```C++
        vector<vector<int>> dp(m + 1, vector<int>(n + 1));
        for (int k = 0; k < len; k++) {
            int zero = cnt[k][0], one = cnt[k][1];
            for (int i = m; i >= zero; i--) {
                for (int j = n; j >= one; j--) {
                    dp[i][j] = max(dp[i][j], dp[i-zero][j-one] + 1);
                }
            }
        }
        return dp[m][n];
```



#### [518. 零钱兑换 II](https://leetcode.cn/problems/coin-change-2/)：完全背包

被选物品之间不需要满足特定关系，只需要选择物品，以达到「全局最优」或者「特定状态」即可。

同时硬币相当于我们的物品，每种硬币可以选择「无限次」，**很自然的想到「完全背包」。**

定义f[i][j]为考虑前i件物品，凑成总和为j的方案数量。

为了方便初始化，我们一般让f[0][x] 代表不考虑任何物品的情况。因此我们有显而易见的初始化条件f[0][0]=1，其余f[0][x]=0。代表当没有任何硬币的时候，存在凑成总和为 0 的方案数量为1；凑成其他总和的方案不存在。

当「状态定义」与「基本初始化」有了之后，我们不失一般性的考虑f[i][j]该如何转移。

对于第 ii 个硬币我们有两种决策方案：

- 不使用该硬币：f[i - 1][j]
- 使用该硬币：由于每个硬币可以被选择多次（容量允许的情况下），因此方案数量应当是选择「任意个」该硬币的方案总和：$$sum_{k = 1}^{\left \lfloor {j / val} \right \rfloor}f[i - 1][j - k * val], val = nums[i - 1] $$

> 对于dp数组，也可以使用n*(amount+1)，但是对于第一行的数据初始化的时候会稍微麻烦，不如直接(n+1)*(amount+1)

```C++
class Solution {
public:
    int change(int amount, vector<int>& coins) {
        int n = coins.size();
        // dp[i][j]：考虑前i件物品，凑成总和为j的方案数量
        vector<vector<int>> dp(n + 1, vector<int>(amount + 1));
        dp[0][0] = 1;
        for (int i = 1; i <= n; i++) {
            int val = coins[i - 1];
            for (int j = 0; j <= amount; j++) {
                dp[i][j] = dp[i - 1][j];
                for (int k = 1; k * val <= j; k++) {
                    dp[i][j] += dp[i - 1][j - k * val];
                }
            }
        }
        return dp[n][amount];
    }
};
class Solution {
public:
    int change(int amount, vector<int>& coins) {
        int n = coins.size();
        vector<int> dp(amount + 1);
        dp[0] = 1;
        for (int i = 1; i <= n; i++) {
            int val = coins[i - 1];
            for (int j = val; j <= amount; j++) {
                dp[j] += dp[j - val];
            }
        }
        return dp[amount];
    }
};
```



#### [377. 组合总和 Ⅳ](https://leetcode.cn/problems/combination-sum-iv/)：完全背包 考虑顺序+溢出

本题与「完全背包求方案数」问题的差别在于：**选择方案中的不同的物品顺序代表不同方案。**

因此我们不能直接代入「完全背包」的思路（状态定义）来求解。

这时候可以从**「构成答案的组合」**入手：利用 1 <= nums[i] <= 1000 和 1 <= target <= 1000 条件可以确定，组合长度必然在[1,1000]。

定义：f[i][j]为**组合长度为i**，**凑成总和为j的方案数**是多少。

由于对组合方案的长度没有限制，因此我们**最终答案为所有的f[x][target]的总和**。

同时有显而易见的初始条件（有效值）f[0][0]=1。

那么对任意的f[len][target] 而言，组合中的最后一个数字可以选择nums中的任意数值，因此f[len][target]应该为以下所有方案总和：

- **最后一个数选择 nums[0]，方案数为f [len−1] [target−nums[0]]**
- **最后一个数选择 nums[1]，方案数为f [len−1] [target−nums[1]]**
- **最后一个数选择 nums[2]，方案数为f [len−1] [target−nums[2]]**
- **...**

```C++
class Solution {
public:
    // 因为 nums[i] 最小值为 1，因此构成答案的最大长度为 target
    int combinationSum4(vector<int>& nums, int target) {
        int len = target;
        // dp[i][j]：组合长度为i，最后一个元素为num，凑成总和为j的方案数
        vector<vector<int>> dp(len + 1,vector<int>(target + 1));
        dp[0][0] = 1;
        int ans = 0;
        for (int i = 1; i <= len; i++) {
            for (int j = 0; j <= target; j++) {
                for (int num : nums) {
                    if (j >= num) dp[i][j] += dp[i - 1][j - num];
                }
            }
            ans += dp[i][target];
        }
        return ans;
    }
};

其中，力扣会有dp数组的溢出，处理方法是：
vector<vector<unsigned long long>> dp(len + 1,vector<unsigned long long>(target + 1));
```

**一维优化**

我们知道**「完全背包」可以通过取消物品维度来实现降维优化**。

本题也可以使用相同手段：**定义** ***f*****[*****i*****] 为凑成总和为** ***i*** **的方案数是多少。**

由于每个数值可以被选择无限次，因此在计算任意总和时，我们保证 nums 中的每一位都会被考虑到即可（即确保对组合总和 target 的遍历在外，对数组 nums 的遍历在内）。

> 这一个题其实是**排列**，这个题和其他的不太一样！！外层for背包

> 换句话说，每次考虑一个背包容量，都要结合nums中的所有物品

```C++
class Solution {
public:
    // 因为 nums[i] 最小值为 1，因此构成答案的最大长度为 target
    int combinationSum4(vector<int>& nums, int target) {
        int len = target;
        vector<unsigned long long> dp(target + 1);
        dp[0] = 1;
        for (int j = 1; j <= target; j++) {
            for (int num : nums) {
                if (j >= num) dp[j] += dp[j - num];
            }
        }
        return dp[target];
    }
};
```



**补充关于溢出说明**

首先 Java 不需要考虑溢出，CPP 需要考虑溢出，绝不是因为测试数据不同，而是两者对于「溢出」处理不同导致。

由于题目最终答案是 int，因此 Java 不需要用额外操作。

当 Java 发生溢出时，会直接当成负数来处理。这就导致了只要答案最终是 int，所有的溢出会被补偿回来：

```Go
{
    System.out.println(Integer.MIN_VALUE); // -2147483648
    
    int a = Integer.MAX_VALUE;
    System.out.println(a); // 2147483647
    a += 1;
    System.out.println(a); // -2147483648
    a -= 1;
    System.out.println(a); //2147483647
}
```

这意味着，如果我们在运算过程中如果只涉及「纯加减运算」，而不涉及「乘除」、「取最大值/最小值」和「数值大小判断」的话，Java 是不需要使用 Long 来确保正确性的，因为最终溢出会被转化回来。

按道理，CPP 本身对于 int 溢出的转化处理也是一样的。

但在 LC 上的 CPP 发生溢出时，不会直接当做负数来处理，而是直接抛出异常。因此同样的代码在 LC 上是无法被正常执行的：

```C++
{
    cout << INT_MIN << endl; //-2147483648

    int a = INT_MAX; 
    cout << a << endl; // 2147483647
    a += 1; // 溢出报错
    cout << a << endl;
    a -= 1;
    cout << a << endl;
}
```

这是一般性的，对于 LC 上的同一道题，Java 不需要处理溢出，CPP 需要处理的原因。

但本题还有另外一个原因：由于状态值是被累加的，最终答案又是 int，所以其实那些溢出值是不会被用到的（不会与我们的目标状态值相关），CPP 使用 ULL 其实只是单纯为了解决溢出报错罢了。



#### [322. 零钱兑换](https://leetcode.cn/problems/coin-change/)：完全背包 无序、最小个数

定义**f[i][j]为考虑前 i 件物品，凑成总和为 j 所需要的最少硬币数量**。

为了方便初始化，我们一般让f[0][x]代表不考虑任何物品的情况。

因此我们有显而易见的初始化条件f[0][0]=0，其余f[0][x] = INF。

代表当没有任何硬币的时候，存在凑成总和为 0 的方案，方案所使用的硬币为 0；凑成其他总和的方案不存在。由于我们要求的是「最少」硬币数量，因此我们不希望「无效值」参与转移，因此可设INF=INT_MAX。

当「状态定义」与「基本初始化」有了之后，我们不失一般性的考虑 f[i][j]f[i][j] 该如何转移。

对于第i个硬币我们有两种决策方案：

- 不使用该硬币：f[i - 1][j]
- 使用该硬币，由于每个硬币可以被选择多次（容量允许的情况下），因此最优解应当是所有方案中的最小值：min(f[i-1][j-k*coin] + k)

> 朴素的完全背包有超时的风险

```C++
class Solution {
public:
    int coinChange(vector<int>& coins, int amount) {
        int n = coins.size();
        vector<vector<int>> dp(n + 1, vector<int>(amount + 1));
        for (int j = 1; j <= amount; j++) {
            dp[0][j] = INT_MAX;
        }
        for (int i = 1; i <= n; i++) {
            int val = coins[i - 1];
            for (int j = 0; j <= amount; j++) {
                dp[i][j] = dp[i - 1][j];
                for (int k = 1; k * val <= j; k++) {
                    if (dp[i - 1][j - k * val] != INT_MAX) {
                        dp[i][j] = min(dp[i][j], dp[i - 1][j - k * val] + k);
                    }
                }
            }
        }
        return dp[n][amount] == INT_MAX ? -1 : dp[n][amount];
    }
};
居然会超时？？
```

**一维dp优化：**

> 组合数，外层for物品

```C++
class Solution {
public:
    int coinChange(vector<int>& coins, int amount) {
        int n = coins.size();
        vector<unsigned long long> dp(amount + 1, INT_MAX);
        dp[0] = 0;
        for (int i = 0; i < n; i++) {
            // 对前i个硬币进行考虑
            for (int j = coins[i]; j <= amount; j++) {
                dp[j] = min(dp[j], dp[j-coins[i]] + 1);         
            }
        }
        return dp[amount] == INT_MAX ? -1 : dp[amount];
    }
};
```



#### [279. 完全平方数](https://leetcode.cn/problems/perfect-squares/)：完全背包 最小个数

凑平方数和凑零钱是一个道理，物品是无限使用的平方数！

目前我们学过的两类背包问题（01 背包 & 完全背包）的原始状态定义都是两维：第一维 i 代表物品编号，第二维 j 代表容量。

其中第二维 j 又有「不超过容量 j」和「容量恰好为 j」两种定义，本题要我们求「恰好」凑出 n 所需要的最少个数。



因此我们可以调整我们的「状态定义」：**f[i][j] 为考虑前 i 个数字，凑出数字总和 j 所需要用到的最少数字数量。**

不失一般性的分析 f[i][j]，对于第 i 个数字（假设数值为 t），我们有如下选择：

- 选 0 个数字 i，此时有 f[i][j]=f[i−1][j]
- 选 1 个数字 i，此时有 f[i][j]=f[i−1][j−t]+1
- 选 k 个数字 i，此时有 f[i][j]=f[i−1][j−k∗t]+k

因此我们的状态转移方程为：`f[i][j]=min(f[i−1][j−k∗t] + k)，0⩽k∗t⩽j`

当然，能够选择 k 个数字 i 的前提是，剩余的数字 j−k∗t 也能够被其他「完全平方数」凑出，即f[i−1][j−k∗t] 为有意义的值。

**朴素的完全背包：**（让物品下标从 0 开始，单独处理第一个物品的代码，但是还是超时了。。）

```C++
class Solution {
public:
    int numSquares(int n) {
        // 预处理所有可能的平方数
        vector<int> square;
        for (int i = 1; i * i <= n; i++) square.push_back(i * i);
        int len = square.size();
        // dp[i][j]：考虑前i个物品，凑出j所使用到的最小元素个数
        vector<vector<int>> dp(len, vector<int>(n + 1));
        
        // 处理第一个数的情况
        for (int j = 0; j <= n; j++) {
            int k = j / square[0];
            if (k * square[0] == j) dp[0][j] = k;   // 只有容量为第一个数的整数倍的才能凑出
            else dp[0][j] = -1;     // 作为无效值
        }
        // 处理剩余数的情况
        for (int i = 1; i < len; i++) {
            int t = square[i];
            for (int j = 0; j <= n; j++) {
                // 对于不选第i个数的情况
                dp[i][j] = dp[i - 1][j];
                // 对于选k次第i个数的情况
                for (int k = 1; k * t <= j; k++) {
                    if (dp[i-1][j-k*t] != -1) {
                        dp[i][j] = min(dp[i][j], dp[i-1][j-k*t] + k);
                    }
                }
            }
        }
        return dp[len - 1][n];
    }
};
```

**完全背包优化为一维dp数组：**

> [【宫水三叶】详解完全背包一维空间优化推导（附背包问题攻略） - 完全平方数](https://leetcode.cn/problems/perfect-squares/solution/gong-shui-san-xie-xiang-jie-wan-quan-bei-nqes/)

1. 确定dp数组（dp table）以及下标的含义：**dp[j]：和为j的完全平方数的最少数量为dp[j]**
2. 确定递推公式

dp[j] 可以由dp[j - i * i]推出， dp[j - i * i] + 1 便可以凑成dp[j]。此时我们要选择最小的dp[j]，

所以递推公式：dp[j] = min(dp[j - i * i] + 1, dp[j]);

1. dp数组如何初始化

dp[0]表示 和为0的完全平方数的最小数量，那么dp[0]一定是0。

非0下标的dp[j]应该是多少呢？从递归公式dp[j] = min(dp[j - i * i] + 1, dp[j]);中可以看出每次dp[j]都要选最小的，**所以非0下标的dp[j]一定要初始为最大值，这样dp[j]在递推的时候才不会被初始值覆盖**。

1. 确定遍历顺序

**求组合数，就是外层for遍历物品，内层for遍历背包。（无序：最少有多少个）**

**求排列数，就是外层for遍历背包，内层for遍历物品。（有序：最多多少种方案）**

- > 本题外for背包内for物品，还是外for物品内for背包，都是可以的！

- > 其实本题如果是先for背包会更好理解？

```C++
class Solution {
public:
    int numSquares(int n) {
        // dp[j]：凑出和为j的最少个数
        vector<int> dp(n + 1, INT_MAX);
        dp[0] = 0;
        for (int i = 1; i * i <= n; i++) {
            int t = i * i;
            for (int j = t; j <= n; j++) {
                dp[j] = min(dp[j], dp[j - t] + 1);
            }
        }
        return dp[n];
    }
};
```



#### [139. 单词拆分](https://leetcode.cn/problems/word-break/)：完全背包 拼出字符串是背包

**如果直接使用dfs**，会超出时间限制。不过也是一个思路，大部分都可以过？这个方法需要剪枝优化。

```C++
class Solution {
public:
    bool dfs(string s, vector<string>& wordDict, int idx) {
        // 如果能一路走到叶节点，说明找到这样的拆分方法了
        if (idx == s.size()) return true;
        // 否则从idx开始拆分s
        for (auto word : wordDict) {
            int n = word.size();
            if (s.substr(idx, n) == word) {
                // 不能直接 return dfs(s, wordDict, idx + n);
                if (dfs(s, wordDict, idx + n)) return true;
                else continue;
            }
        }
        return false;
    }
    bool wordBreak(string s, vector<string>& wordDict) {
        return dfs(s, wordDict, 0);
    }
};
```

**完全背包？**

单词就是物品，字符串s就是背包，单词能否组成字符串s，就是问物品能不能把背包装满。

拆分时可以重复使用字典中的单词，说明就是一个完全背包！

1. 确定dp数组以及下标的含义

**dp[i] : 字符串长度为i的话，dp[i]为true，表示可以拆分为一个或多个在字典中出现的单词**。

1. 确定递推公式：如果确定dp[j] 是true，且 [j, i] 这个区间的子串出现在字典里，那么dp[i]一定是true
2. dp数组如何初始化
3. 确定遍历顺序

本题最终要求的是是否都出现过，所以对出现单词集合里的元素是组合还是排列，并不在意！

那么本题使用求排列的方式，还是求组合的方式都可以。

但本题还有特殊性，因为是要求子串，最好是遍历背包放在外循环，将遍历物品放在内循环。

如果要是外层for物品dict内层for背包s，就需要把所有的子串都预先放在一个容器里。

所以选择的遍历顺序为：遍历背包放在外循环，将遍历物品放在内循环，内循环从前到后。

```C++
class Solution {
public:
    bool wordBreak(string s, vector<string>& wordDict) {
        unordered_set<string> words(wordDict.begin(), wordDict.end());
        int n = s.size();
        // dp[i]：背包s前i可以由词典中单词组成则为true
        vector<bool> dp(n + 1, false);
        dp[0] = true;
        for (int i = 1; i <= n; i++) {
            for (int j = 0; j < i; j++) {
                string word = s.substr(j, i - j);
                if (words.find(word) != words.end() && dp[j]) {
                    dp[i] = true;
                }
            }
        }
        return dp[n];
    }
};
```



#### [198. 打家劫舍](https://leetcode.cn/problems/house-robber/)：经典dp 怎样隔着和最大

1. 确定dp数组（dp table）以及下标的含义

**dp[i]：考虑下标i（包括i）以内的房屋，最多可以偷窃的金额为dp[i]**。

1. 确定递推公式：决定dp[i]的因素就是第i房间偷还是不偷。

- 如果偷第i房间，那么dp[i] = dp[i - 2] + nums[i]（第i-1房不能选上）
- 如果不偷第i房间，那么dp[i] = dp[i - 1]，即考虑i-1房

然后dp[i]取最大值，即dp[i] = max(dp[i - 2] + nums[i], dp[i - 1]);

1. dp数组如何**初始化**

从递推公式看出，**递推公式的基础就是dp[0] 和 dp[1]**

从dp[i]的定义上来讲，dp[0] 一定是 nums[0]，dp[1]就是nums[0]和nums[1]的最大值即：dp[1] = max(nums[0], nums[1]);

```C++
vector<int> dp(nums.size());
dp[0] = nums[0];
dp[1] = max(nums[0], nums[1]);
```

1. 确定遍历顺序

dp[i] 是根据dp[i - 2] 和 dp[i - 1] 推导出来的，那么一定是从前到后遍历！

```C++
for (int i = 2; i < nums.size(); i++) {
    dp[i] = max(dp[i - 2] + nums[i], dp[i - 1]);
}
```

一维dp的代码：

```C++
class Solution {
public:
    int rob(vector<int>& nums) {
        int n = nums.size();
        if (n == 1) return nums[0];
        // dp[i]：到i间房屋，物品累计最大价值
        // dp[i] = max(dp[i-2]+nums[i], dp[i-1])
        vector<int> dp(n);
        dp[0] = nums[0], dp[1] = max(nums[0], nums[1]);
        for (int i = 2; i < n; i++) {
            dp[i] = max(dp[i-2]+nums[i], dp[i-1]);
        }
        return dp[n - 1];
    }
};
```



#### [213. 打家劫舍 II](https://leetcode.cn/problems/house-robber-ii/)：物品成环了

**【三叶の题解】*****f*****[*****i*****][*****j*****] 代表考虑前** ***i*** **个房间，当前** ***i*** **房间的现在状态为** ***j*** **的最大价值。**

比起上一题，本题增加了**第一个物品和最后一个物品不能同时选择**的条件

**通常，对于一些明显不是「增加维度」的新限制条件，我们应当考虑直接将其拎出讨论，而不是多增加一维进行状态记录。**

我们可以把「第一间」&「最后一间」单独拎出来讨论：

- 明确「不选」第一间：
  - 初始化f[0][0]和f[0][1]，均为0。
  - 先从「第二间」开始递推到「倒数第二间」的最大价值。
  - 再处理「最后一间」的情况：由于明确了「不选第一间」，则最后的最大价值为max(f[n−2][1],f[n−2][0]+nums[n−1])。
- 允许「选」第一间：
  - 初始化f[0][0]和f[0][1]，分别为0和nums[0]。
  - 先从「第二间」开始递推到「倒数第二间」的最大价值。
  - 再处理「最后一间」的情况：由于明确了「选第一间」，则最后的最大价值为max(f[n−2][0],f[n−2][1])。

走完两遍 DP 后，再从两种情况的最大价值中再取一个max即是答案。

- > 其实是分成三类情况：选首不选尾，不选首选尾，首尾都不选；

- > 上述思路其实把这三类情况都包含了！

```C++
class Solution {
public:
    int rob(vector<int>& nums) {
        int n = nums.size();
        if (n == 1) return nums[0];
        if (n == 2) return max(nums[0], nums[1]);
        
        vector<int> dp(n, 0);       
        // 明确不选第一间
        dp[0] = 0, dp[1] = nums[1], dp[2] = max(nums[1], nums[2]);
        for (int i = 3; i < n; i++) {
            dp[i] = max(dp[i-2]+nums[i], dp[i-1]);
        }
        int a = dp[n - 1];
        // 明确选第一间
        dp[0] = nums[0], dp[1] = max(nums[0], nums[1]);
        for (int i = 2; i < n - 1; i++) {
            dp[i] = max(dp[i-2]+nums[i], dp[i-1]);
        }
        int b = dp[n - 2];
        return max(a, b);
    }
};
```



#### [337. 打家劫舍 III](https://leetcode.cn/problems/house-robber-iii/)：记忆化搜索 or 树形背包？

本题变成二叉树形式进行遍历

如果暴力搜索，会超时：

```C++
class Solution {
public:
    int rob(TreeNode* root) {
        if (root == NULL) return 0;
        if (root->left == NULL && root->right == NULL) return root->val;
        // 偷父节点
        int val1 = root->val;
        if (root->left) val1 += rob(root->left->left) + rob(root->left->right); // 跳过root->left，相当于不考虑左孩子了
        if (root->right) val1 += rob(root->right->left) + rob(root->right->right); // 跳过root->right，相当于不考虑右孩子了
        // 不偷父节点
        int val2 = rob(root->left) + rob(root->right); // 考虑root的左右孩子
        return max(val1, val2);
    }
};
```

所谓**记忆化搜索**，就是用map把刚刚搜索过的内容记录下来

```C++
/**
 * Definition for a binary tree node.
 * struct TreeNode {
 *     int val;
 *     TreeNode *left;
 *     TreeNode *right;
 *     TreeNode() : val(0), left(nullptr), right(nullptr) {}
 *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}
 *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}
 * };
 */
class Solution {
public:
    unordered_map<TreeNode*, int> umap;     // 记录已经计算出的结果
    int dfs(TreeNode* root) {
        if (root == NULL) return 0;
        if (root->left == NULL && root->right == NULL) return root->val;
        if (umap[root] != 0) return umap[root];

        // 如果添加父节点，则跳过两个子节点
        int a = root->val;
        if (root->left != NULL) {
            a += dfs(root->left->left) + dfs(root->left->right);
        }
        if (root->right != NULL) {
            a += dfs(root->right->left) + dfs(root->right->right);
        }
        // 如果跳过父节点，直接添加两个子节点
        int b = dfs(root->left) + dfs(root->right);
        
        umap[root] = max(a, b);
        return max(a, b);
    }
    int rob(TreeNode* root) {
        return dfs(root);
    }
};
```



#### [121. 买卖股票的最佳时机](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/)：遍历 or 动规

> 本题意图：一次买卖，获得最大利润是多少

**法1：直接一次遍历**

```C++
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        int minprice = INT_MAX;
        int ans = 0;
        for (auto p : prices) {
            ans = max(ans, p - minprice);
            minprice = min(minprice, p);
        }
        return ans;
    }
};
```

**法2：动态规划**

一维动态规划思想。dp[i]表示前i天的最大利润

因为我们始终要使利润最大化，则：dp[i] = max(dp[i-1], prices[i]-minprice)



另一种（为了提前适应后续买卖股票问题的思路）：

1. 确定dp数组（dp table）以及下标的含义

dp[i][0] 表示第i天持有股票所得最多现金 ，**这里可能有同学疑惑，本题中只能买卖一次，持有股票之后哪还有现金呢？**其实一开始现金是0，那么加入第i天买入股票现金就是 -prices[i]， 这是一个负数。

dp[i][1] 表示第i天不持有股票所得最多现金

**注意这里说的是“持有”，“持有”不代表就是当天“买入”！也有可能是昨天就买入了，今天保持持有的状态**

1. 确定递推公式：

如果第i天持有股票即dp[i][0]， 那么可以由两个状态推出来：

- 第i-1天就持有股票，那么就保持现状，所得现金就是昨天持有股票的所得现金 即：dp[i - 1][0]
- 第i天买入股票，所得现金就是买入今天的股票后所得现金即：-prices[i]

那么dp[i][0]应该选所得现金最大的，所以dp[i][0] = max(dp[i - 1][0], -prices[i]);

如果第i天不持有股票即dp[i][1]， 也可以由两个状态推出来：

- 第i-1天就不持有股票，那么就保持现状，所得现金就是昨天不持有股票的所得现金 即：dp[i - 1][1]
- 第i天卖出股票，所得现金就是按照今天股票佳价格卖出后所得现金即：prices[i] + dp[i - 1][0]

同样dp[i][1]取最大的，dp[i][1] = max(dp[i - 1][1], prices[i] + dp[i - 1][0]);

1. dp数组如何初始化：由递推公式可以看出其基础都是要从dp[0][0]和dp[0][1]推导出来。
2. 确定遍历顺序：从递推公式可以看出dp[i]都是有dp[i - 1]推导出来的，那么一定是从前向后遍历。

> 输出的结果应该是最后一天不持有股票手中的现金

```C++
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        int len = prices.size();
        if (len == 0) return 0;
        vector<vector<int>> dp(len, vector<int>(2));
        dp[0][0] -= prices[0];
        dp[0][1] = 0;
        for (int i = 1; i < len; i++) {
            dp[i][0] = max(dp[i - 1][0], -prices[i]);
            dp[i][1] = max(dp[i - 1][1], prices[i] + dp[i - 1][0]);
        }
        return dp[len - 1][1];
    }
};
```



#### [122. 买卖股票的最佳时机 II](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/)：动规 or 贪心

> 本题意图：多次买卖，争取获得最大利润

> 另外，本题要求只持有一股，今天要买必须先卖了昨天的

**法1：本题的特殊做法是贪心**

```C++
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        int n = prices.size();
        int ans = 0;
        for (int i = 1; i < n; i++) {
            int profit = prices[i] - prices[i-1];
            if (profit > 0) ans += profit;
        }
        return ans;
    }
};
```

**法2：动规**

这里重申一下dp数组的含义：

- dp[i][0] 表示第i天持有股票所得现金。
- dp[i][1] 表示第i天不持有股票所得最多现金

递推公式和上一题不太相同，其他一致

```C++
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        int n = prices.size();
        // dp[i][0]：今日买，截至今日累计利润；dp[i][1]：今日不买，截至今日累计利润
        vector<vector<int>> dp(n, vector<int>(2));
        dp[0][0] = -prices[0], dp[0][1] = 0;
        for (int i = 1; i < n; i++) {
            dp[i][0] = max(dp[i-1][0], dp[i-1][1] - prices[i]);
            dp[i][1] = max(dp[i-1][1], dp[i-1][0] + prices[i]);
        }
        return dp[n-1][1];
    }
};
```



#### [123. 买卖股票的最佳时机 III](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iii/)：只好动规了

> 本题是总共允许两次买卖，每个物品的状态数变多了

> 规则： 注意你不能在第 1 天和第 2 天接连购买股票，之后再将它们卖出。因为这样属于同时参与了多笔交易，你必须在再次购买前出售掉之前的股票。

1. 确定dp数组以及下标的含义

一天共有5个状态，0没有操作、1第一次买入、2第一次卖出、3第二次买入、4第二次卖出

dp[i][j]中，i表示第i天，j为 [0 - 4] 五个状态，dp[i][j]表示在状态j下，截至第i天所剩利润。

1. 确定递推公式

达到dp[i][1]状态，有两个具体操作：

- 操作一：第i天买入股票了，那么dp[i][1] = dp[i-1][0] - prices[i]
- 操作二：第i天没有操作，而是沿用前一天买入的状态，即：dp[i][1] = dp[i - 1][1]

那么dp[i][1]究竟选 dp[i-1][0] - prices[i]，还是dp[i - 1][1]呢？一定是选最大的，

所以 `dp[i][1] = max(dp[i-1][0] - prices[i], dp[i - 1][1]);`

同理dp[i][2]也有两个操作：

- 操作一：第i天卖出股票了，那么dp[i][2] = dp[i - 1][1] + prices[i]
- 操作二：第i天没有操作，沿用前一天卖出股票的状态，即：dp[i][2] = dp[i - 1][2]

所以 `dp[i][2] = max(dp[i - 1][1] + prices[i], dp[i - 1][2])`

同理可推出剩下状态部分：

```
dp[i][3] = max(dp[i - 1][3], dp[i - 1][2] - prices[i]);
dp[i][4] = max(dp[i - 1][4], dp[i - 1][3] + prices[i]);
```

1. dp数组如何初始化
2. 确定遍历顺序：一定是从前向后遍历，因为dp[i]，依靠dp[i - 1]的数值。

```C++
class Solution {
public:
    int maxProfit(vector<int>& prices) {
        int n = prices.size();
        // dp[i][j]：表示在状态j下，截至第i天所剩利润
        // j是不断继承的状态：0没有操作、1第一次买入、2第一次卖出、3第二次买入、4第二次卖出
        vector<vector<int>> dp(n, vector<int>(5, 0));
        dp[0][1] = -prices[0], dp[0][3] = -prices[0];
        for (int i = 1; i < n; i++) {
            dp[i][0] = dp[i-1][0];
            dp[i][1] = max(dp[i-1][1], dp[i-1][0] - prices[i]);
            dp[i][2] = max(dp[i-1][2], dp[i-1][1] + prices[i]);
            dp[i][3] = max(dp[i-1][3], dp[i-1][2] - prices[i]);
            dp[i][4] = max(dp[i-1][4], dp[i-1][3] + prices[i]);
        }
        return dp[n-1][4];
    }
};
```





















#### [646. 最长数对链](https://leetcode.cn/problems/maximum-length-of-pair-chain/)：动态规划 or 贪心dp

**法1：直接动态规划**

定义：**dp[i] 为以 pairs[i] 为结尾的最长数对链的长度**。

计算 dp[i] 时，可以先找出所有的满足`pairs[i][0]>pairs[j][1]`的 j，并求出最大的 dp[j]，dp[i] 的值即可赋为这个最大值+1

```C++
class Solution {
public:
    int findLongestChain(vector<vector<int>>& pairs) {
        int n = pairs.size();
        sort(pairs.begin(), pairs.end());
        vector<int> dp(n, 1);
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < i; j++) {
                if (pairs[j][1] < pairs[i][0]) {
                    dp[i] = max(dp[i], dp[j] + 1);
                }
            }
        }
        return dp[n - 1];
    }
};
```

**法2：贪心**

**要挑选最长数对链的第一个数对时，最优的选择是****挑选第二个数字最小的**，这样能给挑选后续的数对留下更多的空间。挑完第一个数对后，要挑第二个数对时，也是按照相同的思路，是在剩下的数对中，第一个数字满足题意的条件下，挑选第二个数字最小的。

按照这样的思路，**可以先将输入按照第二个数字排序**，然后不停地判断第一个数字是否能满足大于前一个数对的第二个数字即可。

```C++
class Solution {
public:
    static bool cmp(vector<int> a, vector<int> b) {
        return a[1] < b[1];     // 按照第二个数升序排列
    }
    int findLongestChain(vector<vector<int>>& pairs) {
        int last = INT_MIN;
        int ans = 0;
        sort(pairs.begin(), pairs.end(), cmp);
        for (auto &p : pairs) {
            if (last < p[0]) {
                last = p[1];
                ans++;
            }
        }
        return ans;
    }
};
```











## [(1)记忆化搜索](https://github.com/SharingSource/LogicStack-LeetCode/wiki/记忆化搜索)

## [(2)线性 DP](https://github.com/SharingSource/LogicStack-LeetCode/wiki/线性-DP)

无法复制加载中的内容

#### [467. 环绕字符串中唯一的子字符串](https://leetcode.cn/problems/unique-substrings-in-wraparound-string/)：DP or 前缀和

- 无限环绕字符串s任意两个相邻字符都满足字典序上的相邻，`s[i] == (s[i-1] + 1) % 26`
- 这意味着所以p中的子串如果是s的子串，也必须同样满足这个性质

**我们可以定义** ***dp*****[*****α*****] 表示** ***p*** **中以字符** ***α*** **结尾且在** ***s*** **中的子串的最长长度**

![img](https://uestc.feishu.cn/space/api/box/stream/download/asynccode/?code=Mzk0NDA4MzNjYTA3ZmE4YTgzNDNjNGVmM2M5NzBmNWVfQ0VJdFh0RW90Q3lPR1ZaVXhsVHo5WmZTajdZWkVFTkJfVG9rZW46Ym94Y254MHU4d3dMbjdzNHdTUE0xdlRBSzVjXzE2NjI2NDE5MTI6MTY2MjY0NTUxMl9WNA)

```C++
    int findSubstringInWraproundString(string p) {
        int n = p.size();
        int k = 0;
        vector<int> dp(26);
        for (int i = 0; i < n; i++) {
            if (i > 0 && (p[i] - p[i - 1] + 26) % 26 == 1) k++;
            else k = 1;
            dp[p[i] - 'a'] = max(k, dp[p[i] - 'a']);  // 不能重复算上子串 
        }
        return accumulate(dp.begin(), dp.end(), 0);
    }
```



#### [688. 骑士在棋盘上的概率](https://leetcode-cn.com/problems/knight-probability-in-chessboard/)：概率一定是连续递推

首先是动规DP的思想

此外，要注意移动方向dx、dy两种写法

**【三叶】の题解：**

![img](https://uestc.feishu.cn/space/api/box/stream/download/asynccode/?code=YzZmY2IyMDAyZmU3ZmNmNWVkNGM0ODlhNGRiNWFlZDNfdUc5NWpUMEgzcnVmWThWRzNuOEZYNnM2Z0JZWGpYeGpfVG9rZW46Ym94Y25xYVpvM3Y1cVpoamp3eHVrbGJNSDVnXzE2NjI2NDE5MTI6MTY2MjY0NTUxMl9WNA)

```
**dp[i][j][p] => 从位置(i, j)出发，走不超过p步后仍在棋盘内的概率**
class Solution {
public:
    // 移动k步过程中离开棋盘就不算了。。
    // dp[i][j][p] => 从位置(i, j)出发，走不超过p步后仍在棋盘内的概率
    double knightProbability(int n, int k, int row, int column) {
        int dirs[8][2] = {{-1,-2},{-1,2},{1,-2},{1,2},{-2,1},{-2,-1},{2,1},{2,-1}};
        // double dp[n][n][k+1]; 没有初始化❌
        // double dp[n][n][k+1] = {0}; 这种初始化是错误的写法❌
        vector<vector<vector<double>>> dp(n, vector<vector<double>>(n, vector<double>(k+1)));  // 才是可以的
        (k + 1, vector<vector<double>>(n, vector<double>(n)));
        for (int i = 0; i < n; ++i)
            for (int j = 0; j < n; ++j)
                dp[i][j][0] = 1;
        for (int p = 1; p <= k; ++p) {
            for (int i = 0; i < n; ++i) {
                for (int j = 0; j < n; ++j) {
                    for (auto d : dirs) {
                        int nx = i + d[0], ny = j + d[1];
                        if (nx < 0 || nx >= n || ny < 0 || ny >= n) continue;
                        dp[i][j][p] += dp[nx][ny][p-1] / 8;
                    }
                }
            }
        }
        return dp[row][column][k];
    }
};
```

注意关于**数组的初始化**！

- `double dp[n][n][k+1];` 没有初始化❌
- `double dp[n][n][k+1] = {0};` 这种初始化是错误的写法❌
- 只有`**vector**``<vector<vector<double>>> dp(n, vector<vector<double>>(n, vector<double>(k+1))); `  才是正确的写法，**不用单独进行初始化**！

```Python
class Solution:
    def knightProbability(self, n: int, k: int, row: int, column: int) -> float:
        dp = [[[0] * (k+1) for _ in range(n)] for _ in range(n)]
        for i in range(n):
            for j in range(n):
                dp[i][j][0] = 1
        for p in range(1, k+1):
            for i in range(n):
                for j in range(n):
                    for dx, dy in ((-2, -1), (-2, 1), (2, -1), (2, 1), (-1, -2), (-1, 2), (1, -2), (1, 2)):
                        nx, ny = i + dx, j + dy
                        if nx < 0 or nx >= n or ny < 0 or ny >= n: continue
                        dp[i][j][p] += dp[nx][ny][p-1] / 8
        return dp[row][column][k]
```

> **Python 解法要注意：for循环的层次不要写错！！**



#### [926. 将字符串翻转到单调递增](https://leetcode.cn/problems/flip-string-to-monotone-increasing/)：前缀和？线性遍历

**思路1：前缀和**

我们发现，如果一个字符串单调递增，那么该字符串一定可以分为两部分，前一部分全为字符 0，后一部分全为字符 1。

那么，我们可以遍历所有的 n 个位置，分别作为目标字符串 0 与 1 的分界线。这样，我们只需要对于每个位置，计算将 s 转化为目标字符串的翻转次数。并取所有可能的最小值即可。

算法细节：我们假设位置 i 为当前字符 0 与 1 的分界线，也即 [0, i−1] 位置均为字符 0，[i+1, n]位置均为 1，而位置 i 是 0 还是 1 均可。

所以我们需要将 [0, i−1] 区间内的所有字符 1 进行翻转，也即我们需要提前维护一个前缀和数组，记录 [0, i−1] 区间内字符 1 的个数。同理，我们也需要一个数组，记录[i+1, n-1] 区间内字符 0 的个数。

```C++
class Solution {
public:
    int minFlipsMonoIncr(string s) {
        int n = s.size();
        vector<int> cnt_0(n + 1), cnt_1(n + 1);
        for (int i = 0; i < n; i++) {
            // [0, i-1] 的 1 数量
            cnt_1[i + 1] = cnt_1[i] + (s[i] == '1');  // cnt_1[1:n]
        }
        for (int i = n; i > 0; i--) {
            // [i, n-1] 的 0 的数量
            cnt_0[i - 1] = cnt_0[i] + (s[i - 1] == '0');  // cnt_0[0:n-1]
        }
        int ans = n;
        for (int i = 0; i < n; i++) {  // i 位置为分界线，该位置是 0 或 1 无所谓
            // [0, i-1]的所有1翻转为0， [i+1, n-1]的所有0翻转为1
            // [0, i-1]的1在cnt_1[i-1]，[i+1, n-1]的0在cnt_0[i+1]，注意下标换一下⭐
            int cur = cnt_1[i] + cnt_0[i + 1];
            ans = min(ans, cur);
        }
        return ans;
    }
};
```

思路2：传统一点的递推

1. 确定dp数组以及下标的含义：

dp[i][0] 和 dp[i][1]分别表示下标i处的字符为0和1的情况下使得s[0..i]单调递增的最小翻转次数。

1. 确定递推公式：

- 如果s[i] == '1'，有`dp[i][0] = dp[i-1][0]`
- 如果s[i] == '0'，有`dp[i][1] = min(dp[i-1][0], dp[i-1][1]) + 1`

1. 初始状态：

- 如果 s[i] == '0'，即 dp[i][0] = 0
- 如果 s[i] == '1'，即 dp[i][1] = 1

等价于代码中的count的处理

1. 返回值：dp[i][0]和dp[i][1]中间的最小值

- > 代码中直接用dp变量进行记录最小反转次数

- > 注：上述只是为了方便理解用了dp[i],由于dp[i] 的值只和dp[i−1] 有关，所以可以进行状态压缩

```C++
    int minFlipsMonoIncr(string s) {
        int dp = 0;
        if(s.size() == 1) return dp;
        int count = 0;
        if(s[0] == '1') count = 1;
        for(int i = 1; i < s.size(); i++) {
            if(s[i] == '1') count++;
            else dp = min(dp + 1, count);
        }
        return dp;
    }
```



#### [剑指 Offer II 091. 粉刷房子](https://leetcode.cn/problems/JEj789/)

- > 相邻的房子颜色不相同，所以要动态规划

- > 用dp[i][j]表示第i+1个房子粉刷颜色j时，前i+1个房子的最小花费。那么，min{dp[n - 1][0, 1, 2]}就是答案（把第n个粉刷成3种颜色中的一个，前n个的最小花费）

- > 相邻两个方块颜色不能相同。因此递推公式：

  - > `dp[i][0] = min(dp[i - 1][1], dp[i - 1][2]) + costs[i][0]`

  - > `dp[i][1] = min(dp[i - 1][0], dp[i - 1][2]) + costs[i][1]`

  - > `dp[i][2] = min(dp[i - 1][0], dp[i - 1][1]) + costs[i][2]`

> 如果允许修改costs数组，可直接用costs来代替dp，`costs[i][j] += min(costs[i - 1][xx])`

```Prolog
class Solution {
public:
    int minCost(vector<vector<int>>& cs) {
        int n = cs.size();
        for (int i = 1; i < n; i++) {
            cs[i][0] += min(cs[i - 1][1], cs[i - 1][2]);
            cs[i][1] += min(cs[i - 1][0], cs[i - 1][2]);
            cs[i][2] += min(cs[i - 1][0], cs[i - 1][1]);
        }
        return min(cs[n - 1][0], min(cs[n - 1][1], cs[n - 1][2]));
    }
};
```









## [(3)背包 DP](https://github.com/SharingSource/LogicStack-LeetCode/wiki/背包-DP)

> 三叶的の背包系列 🍭🍭🍭 ：见1995题解文末

无法复制加载中的内容

#### [1995. 统计特殊四元组](https://leetcode-cn.com/problems/count-special-quadruplets/)：暴力 / 哈希⭐ / 背包

![img](https://uestc.feishu.cn/space/api/box/stream/download/asynccode/?code=MjJkY2I4N2M2MTM3OWE1NzhmMzNlOGQ1NDY3Zjc5NGZfTURTOFhEMHRmMlQ2MlRrVk1LRkM5a1Bkbnh0WGVKbVhfVG9rZW46Ym94Y24xN1NwbndtVmd0WFhmWWdsd2ZUdFNwXzE2NjI2NDE5MTI6MTY2MjY0NTUxMl9WNA)

> 和LC第一题有异曲同工之处。枚举左边两者和，枚举右边两者差，动态更新相同数目到答案。

> 另外同样可以采用背包动态规划思想，我们要**选三个**到背包里，维护不选的各个值的个数、选一个各个值的个数、选两个各个值的个数、选三个各个值的个数。

> 在遍历到每个数，统计选三个了的各值中该数的个数就是答案的一部分。

**法2.1：哈希，使用哈希表存储nums[d]**

```C++
class Solution {
public:
    int countQuadruplets(vector<int>& nums) {
        int n = nums.size();
        int ans = 0;
        unordered_map<int, int> cnt;  // 使用哈希表存储nums[d]
        for(int c = n-2; c >= 2; --c){
            cnt[nums[c + 1]]++;
            for(int a = 0; a < c; ++a){
                for(int b = a + 1; b < c; ++b){
                    ans += cnt[nums[a] + nums[b] + nums[c]];  //⭐
                }
            }
        }
        return ans;
    }
};
```

**法2.2：哈希，作为两数之和的进阶版本，nums[a] + nums[b] = nums[d] - nums[c]**

引：运用两数之和的思想（python用Counter来当作哈希表！！）

```Python
class Solution:
    def countQuadruplets(self, nums: List[int]) -> int:
        l, ans = Counter(), 0
        for i in range(1, len(nums) - 2):
            # 到目前为止统计了所有0到i的两坐标和
            for j in range(i):
                l[nums[i] + nums[j]] += 1
            # 目前第三个坐标为i+1，枚举第四个坐标j的范围
            for j in range(i + 2, len(nums)):
                # 叠加以前统计的左半段和的结果，i+1作为第三个idx和j最多组成这么多
                ans += l[nums[j] - nums[i+1]]
        return ans
class Solution {
public:
    int countQuadruplets(vector<int>& nums) {
        int n = nums.size();
        unordered_map<int, int> cnt;
        int ans = 0;

        for (int b = n - 3; b >= 1; b--) {
            int c = b + 1;
            for (int d = c + 1; d < n; d++) {
                cnt[nums[d]-nums[c]]++;  //存哈希
            }
            for (int a = 0; a < b; a++) {
                ans += cnt[nums[a]+nums[b]];  //找哈希
            }
        }
        return ans;
    }
};
```

**法3：多维背包?**













## [(4)序列 DP](https://github.com/SharingSource/LogicStack-LeetCode/wiki/序列-DP)

无法复制加载中的内容

#### [472. 连接词](https://leetcode-cn.com/problems/concatenated-words/)：没做，困难

![img](https://uestc.feishu.cn/space/api/box/stream/download/asynccode/?code=ZWMxOGE5ODZlYWNjMmE1ZWRlNTU3OGNjMTI1MDBiYzhfeVBtOFU0c1oyR1I1eDN5czJrR2xNNjZZc3VMaXJRZnhfVG9rZW46Ym94Y25JakZzZEZROUtJMDVJQ053Ukp1Y3FlXzE2NjI2NDE5MTI6MTY2MjY0NTUxMl9WNA)















## [(5)区间 DP](https://github.com/SharingSource/LogicStack-LeetCode/wiki/区间-DP)

#### [730. 统计不同回文子序列](https://leetcode.cn/problems/count-different-palindromic-subsequences/)：枚举边缘字符

- > 枚举边缘字符的区间 DP 运用题

- > 这是一道困难题，真的比较难想出来

- > “通过从 s 中删除 0 个或多个字符来获得子序列。”

- > 与其说回文，更像是“轴对称”

![img](https://uestc.feishu.cn/space/api/box/stream/download/asynccode/?code=YjI0OWE1YzgxZGVlZjMzZWYzZjFlN2YwMTEwNjc1M2VfcG5tUU9CcGhBeDFua1hiTVNwZWNIU0MzeTBHWkdjbk9fVG9rZW46Ym94Y25PNHhmM2RHNmtNT0c3ZGRFNzF2WHNlXzE2NjI2NDE5MTI6MTY2MjY0NTUxMl9WNA)

![img](https://uestc.feishu.cn/space/api/box/stream/download/asynccode/?code=ZjQ3NTBjMGRiNmQwMDk3NDYzY2JiOGQwNmU5MjZlOWRfWU5BUlh2eTRXb1ZRWVhyaDRlSzFHTThtZkljUzlSMnZfVG9rZW46Ym94Y25DZHk0V2VEdlhCZ3lNcjRubHUzRmhiXzE2NjI2NDE5MTI6MTY2MjY0NTUxMl9WNA)

**一个不错的讲解：**

由于长字符串会依赖短字符串的回文序列数量，所以我们可以采用动态规划来实现。

设**dp[i][j]**表示字符串**从i到j的回文序列个数**，我们可以将长字符串看作短字符串左右加上两个字符

于是我们有`s[i,j] = s[i] + s [i+1,j-1] + s[j]`，如："bccb" 可以看作 "cc"两边分别加上"b"，此时我们分情况进行讨论：

(1) 若s[i] == s[j]，相当于我们给s[i+1,j-1] 左右加上两个相同的字符，然后我们计算回文序列的个数

- ① s[i+1,j-1]中没有字符和s[i]相等（bcb+aa）

设有字符串"bcb"，则"bcb"的回文子序列是：b、c、bb、bcb

若两边加上相同的字符，相当于给"bcb"的回文子序列左右各加一个相同字符，仍然构成回文子序列。假设我们给"bcb"左右加一个字符"a"，则相当于给"bcb"的子序列都左右加一个字符可构成新的回文子序列。

![img](https://uestc.feishu.cn/space/api/box/stream/download/asynccode/?code=ODk0MWYwODY1MmY2OTdkMjg1OWQzNTk2NjA2MTJkZjJfaU1qZmdwVjFHZnM1MVdlZzNHVkR2S1UyU01uZ0dISDNfVG9rZW46Ym94Y25yTDd1a3pNTkZHb1J1OHRQWEcxaWFoXzE2NjI2NDE5MTI6MTY2MjY0NTUxMl9WNA)

再加上"a"(字符本身就是一个回文子序列)和"aa"(两个相同字符的回文子序列)

所以此时dp[i][j] = 2dp[i+1][j-1] + 2（本身的4个+新生成的4个+2个单独生成的）

- ② s[i+1,j-1]中有一个字符和s[i]相等（bcb+bb）

假设有一个字符相等，则之前已经记录了此单字符的回文子序列(只能加上"aa"，不能加"a")

所以此时dp[i][j] = 2dp[i+1][j-1] + 1（本身的4个+新生成的4个+1个单独生成的）

- ③ s[i+1,j-1]中有两个及以上字符和s[i]相等

若有两个及以上的字符,则我们需要找到其位置，并**删掉重复计算的回文子序列**，并且两个单独的之前也已经计算。

假设有字符串"dabcbad"，我们向两边加入字符"a"

则此时的"a"字符会和中间的"bcb"组成重复的回文子序列，因为之前已经有"a"和"bcb"组成回文子序列

![img](https://uestc.feishu.cn/space/api/box/stream/download/asynccode/?code=NDk3MDAxZWJkZWFkYzU2NzZhZTk2NGU1YmE4YTQ5OWFfRGo1ZFA2bHFjNFRmdmpka05hclNneWVBTnJEN0N6enNfVG9rZW46Ym94Y25xMGJMVnM3UU55V1hReXo5eUttT0dkXzE2NjI2NDE5MTI6MTY2MjY0NTUxMl9WNA)

![img](https://uestc.feishu.cn/space/api/box/stream/download/asynccode/?code=NzI5MTFkYjc5ZGZkNWFhYmYxYjVkYjk4MTI0YzFkMjZfdUFDOHpkbWxSWDg3OVVsVjlIbGpaUWowSmRwOFllc2NfVG9rZW46Ym94Y254OVJrVUtxVDJQckVFeWNiaUEwUnJoXzE2NjI2NDE5MTI6MTY2MjY0NTUxMl9WNA)

(2) 若s[i] != s[j]，则我们给之前任何一个回文子序列左右加上s[i]和s[j]都不能组成回文子序列，只能单独计算

![img](https://uestc.feishu.cn/space/api/box/stream/download/asynccode/?code=YjQxYTc2NzEyZWE2NzAxYzk3NDVjMGJkYjc0YTUzNjRfaXUyNWpCQzR5anVLWVJLTG9udG1jQzhtd3lpd2hzZTBfVG9rZW46Ym94Y241YmJaTVNXeEF6Sjg4cnRPb3FBVTVlXzE2NjI2NDE5MTI6MTY2MjY0NTUxMl9WNA)

综上所述，状态转移方程为：

![img](https://uestc.feishu.cn/space/api/box/stream/download/asynccode/?code=ZmNlODUwNDgxZjBlZjMxNDdhMzFiYzJmMGFiZWUzYjFfdUNHVWkxVVZ4Z25HOWZ3and4NHc5Z2Y2d2lZOFlsWkVfVG9rZW46Ym94Y25uMTlDSmVqazg5ak9IY2NQbGNCZlJjXzE2NjI2NDE5MTI6MTY2MjY0NTUxMl9WNA)









## [(6)状压 DP](https://github.com/SharingSource/LogicStack-LeetCode/wiki/状压-DP)

## [(7)状态机 DP](https://github.com/SharingSource/LogicStack-LeetCode/wiki/状态机-DP)

## [(8)数位 DP](https://github.com/SharingSource/LogicStack-LeetCode/wiki/数位-DP)









# 贪心 ⭐

- > 贪心的思想是：通过局部最优达到全局最优

#### [435. 无重叠区间](https://leetcode-cn.com/problems/non-overlapping-intervals/)：区间贪心

![img](https://uestc.feishu.cn/space/api/box/stream/download/asynccode/?code=ZTExNjRkNDEwYTlhYmQxZTNlMzBhYjg2Y2Q1Y2RhZGRfREw3V2k5aDVWTEtKMUJLazRXWTl4dkYxUW9BOUdCdWpfVG9rZW46Ym94Y25EckhEbnpwZTVMWjNCbG1GR1ZiZjVkXzE2NjI2NDE5MTI6MTY2MjY0NTUxMl9WNA)

要找移除得最小数量，

**法1：按照右边界排序，则****从左向右遍历，优先选右边界小的**

```C++
class Solution {
public:
    // 按照区间右边界<排序，自己写一个排序规则！
    static bool cmp (const vector<int>& a, const vector<int>& b) {
        return a[1] < b[1];
    }
    int eraseOverlapIntervals(vector<vector<int>>& intervals) {
        if (intervals.size() == 0) 
            return 0;
        
        sort(intervals.begin(), intervals.end(), cmp);
        // 从左向右遍历，优先选右边界小的
        int cnt = 1;  // 记录非交叉区间的个数
        int end = intervals[0][1];  // 第一个的右边界
        // 从下一个开始遍历
        for (int i = 1; i < intervals.size(); i++) {
            // 如果左边不符合条件，下一个
            // 如果左边界符合条件：符合，更新end
            if (intervals[i][0] >= end) {
                end = intervals[i][1];
                cnt++;
            }
        }
        return intervals.size() - cnt;
    }
};
class Solution:
    def eraseOverlapIntervals(self, intervals: List[List[int]]) -> int:
        n = len(intervals)
        if n == 0: return 0
        intervals.sort(key=lambda x: x[1]) #按右边界排序
        end = intervals[0][1] #最左元素的右边界作为基准
        cnt = 1 

        #记录非交叉区间的个数 局部最优：从左向右(优先考量右边界小的区间) 
        for i in range(1,n):
            if intervals[i][0] >= end: #不交叉
                cnt += 1 
                end = intervals[i][1]            
        return n - cnt
```



**法2：按照左边界排序，则****从右向左遍历，优先选左边界大的**

```Python
class Solution:
    def eraseOverlapIntervals(self, intervals: List[List[int]]) -> int:
        n = len(intervals)
        if n == 0: return 0

        intervals.sort(key=lambda x: x[0]) # O(nlogn) 按左边界排序
        leftend = intervals[n-1][0] # 选取左边界最大的元素作为基准
        cnt = 1 

        for i in range(n-2,-1,-1):
            if intervals[i][1] <= leftend: 
                cnt += 1
                leftend = intervals[i][0]

        return n - cnt
```

**法3：动态规划**

![img](https://uestc.feishu.cn/space/api/box/stream/download/asynccode/?code=N2U1ODAxZDdiMTRlYTRlNWM0Y2I1MTE1ZjBjODFiZjRfV0dZekxMdkRmOVJ5UGc4cGhrSU5LaDN5R2ExNFEyaTBfVG9rZW46Ym94Y25ZQXpDbTl0ZUlQTXF2R1g2VWpmZ3FnXzE2NjI2NDE5MTI6MTY2MjY0NTUxMl9WNA)



#### [462. 最少移动次数使数组元素相等 II](https://leetcode.cn/problems/minimum-moves-to-equal-array-elements-ii/)：中位数

![img](https://uestc.feishu.cn/space/api/box/stream/download/asynccode/?code=MmZjYTVhYjM1YzhjMDQzYWE1OGFkMzFmYTVkYzZiMTlfa0NwSVROQnYyUklnWXdjeXI3MTB3aFg4ampMdzZsWmxfVG9rZW46Ym94Y241eUZKVjNnb2JjR25FSWZOUWI0OHpoXzE2NjI2NDE5MTI6MTY2MjY0NTUxMl9WNA)

> 准确来说没有用到贪心，

> 设从小到大的数列{x1,x2,...,xn}，设x是从x1到xn与其绝对差之和最小的数，显然x∈[x1,xn]

> ∵x1，xn与它们之间的任意一点的距离之和都相等，且都等于xn-x1，因此接下来可以不考虑x1与xn

> 而又∵中位数是离数列中最中间那个数距离最小的那个

> ∴**用中位数来**...

```C++
class Solution {
public:
    int minMoves2(vector<int>& nums) {
        sort(nums.begin(), nums.end());
        int n = nums.size(), mid = nums[n / 2];
        int ans = 0;
        for (int i = 0; i < n; ++i) {
            ans += abs(nums[i] - mid);
        }
        return ans;
    }
};
```



#### [553. 最优除法](https://leetcode-cn.com/problems/optimal-division/)：数学+贪心

![img](https://uestc.feishu.cn/space/api/box/stream/download/asynccode/?code=YjMwMzBmODgzNDk3ZGE2ODY4MWYzMzNhYmRjNWQ3YWJfbUt5RmgyaG5yZzROUlFDeUFqeElDRnhOcU5Ya08zc3ZfVG9rZW46Ym94Y25JS0Jjc01RcUlKVXdGYzFLTDB2R3lnXzE2NjI2NDE5MTI6MTY2MjY0NTUxMl9WNA)

**思路：**不管怎么添加括号，第一个数字永远是唯一的分子，而第二个数字永远是分母的一部分。

分子是不能变大的，要想尽可能大，只能从分母入手，把分母变得尽可能小。

而这显然只需要让第二个数字尽可能地除后面越多的数越好（因为都是正整数）。

【三叶】の题解：

![img](https://uestc.feishu.cn/space/api/box/stream/download/asynccode/?code=MDcwMDdmZWJkYmU1ODIwNDhiZTNkMmM3YjM4YTFhZWRfMnpzUEtBcWFyY0k0Sm9Palg0Zll2cEU1SHhBNVlxQjRfVG9rZW46Ym94Y25lb0ZZeXhUWXpqNG5yZENNSmtJV0ZmXzE2NjI2NDE5MTI6MTY2MjY0NTUxMl9WNA)

由此：只要nums长度>2，把后面的统一加上括号

```C++
class Solution {
public:
    string optimalDivision(vector<int>& nums) {
        int n = nums.size();
        string ans = "";

        if (n == 1) return to_string(nums[0]);
        if (n == 2) return to_string(nums[0]) + '/' + to_string(nums[1]);
        else {
            ans += to_string(nums[0]) + "/(";
            for (int i = 1; i < n; ++i) {
                ans += to_string(nums[i]) + '/';
            }
            ans.pop_back();
            ans.push_back(')');
        }
        return ans;
    }
};
```



#### [768. 最多能完成排序的块 II](https://leetcode.cn/problems/max-chunks-to-make-sorted-ii/)：贪心+哈希

- > 将数组序列拆分为多少块，仍有序：

- > 如何判断一个数组是否能分为符合题意的两块呢？

**思路1：**

如果一个数组能分为两块，那么一定能找到一个下标k，这个下标将数组分为两个非空子数组arr[0,…,k] 和arr[k+1,…,n−1]，使得arr[0,…,k] 和sortedArr[0,…,k] 的元素频次相同，arr[k+1,…,n−1] 和sortedArr[k+1,…,n−1] 的元素频次相同。

判断能否分为更多的块时同理。这个判断过程可以从左至右同时遍历 arr 和 sortedArr，并**用一个哈希表来记录两个数组元素频次之差**。

当遍历到某个下标时，如果哈希表内所有键的值均为0，则表示划分出了一个新的块，最后记录有多少下标可以使得哈希表内所有键的值均为0即可。

（其实，主要思想就是与排好序的而数组进行比较）

```C++
class Solution {
public:
    int maxChunksToSorted(vector<int>& arr) {
        vector<int> arr_sorted = arr;
        sort(arr_sorted.begin(), arr_sorted.end());
        int n = arr.size();
        int ans = 0;
        unordered_map<int, int> umap;
        for (int i = 0; i < n; i++) {
            int a = arr[i], sa = arr_sorted[i];
            umap[a]++;
            if (umap[a] == 0) umap.erase(a);
            
            umap[sa]--;
            if (umap[sa] == 0) umap.erase(sa);
            
            if (umap.size() == 0) ans++;
        }
        return ans;
    }
};
```

**思路2：**

```C++
class Solution {
public:
    // 寻找局部最大值，用栈来存块的最大值
    // 下一个比之前的小，就算不是局部最大的
    int maxChunksToSorted(vector<int>& arr) {
        stack<int> st;
        for (int a : arr) {
            if (st.empty() || a >= st.top()) {
                st.push(a);
            } else {
                int t = st.top();
                st.pop();
                while (!st.empty() && st.top() > a) st.pop();
                st.push(t);
            }
        }
        return st.size();
    }
};
```





#### [807. 保持城市天际线](https://leetcode-cn.com/problems/max-increase-to-keep-city-skyline/)：python官方写法？

![img](https://uestc.feishu.cn/space/api/box/stream/download/asynccode/?code=ZDM3N2U4YmM3NzdhNmU0N2QxMDNlNWFmMTQwODU2MmJfOVFCSmsxczg2WmJQTGRiMTZVZENYR2l3bEl4OFBFTVpfVG9rZW46Ym94Y25RT2I1SXBjOXFhWHpNTkNjeGVkZ3NoXzE2NjI2NDE5MTI6MTY2MjY0NTUxMl9WNA)

![img](https://uestc.feishu.cn/space/api/box/stream/download/asynccode/?code=M2NiM2JmNDA3MGYxMTUxMDM0NTI5ZTY4ZTFhZDhmZTBfcXlTZ3dDaVhPQzNXV25aRDhyb21LRDBDaldKR1lsWHpfVG9rZW46Ym94Y25MRHZvRVhZZlJQdWFlZEVvUWFrSnRoXzE2NjI2NDE5MTI6MTY2MjY0NTUxMl9WNA)

![img](https://uestc.feishu.cn/space/api/box/stream/download/asynccode/?code=MGFmYTVmZDk0MTA5ODc2MDllNzU0NzU2ZjY2M2NjNTdfZ090ZVBaNDlFbkN1OVcxSld4anVBdTY4VlllY0UxOUpfVG9rZW46Ym94Y25nZlA2SnZXZ0RoWkx3N1U2Z2tJTDdiXzE2NjI2NDE5MTI6MTY2MjY0NTUxMl9WNA)

C++的写法很正常

```C++
class Solution {
public:
    // 变为所在行列，最大高度里的最小者
    int maxIncreaseKeepingSkyline(vector<vector<int>>& grid) {
        int n = grid.size(); //n行，其实也是n列
        vector<int> rowMax(n);
        vector<int> colMax(n);
        for(int i = 0; i < n; ++i){
            for(int j = 0; j < n; ++j){
                rowMax[i] = max(rowMax[i], grid[i][j]);
                colMax[j] = max(colMax[j], grid[i][j]);
            }
        }
        int ans = 0; // 最大高度增量总和
        // 遍历整个矩阵的第i行，第j列
        for (int i = 0; i < n; i++){
            for (int j = 0; j < n; j++){
                ans += min(rowMax[i], colMax[j]) - grid[i][j];
            }
        }
        return ans;
    }
};
class Solution:
    def maxIncreaseKeepingSkyline(self, grid: List[List[int]]) -> int:
        rowMax = list(map(max, grid))
        colMax = list(map(max, zip(*grid)))
        return sum(min(rowMax[i], colMax[j]) - h for i, row in enumerate(grid) for j, h in enumerate(row))
```



#### [630. 课程表 III](https://leetcode-cn.com/problems/course-schedule-iii/)：注意贪心的思想和实现 ⭐

![img](https://uestc.feishu.cn/space/api/box/stream/download/asynccode/?code=NTQ3ZjA0ZDUxOTI5ZDEwMGMwY2E2ZDJhYzUwMWJmNzNfSXpwMFNudzB0QU84M2hZT0NOWUZaYVNZejlkQXhOVDhfVG9rZW46Ym94Y25TdHk3ZWdmVDVORXN3WUNBZmlBNWhjXzE2NjI2NDE5MTI6MTY2MjY0NTUxMl9WNA)

**贪心**：就是默认前面已经是最优的前提下，继续考虑

要考虑两个一级条件：

- 1.趁着ddl前，当前能修则修
- 2.在都能修的都修了（这个不能再修了）的前提下，看能否把持续时间长的某一个替换出来：
  - 把曾经duration长的换成新的，反正数量不会再变了

```C++
class Solution {
public:
    int scheduleCourse(vector<vector<int>>& courses) {
        sort(courses.begin(), courses.end(), [](const auto& a, const auto& b){return a[1] < b [1];});

        priority_queue<int> q;
        int t_now = 0; // 修完某门课后的时间，也是下一门课的开始时间
        for (auto course: courses) {
            if (course[1]-course[0] >= t_now) {
                // 可以修
                t_now += course[0];
                q.push(course[0]);
                continue;
            }
            if (!q.empty() && q.top() > course[0]) {
                // 在当前课程可以修的前提下，进一步看duration最长的那个是否被修了
                t_now -= q.top();
                t_now += course[0];
                q.pop();
                q.push(course[0]);
            }        
        }
        return q.size();
    }
};
```

python的实现注意语法，

```Python
class Solution:
    def scheduleCourse(self, courses: List[List[int]]) -> int:
        courses.sort(key=lambda c: c[1])

        q = list()
        t_now = 0  # 优先队列中所有课程的总时间

        for ti, di in courses:
            if t_now + ti <= di:
                t_now += ti
                # Python 默认是小根堆
                heapq.heappush(q, -ti)
            elif q and -q[0] > ti:
                t_now -= -q[0] - ti
                heapq.heappop(q)
                heapq.heappush(q, -ti)

        return len(q)
```



#### [942. 增减字符串匹配](https://leetcode.cn/problems/di-string-match/)：构造折线

> 直接从0开始构造，然后整体上下移动

```C++
vector<int> diStringMatch(string s) {
    int n = s.size();
    int min = 0, max = 0;
    vector<int> ans(n + 1, 0);
    for (int i = 0; i < n; i++) {
        if (s[i] == 'I')
            ans[i + 1] = ++max;
        else
            ans[i + 1] = --min;
    }
    for (int &a : ans) a -= min;  //必须加上引用，不然vector没有改
    return ans;
}
```

![img](https://uestc.feishu.cn/space/api/box/stream/download/asynccode/?code=ZTYxMDA0NzU4N2M4ZTMwMDI2Yzg5NTIzY2Y0NzkwNzVfVk9XVzUwSzlPalRXQU12T1hXVko4elA2b25ZZFY1cDFfVG9rZW46Ym94Y244S2dYTnM1SUVsbk9YeDVjNEduV0ZmXzE2NjI2NDE5MTI6MTY2MjY0NTUxMl9WNA)



#### [1217. 玩筹码](https://leetcode.cn/problems/minimum-cost-to-move-chips-to-the-same-position/)

> 移动位置，计算最小代价

法1：贪心，直接遍历

```C++
class Solution {
public:
    // 移动两格代价是0，医用一格代价是1：(a-b)%2
    int minCostToMoveChips(vector<int>& pos) {
        int n = pos.size();
        int ans = INT_MAX;
        for (int i = 0; i < n; i++) {
            int cur = 0;
            for (int j = 0; j < n; j++) {
                cur += abs(pos[i] - pos[j]) % 2;
            }
            ans = min(ans, cur);
        }
        return ans;
    }
};
```

**法2：贪心 + 统计奇偶性**

更进一步，我们可以发现要使得「总的移动成本最优」的目标位置有无数个，只要目标位置的奇偶性不变，即可确保总成本不变。

因此我们可以省去枚举具体位置的操作，转而统计原有数的奇偶位置个数，假设偶数位置有a个，奇数位置有b个，最终目标位置选为偶数的成本为b，最终目标位置选为奇数的成本为a，即两者中的最小值即是答案。

```C++
class Solution {
public:
    int minCostToMoveChips(vector<int>& pos) {
        int n = pos.size();
        int a = 0;
        for (int p : pos) a += p % 2;
        return min(a, n - a);
    }
};
```



#### [1403. 非递增顺序的最小子序列](https://leetcode.cn/problems/minimum-subsequence-in-non-increasing-order/)：简单贪心运用

```C++
class Solution {
public:
    vector<int> minSubsequence(vector<int>& nums) {
        sort(nums.begin(), nums.end());
        int sum = 0;
        for (int i : nums) sum += i;
        vector<int> ans;
        int idx = nums.size() - 1;
        int cur = 0;
        while (cur <= sum) {
            sum -= nums[idx];
            cur += nums[idx];
            ans.push_back(nums[idx--]);
        }
        return ans;
    }
};
```



#### [1405. 最长快乐字符串](https://leetcode-cn.com/problems/longest-happy-string/)：❗优先级队列 pair

![img](https://uestc.feishu.cn/space/api/box/stream/download/asynccode/?code=YTFkODg4NjlkZmY3ZDkxMGY4ZTIwNGJhZmJmNTQ1ZjJfRmRzVFY3dlhJWklaekM2YXE5ZmdiUUdTUEdjVVpSTnRfVG9rZW46Ym94Y25IREp4SzVCU3R4MzhtckdNMmo5aFNiXzE2NjI2NDE5MTI6MTY2MjY0NTUxMl9WNA)

（好在只有3个字符），

**优先使用剩余数量最多的字符**

来自【三叶】の题解：

![img](https://uestc.feishu.cn/space/api/box/stream/download/asynccode/?code=MTUyMWZiYWNlYTA4ODQ2ZjIwZjYyZWQ0Y2Y1ZmIxOGJfU0pocWo3Z2hXeFJEMkRyUURXdXNWVTR5NGdDYzRPanBfVG9rZW46Ym94Y25vTmxiN1hpRlQ0eDd6TFE5NG9sOEdmXzE2NjI2NDE5MTI6MTY2MjY0NTUxMl9WNA)

按照这个思路，写出如下解法：

```C++
class Solution {
public:
    // 根本思想：贪心！！
    // 用优先队列，这样就“自动地”保证了：每次取出字符都要进行判断数量 ==> 大根堆⭐
    // 每次取堆顶元素（剩余数量最多的元素）
    string longestDiverseString(int a, int b, int c) {
        priority_queue<pair<int, int>, vector<pair<int, int>>, cmp> q;
        if (a > 0) q.push({0, a});  // a,b,c分别是它们对应的数量，0,1,2用来表示编号
        if (b > 0) q.push({1, b});
        if (c > 0) q.push({2, c});
        string ans;
        while (!q.empty()) {
            pair<int, int> cur = q.top();
            q.pop();
            int n = ans.size();
            if (n >= 2 && ans[n-1]-'a'==cur.first && ans[n-2]-'a'==cur.first) {  // 连续两个和当前最多的相同
                if (q.empty()) break;  // 如果q中无其他字符pair，则退出循环
                pair<int, int> next = q.top();
                q.pop();
                ans.push_back('a'+next.first);  // 把第二多的字符添加进ans
                // 再看第二多的字符是否还有剩余？还有剩余则更新数量重新入堆
                if (--next.second != 0) q.push(next);  // 只有next变化了，所以只更新它即可
                q.push(cur);  // 同时将此前取的最多字符pair也重新入堆⭐
            }
            else {
                // 不违反连续三个字符相同，则说明当前字符能够追加到当前答案尾部
                ans.push_back('a'+cur.first);
                // 若追加后还有字符剩余，则更新剩余数量重新入堆
                if (--cur.second != 0) q.push(cur);
            }
        }
        return ans;
    }


    struct cmp {
        template <typename T, typename U>
        bool operator()(T const &left, U const &right) {
            if (left.second < right.second)
                return true;
            return false;
        }
    };

};
```

升序队列，小根堆：`priority_queue <int,vector<int>,greater<int> > p;`

降序队列，大根堆：`priority_queue <int,vector<int>,less<int> >q;`

对于基础数据类型，默认是大顶堆：`priority_queue<int> r;    //等同于 priority_queue<int, vector<int>, less<int> > r;`

- > 自定义一个优先队列的排序方法：

- > 因为**pair的优先级队列**都是**先first升序，再second升序**

- > https://blog.csdn.net/u014257954/article/details/78623215

- > https://blog.csdn.net/ruohua3kou/article/details/97070552?spm=1001.2014.3001.5501

**其实还能写得简单一些：**

```C++
class Solution {
public:
    // 根本思想：贪心！！
    // 用优先队列，这样就“自动地”保证了：每次取出字符都要进行判断数量 ==> 大根堆⭐
    // 每次取堆顶元素（剩余数量最多的元素）
    string longestDiverseString(int a, int b, int c) {
        priority_queue<pair<int, int>> q;
        if (a > 0) q.push({a, 0});  // a,b,c分别是它们对应的数量，0,1,2用来表示编号
        if (b > 0) q.push({b, 1});
        if (c > 0) q.push({c, 2});
        string ans;
        while (!q.empty()) {
            pair<int, int> cur = q.top();
            q.pop();
            int n = ans.size();
            if (n >= 2 && ans[n-1]-'a'==cur.second && ans[n-2]-'a'==cur.second) {  // 连续两个和当前最多的相同
                if (q.empty()) break;  // 如果q中无其他字符pair，则退出循环
                pair<int, int> next = q.top();
                q.pop();
                ans.push_back('a'+next.second);  // 把第二多的字符添加进ans
                // 再看第二多的字符是否还有剩余？还有剩余则更新数量重新入堆
                if (--next.first != 0) q.push(next);  //只有next变化了，所以只更新它即可
                q.push(cur);  // 同时将此前取的最多字符pair也重新入堆⭐
            }
            else {
                // 不违反连续三个字符相同，则说明当前字符能够追加到当前答案尾部
                ans.push_back('a'+cur.second);
                // 若追加后还有字符剩余，则更新剩余数量重新入堆
                if (--cur.first != 0) q.push(cur);
            }
        }
        return ans;
    }
};
```

**python也有一种朴素一点的写法：**

```Python
class Solution:
    def longestDiverseString(self, a: int, b: int, c: int) -> str:
        # 字符不需要用完
        stack = []
        h = [] # 
        if a: h.append([a,"a"])
        if b: h.append([b,"b"])      
        if c: h.append([c,"c"])
            
        h.sort()
        def check(ele): 
            if len(stack) >= 2 and stack[-1] == ele and stack[-2] == ele:
                return False 
            return True 
        
        while h:
            times,ele = h.pop()
            if check(ele):
                stack.append(ele)
                times -= 1
                if times != 0:
                    h.append([times,ele])
                    h.sort() # 暴力的点
            else:
                if h:
                    times2,ele2 = h.pop()
                    stack.append(ele2)
                    times2 -= 1
                    if times2 != 0:
                        h.append([times2,ele2])
                    h.append([times,ele])
                    h.sort() # 暴力的点
                else:
                    break

        return "".join(stack)
```





#### [1414. 和为 K 的最少斐波那契数字数目](https://leetcode-cn.com/problems/find-the-minimum-number-of-fibonacci-numbers-whose-sum-is-k/)：分治？递归？硬做？

一个思想就是：首先找到所有**不超过k**的斐波那契数字，然后每次贪心地选取不超过k的最大斐波那契数字，将k减去该斐波那契数字，重复该操作直到k变为0，此时选取的斐波那契数字满足和为k且数目最少。

![img](https://uestc.feishu.cn/space/api/box/stream/download/asynccode/?code=OTAwYzk2ZDU5N2I5ZjFhNzZlZTdmMmU1NTQ2NjhkOTRfUDI5M2s1TGFZc3k5c2N1VUUyTk5hSGd5dDdGdGx4ckRfVG9rZW46Ym94Y24yemNueThGMVZ4bkp4T2pMbmRoMDFmXzE2NjI2NDE5MTI6MTY2MjY0NTUxMl9WNA)

**一种解法：贪心**

```C++
class Solution {
public:
    int findMinFibonacciNumbers(int k) {
        int a = 1, b = 1;
        int ans = 0;
        // 找到比 k 小的最大的 b
        while(b <= k){
            int c = a + b;
            a = b, b = c;
        }
        while(k != 0){
            if(k >= b){
                k -= b;
                ans++;
            }
            int c = b - a;
            b = a, a = c;
        }
        return ans;
    }
};
```

**另一种解法：分治+递归**

```Java
class Solution {
public:
    int findMinFibonacciNumbers(int k) {
        if(k == 0) 
            return 0;
        int a = 1, b = 1;
        // 找到比k小的最大的b
        while(b <= k){
            int c = a + b;
            a = b, b = c;
        }
        return 1 + findMinFibonacciNumbers(k-a);
    }
};
class Solution:
    def findMinFibonacciNumbers(self, k: int) -> int:
        if not k:
            return 0
        f1, f2 = 1, 1
        while f2 <= k:
            f1, f2 = f2, f1 + f2
        return 1 + self.findMinFibonacciNumbers(k - f1)
```



#### [1705. 吃苹果的最大数目](https://leetcode-cn.com/problems/maximum-number-of-eaten-apples/)：贪心 优先队列/map

贪心：优先吃快要过期的🍎，设置一个苹果堆来存放

![img](https://uestc.feishu.cn/space/api/box/stream/download/asynccode/?code=NDM4Njg1ZjgyOWMwZjZlMWVmODVkZGY4MDZlYzBjYmFfSWZoVVlWR1RWYWl6RDhKM0hJMmNoNkd4ejVGc3hTQXNfVG9rZW46Ym94Y25oRVVEVmlQNlRVMGFSNGlmNk8yVmtmXzE2NjI2NDE5MTI6MTY2MjY0NTUxMl9WNA)

```C++
class Solution {
public:
    int eatenApples(vector<int>& apples, vector<int>& days) {
        int ans = 0;
        int d = 0, alldays = days.size();
        // 升序的一个苹果堆，pair(能吃到第几天,苹果数量)
        priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> q;
        while (d < alldays || !q.empty()) {
            if (d < alldays) 
                q.push(make_pair(days[d]+d-1, apples[d]));
            auto apple = q.top();
            // 跳过所有已经过期的苹果
            while (apple.first < d) { //对过期的苹果的处理
                q.pop();
                if (q.size() == 0) break;
                apple = q.top();
            }
            // 如果当天没有可以吃的苹果了，等一天
            if (q.size() == 0) { 
                d++; 
                continue; 
            }
            // 如果有可以吃的苹果；我们要把这一天过期的苹果数量减1
            if (apple.second > 0) {
                q.pop();
                apple.second--;
                // 如果苹果还有剩余，我们把它放回堆中
                if (apple.second > 0) q.push(apple);
                ans++;

                // apple.second--;
                // ans++;
                // if(apple.second = 0) q.pop();
                // 这种方法是不对的！等于说队里面的没修改成功！
            }
            d++;
        }
        return ans;
    }
};
```

**另一种解法：使用map⭐**

由于TreeMap可以直接在过期日期上关联苹果数量；所以代码会简单的多。而我们只需要将取堆顶元素的操作换成取map第一个元素的操作即可。 

底层是红黑树；所有操作也是O(logn)的时间复杂度。

```C++
class Solution {
public:
    int eatenApples(vector<int>& apples, vector<int>& days) {
        int ans = 0;
        int d = 0;
        // 提高效率使用map
        map<int, int> m; // (expire, cnt)
        while (d < days.size() || !m.empty()) {
            if (d < days.size()) 
                m[days[d] + d - 1] += apples[d];           
            // 尝试从map中取出一个最接近过期但是没有过期的苹果
            while(!m.empty()) {
                if (m.begin()->first < d || m.begin()->second == 0) 
                    m.erase(m.begin()->first);
                else {
                    // 如果找到了 我们就吃掉它
                    ans++;
                    m.begin()->second--;  // 苹果数要减1
                    break;
                }
            }
            d++;
        }
        return ans;
    }
};
```

# 



# 脑筋急转弯

#### [419. 甲板上的战舰](https://leetcode-cn.com/problems/battleships-in-a-board/)：遍历地扫描

![img](https://uestc.feishu.cn/space/api/box/stream/download/asynccode/?code=ZDk1MGIxZGYyNzg1ZGQyOGQyMDMwM2IzMDY3YTQwNjVfVnp6N2ozcUZIbk5OaWE4aGd5TTVJWDFBRDE0MWVyckxfVG9rZW46Ym94Y25tZk0zSW5CTnVCWVVCQVl0UGtEZlpkXzE2NjI2NDE5MTI6MTY2MjY0NTUxMl9WNA)

方法二可以节省时间复杂度





# 区间求和

## (1)线段树

#### [729. 我的日程安排表 I](https://leetcode.cn/problems/my-calendar-i/)

不冲突加入日程返回true，冲突不加入日程返回false

法1：可以简单模拟

```C++
class MyCalendar {
public:
    vector<pair<int, int>> calen;
    MyCalendar() {}
    
    bool book(int start, int end) {
        for (auto [x, y] : calen) {
            if (x < end && y > start) return false;
        }
        calen.emplace_back(make_pair(start, end));
        return true;
    }
};
/**
 * Your MyCalendar object will be instantiated and called as such:
 * MyCalendar* obj = new MyCalendar();
 * bool param_1 = obj->book(start,end);
 */
```

> `push_back()`也是可以的





#### [731. 我的日程安排表 II](https://leetcode.cn/problems/my-calendar-ii/)



#### [732. 我的日程安排表 III](https://leetcode.cn/problems/my-calendar-iii/)

法1：硬做，挺好的

- > 本题意图：看作是多个日程区间有重叠，看需要并行地预定几个会议室

- > 升序优先队列，存放终点，结束的早的在前面

- > calendar已经按照起点顺序排序

```C++
class MyCalendarThree {
public:
    vector<pair<int, int>> calen;
    MyCalendarThree() {}
    static bool cmp(pair<int, int>& a, pair<int, int>& b) {
        return a.first < b.first;
    }
    int book(int start, int end) {
        calen.push_back(pair{start, end});
        sort(calen.begin(), calen.end(), cmp);
        int ans = 1, cnt = 0;
        priority_queue<int, vector<int>, greater<int>> q;  // 小根堆，升序
        for (auto c : calen) {
            q.push(c.second);
            cnt++;
            while (!q.empty() && q.top() <= c.first) {
                q.pop();
                cnt--;
            }
            ans = max(ans, cnt);
        }
        return ans;
    }
};
```

- > `static bool cmp(...)`必须加上static关键字



法2：线段树

法3：珂朵莉树

```C++
struct node {
    int l, r;
    mutable int v;
    node(int l, int r = 0, int v = 0) : l(l), r(r), v(v) {}
    bool operator < (const node& t) const {
        return l < t.l;
    }
};
class MyCalendarThree {
public:
    set<node> s;
    int mx = 0;
    auto split(int pos) {
        auto it = s.lower_bound(pos);
        if(it != s.end() && it->l == pos) return it;
        --it;
        int l = it->l, r = it->r, v = it->v;
        s.erase(it);
        s.insert(node(l, pos - 1, v));
        return s.insert(node(pos, r, v)).first;
    }
    int add(int l, int r) {
        auto right = split(r), left = split(l);
        for(auto itl = left;itl != right;itl++) {
            ++itl->v;
            mx = max(itl->v, mx);
        }
        return mx;
    }
    MyCalendarThree() {
        s.clear();
        mx = 0;
        s.insert(node(0, 1e9, 0));
    }
    
    int book(int start, int end) {
        return add(start, end);
    }
};
/**
 * Your MyCalendarThree object will be instantiated and called as such:
 * MyCalendarThree* obj = new MyCalendarThree();
 * int param_1 = obj->book(start,end);
 */
```









# 博弈论



#### [464. 我能赢吗](https://leetcode.cn/problems/can-i-win/)：博弈论 dp

题意：m个数累加，看谁先超过t

- > **二维博弈论 DP**

- > **记忆化递归**，就是保存已经知道的状态和结果，下一次遇到同样的参数就不用重新计算了

- > BitMap的再次使用

```C++
class Solution {
public:
    int f[1 << 20] = {0};  // state下当前玩家能否获胜，1能，-1不能
    bool dfs(int state, int sum, int m, int t) {
        if (f[state] != 0) return f[state] == 1 ? true : false;  // 状态记录下来
        for (int i = 0; i < m; i++) {
            if (((state >> i) & 1) == 1) continue;  // i被用过了
            if (sum + i + 1 >= t) {
                f[state] = 1;
                return true;
            }
            if (dfs((state | (1 << i)), sum + i + 1, m, t) == false) {  // 当前玩家选择i判断对方会输
                f[state] = 1;
                return true;
            }
        }
        f[state] = -1;
        return false;
    }
    bool canIWin(int m, int t) {
        if (m >= t) return true;
        if ((m + 1) * m / 2 < t) return false;
        return dfs(0, 0, m, t);
    }
};
```







#### [1728. 猫和老鼠 II](https://leetcode.cn/problems/cat-and-mouse-ii/)：记忆化搜索 dp

> **困难题：**记忆化搜索解决博弈类问题 ｜ 双方永远选择最有利自己的情况

**解题思路**

> 这种完全信息的博弈类游戏中，双方中必有一方有必不败策略。 Zermelo's theorem（策梅洛定理）

而去寻找最优策略最简单的做法就是进行**搜索**；而这种搜索要建立在双方都试图寻找最优解的基础上；也就是如果一方在某一步可以获得胜利，则他一定会选择可以获胜的下法。

我们在这种策略下，按照奇偶轮次逐一判断每个局面的情况即可。为了避免对同一局面的重复搜索；我们可以采用记忆化数组去记录每个局面的赢家是谁；每个“局面“就是一种状态；由猫鼠双方的位置+当前的轮次所决定。

搜索终点就是胜利确定的局面包括以下几种：

- m == c 说明猫抓住了老鼠，返回1
- m == f 说明猫先找到食物，返回1
- m == f 说明老鼠先找到食物；返回2

step > N 步长超过某个阈值，说明老鼠无法及时找到食物；返回1

在老鼠的轮次，如果移动一次有一个局面可以让老鼠获得胜利，则当前局面应该被标记为老鼠获胜的局面。

在猫的轮次，如果一动一次有一个局面可以让猫获得胜利，则当前局面应该被标记为猫获胜的局面。

显然，由于步数有上限，游戏一定有胜负；我们对每个局面进行搜索，理所应当可以确定当前局面的获胜者是谁。